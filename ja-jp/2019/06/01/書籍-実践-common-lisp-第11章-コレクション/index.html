<!DOCTYPE html>
<html lang="ja-jp" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta name="generator" content="Hugo 0.54.0" />
  <meta charset="utf-8">
  <title>書籍 実践 Common Lisp 第11章 コレクション · Lazy Lambda</title>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="この章について この章では、複数の値を1つのオブジェクトにまとめたデータ型(コレクション)について説明する。 11.1 ベクタ ベクタは、整数でインデック" />

  <meta name="keywords" content="programming, make" />

<link rel="canonical" href="https://otaon.github.io/web/ja-jp/2019/06/01/%E6%9B%B8%E7%B1%8D-%E5%AE%9F%E8%B7%B5-common-lisp-%E7%AC%AC11%E7%AB%A0-%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3/" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
<link rel="stylesheet" href="https://otaon.github.io/web/css/den.css">




<meta property="og:title" content="書籍 実践 Common Lisp 第11章 コレクション" />
<meta property="og:description" content="この章について この章では、複数の値を1つのオブジェクトにまとめたデータ型(コレクション)について説明する。 11.1 ベクタ ベクタは、整数でインデック" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://otaon.github.io/web/ja-jp/2019/06/01/%E6%9B%B8%E7%B1%8D-%E5%AE%9F%E8%B7%B5-common-lisp-%E7%AC%AC11%E7%AB%A0-%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3/" />
<meta property="article:published_time" content="2019-06-01T00:00:00&#43;09:00"/>
<meta property="article:modified_time" content="2019-06-01T00:00:00&#43;09:00"/>

<meta itemprop="name" content="書籍 実践 Common Lisp 第11章 コレクション">
<meta itemprop="description" content="この章について この章では、複数の値を1つのオブジェクトにまとめたデータ型(コレクション)について説明する。 11.1 ベクタ ベクタは、整数でインデック">


<meta itemprop="datePublished" content="2019-06-01T00:00:00&#43;09:00" />
<meta itemprop="dateModified" content="2019-06-01T00:00:00&#43;09:00" />
<meta itemprop="wordCount" content="7706">



<meta itemprop="keywords" content="lisp,実践-Common-Lisp," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="書籍 実践 Common Lisp 第11章 コレクション"/>
<meta name="twitter:description" content="この章について この章では、複数の値を1つのオブジェクトにまとめたデータ型(コレクション)について説明する。 11.1 ベクタ ベクタは、整数でインデック"/>
</head>
<body>
  
  <div class="header-container" style="background: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)), url('https://otaon.github.io/web/images/background.jpg'); background-position: center; background-size: cover;">
  <div class="container">
  <nav class="header-nav navbar navbar-expand-md navbar-dark light-dark">
    <div class="header-logo navbar-brand">
      
        <a class="float-left" href="https://otaon.github.io/web/ja-jp/">
      
        
        <img class="mr20 header-logo-image" src="https://otaon.github.io/web/images/night.svg" alt="logo">
        
        
          LL
         
      </a>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="nav-menu collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://otaon.github.io/web/ja-jp/category/notes/">ノート</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://otaon.github.io/web/ja-jp/category/demos/">デモ</a>
              
            
          </li>
        
          <li class="nav-item">
            
              <a class="nav-link" href="https://otaon.github.io/web/ja-jp/about/">このサイトについて</a>
            
          </li>
        
        
          
            <li class="nav-item">
              <a class="nav-link" href="https://otaon.github.io/web/en/"><i class="fas fa-globe"></i> English</a>
            </li>
          
          
          
          
        
      </ul>
    </div>
  </nav>
</div>

<div class="container header-wrapper">
  <div class="row">
    <div class="col-lg-12">
      <div class="header-content">
        <h1 class="header-title">書籍 実践 Common Lisp 第11章 コレクション</h1>
        <p class="header-date">著者：
          otaon /
        
        2019-06-01
          / カテゴリ：
          <a href="https://otaon.github.io/web/ja-jp/category/%E5%AE%9F%E8%B7%B5-common-lisp/">実践-Common-Lisp</a>
        </p>
        
        <div class="header-underline"></div>
        
          <div class="clearfix"></div>
          <p class="float-right header-tags">
              <i class="fas fa-tags" aria-hidden="true"></i>
              <a href="https://otaon.github.io/web/ja-jp/tag/lisp/">lisp</a>, 
                <a href="https://otaon.github.io/web/ja-jp/tag/%E5%AE%9F%E8%B7%B5-common-lisp/">実践-Common-Lisp</a>
          </p>
        
        

      </div>
    </div>
  </div>
</div>

  </div>
  <main>
<div class="container content">
  <article>
  
    <section class="js-toc">
  <div class="toc">
  <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#この章について">この章について</a></li>
<li><a href="#11-1-ベクタ">11.1 ベクタ</a>
<ul>
<li><a href="#固定サイズのベクタ">固定サイズのベクタ</a></li>
</ul></li>
<li><a href="#11-2-特殊ベクタ">11.2 特殊ベクタ</a></li>
<li><a href="#11-3-シーケンスとしてのベクタ">11.3 シーケンスとしてのベクタ</a>
<ul>
<li><a href="#シーケンス関数-length">シーケンス関数 <code>length</code></a></li>
<li><a href="#シーケンス関数-elt">シーケンス関数 <code>elt</code></a></li>
</ul></li>
<li><a href="#11-4-シーケンス反復関数">11.4 シーケンス反復関数</a>
<ul>
<li><a href="#デフォルトの挙動を変更する">デフォルトの挙動を変更する</a>
<ul>
<li><a href="#test-引数2つの関数"><code>:test 引数2つの関数</code></a></li>
<li><a href="#key-引数1つの関数"><code>:key 引数1つの関数</code></a></li>
<li><a href="#start-数値-end-数値"><code>:start 数値</code> <code>:end 数値</code></a></li>
</ul></li>
<li><a href="#from-end-数値"><code>:from-end 数値</code></a></li>
<li><a href="#count-数値"><code>:count 数値</code></a></li>
<li><a href="#キーワード引数一覧">キーワード引数一覧</a></li>
</ul></li>
<li><a href="#11-5-さまざまな高階関数">11.5 さまざまな高階関数</a></li>
<li><a href="#11-6-シーケンス全体の操作">11.6 シーケンス全体の操作</a></li>
<li><a href="#11-7-ソートとマージ">11.7 ソートとマージ</a>
<ul>
<li><a href="#ソート">ソート</a></li>
<li><a href="#マージ">マージ</a></li>
</ul></li>
<li><a href="#11-8-部分シーケンスの操作">11.8 部分シーケンスの操作</a>
<ul>
<li><a href="#subseq"><code>subseq</code></a></li>
<li><a href="#fill"><code>fill</code></a></li>
<li><a href="#search"><code>search</code></a></li>
<li><a href="#mismatch"><code>mismatch</code></a></li>
</ul></li>
<li><a href="#11-9-シーケンス述語">11.9 シーケンス述語</a>
<ul>
<li><a href="#every"><code>every</code></a></li>
<li><a href="#some"><code>some</code></a></li>
<li><a href="#notany"><code>notany</code></a></li>
<li><a href="#notevery"><code>notevery</code></a></li>
<li><a href="#2つのシーケンスに対するシーケンス述語">2つのシーケンスに対するシーケンス述語</a></li>
</ul></li>
<li><a href="#11-10-シーケンスマッピング関数-map-など">11.10 シーケンスマッピング関数(<code>map</code>など)</a>
<ul>
<li><a href="#map"><code>map</code></a></li>
<li><a href="#map-into"><code>map-into</code></a></li>
<li><a href="#reduce"><code>reduce</code></a></li>
</ul></li>
<li><a href="#11-11-ハッシュテーブル">11.11 ハッシュテーブル</a>
<ul>
<li><a href="#ハッシュテーブル作成">ハッシュテーブル作成</a></li>
<li><a href="#ハッシュテーブルの要素にアクセス">ハッシュテーブルの要素にアクセス</a></li>
<li><a href="#ハッシュテーブルの要素を削除">ハッシュテーブルの要素を削除</a></li>
<li><a href="#ハッシュテーブルの初期化">ハッシュテーブルの初期化</a></li>
</ul></li>
<li><a href="#11-2-ハッシュテーブル上の反復">11.2 ハッシュテーブル上の反復</a></li>
</ul></li>
</ul>
</nav>
  </div>
</section>

  
  

<h2 id="この章について">この章について</h2>

<p>この章では、複数の値を1つのオブジェクトにまとめたデータ型(コレクション)について説明する。</p>

<h2 id="11-1-ベクタ">11.1 ベクタ</h2>

<p>ベクタは、整数でインデックスされたコレクション。</p>

<p>ベクタには、固定サイズのベクタと可変サイズのベクタがある。</p>

<h3 id="固定サイズのベクタ">固定サイズのベクタ</h3>

<p>特定の値を含む固定サイズのベクタは<code>vector</code>関数で作ることができる。<br />
<code>vector</code>は任意個の引数を取り、引数で与えた要素を含む固定サイズのベクタを新しく確保する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">vector</span><span class="p">)</span> <span class="c1">; #()</span>
<span class="p">(</span><span class="nv">vector</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; #(1)</span>
<span class="p">(</span><span class="nv">vector</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; #(1 2)</span></code></pre></div>
<p><code>#(...)</code>というシンタックスは、lispの印字器や読み取り器が使用するベクタのリテラル表記。<br />
すなわち、この表記を使えば<code>print</code>や<code>read</code>を使って読み書きできる。</p>

<p><code>#(...)</code>リテラルを使って定義したベクタを変更したときの動作は<strong>未定義</strong>であるため、変更予定のあるベクタを定義する場合は<code>vector</code>関数か<code>make-array</code>関数を使用する必要がある。</p>

<p><code>make-array</code>関数は<code>vector</code>関数よりも汎用的に使用できる。<br />
固定サイズ、可変サイズの両方のベクタを作成でき、さらに、任意次元の配列も作成できる。<br />
したがって、ベクタを作成する場合は1次元を表す数を引数にとる。<br />
次元を表す引数にはリストか、1次元の場合は数値を渡す。<br />
<code>:initial-element</code>引数を渡せば、すべての要素に初期値を設定できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">make-array</span> <span class="mi">5</span> <span class="ss">:initial-element</span> <span class="no">nil</span><span class="p">)</span> <span class="c1">; #(nil nil nil nil nil)</span></code></pre></div>
<p><code>make-array</code>を使うと、フィルポインタを持ったベクタを作成できる。<br />
フィルポインタとは「次に要素を追加した時に埋める(fillする)位置」のこと。<br />
すなわち、フィルポインタは「今ベクタに格納されている要素の数」と等しい。</p>

<p>下記プログラムでは、要素5つ分の領域を持つベクタを作成する。<br />
なお、フィルポインタが<code>0</code>であるため、何も格納されていないように見える。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">make-array</span> <span class="mi">5</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; #()</span></code></pre></div>
<p>フィルポインタを持ったベクタの末尾に要素を追加するには、<code>verctor-push</code>関数を使用する。<br />
<code>vector-push</code>は下記動作を行う。</p>

<ol>
<li>フィルポインタの値が示す場所に要素を追加する</li>
<li>フィルポインタの値をインクリメントする</li>
<li>新しく追加された要素のインデックスを返す</li>
</ol>

<p>フィルポインタを持ったベクタの末尾要素を取り出すには、<code>verctor-pop</code>関数を使用する。<br />
<code>vector-pop</code>は下記動作を行う。</p>

<ol>
<li>フィルポインタの値をデクリメントする</li>
<li>最後に追加された要素を返す</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*x*</span> <span class="p">(</span><span class="nv">make-array</span> <span class="mi">5</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nv">vector-push</span> <span class="ss">&#39;a</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; 0</span>
<span class="vg">*x*</span> <span class="c1">; #(A)</span>
<span class="p">(</span><span class="nv">vector-push</span> <span class="ss">&#39;b</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; 1</span>
<span class="vg">*x*</span> <span class="c1">; #(A B)</span>
<span class="p">(</span><span class="nv">vector-push</span> <span class="ss">&#39;c</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; 2</span>
<span class="vg">*x*</span> <span class="c1">; #(A B C)</span>
<span class="p">(</span><span class="nv">vector-pop</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; C</span>
<span class="vg">*x*</span> <span class="c1">; #(A B)</span>
<span class="p">(</span><span class="nv">vector-pop</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; B</span>
<span class="vg">*x*</span> <span class="c1">; #(A)</span>
<span class="p">(</span><span class="nv">vector-pop</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; A</span>
<span class="vg">*x*</span> <span class="c1">; #()</span></code></pre></div>
<p><code>make-array</code>で可変サイズのベクタ(<strong>可変ベクタ : adjustable vector</strong>)を作るには、下記の通り定義する。</p>

<ul>
<li><strong><code>:fill-pointer</code></strong>を引数に渡してフィルポインタを使用させる</li>
<li><strong><code>:adjustable t</code></strong>を引数に渡して拡張可能にする</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">make-array</span> <span class="mi">5</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span><span class="p">)</span> <span class="c1">; #()</span></code></pre></div>
<p>可変ベクタに要素を追加するには<code>vector-push-extend</code>を使う。<br />
この関数は<code>vector-push</code>と同様に動作するが、フィルポインタの値が下層のストレージサイズと同じ状態で呼び出されると、配列を自動的に拡張する。</p>

<p><strong>NOTE:</strong></p>

<ul>
<li><code>:fill-pointer</code>を指定せずに<code>:adjustable t</code>のみを指定することもできる。<br /></li>
<li>ただし、<code>vector-push</code>、<code>vector-pup</code>はフィルポインタを持ったベクタにのみ使用可能。<br /></li>
<li>また、<code>vector-push-extend</code>はフィルポインタを持った可変ベクタに対してのみ使用可能。<br /></li>
<li><code>adjust-array</code>関数を使用すると、ベクタのサイズを拡張する以外にも、様々な方法で可変配列を変更できる。</li>
</ul>

<h2 id="11-2-特殊ベクタ">11.2 特殊ベクタ</h2>

<p>特殊ベクタ(specialized vector)とは、特定の型のデータのみを持つように制限されたベクタのこと。<br />
データ型を制限されると、データの容量削減や、アクセスの高速化が可能になる。</p>

<p>特殊ベクタの例としては、文字列がある。文字列は、特別に専用の表記方法がある。<br />
しかし、文字列もベクタの部分型であるから、ベクタに対する関数は文字列に対しても使用できる。</p>

<p><code>&quot;foo&quot;</code>のような文字列リテラルは、<code>#()</code>というベクタのリテラルと似ており、変更を加えてはいけない(イミュータブルとして扱う必要がある)。<br />
ただし、<code>make-array</code>に別のキーワード引数<code>:element-type</code>を指定すると、サイズ変更可能な文字列を作成できる。<br />
文字列の場合は<code>:element-type 'character</code>を指定する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">make-array</span> <span class="mi">5</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span> <span class="ss">:element-type</span> <span class="ss">&#39;character</span><span class="p">)</span> <span class="c1">; &#34;&#34;</span></code></pre></div>
<p>文字列以外の特殊なベクタとしては、<strong>ビットベクタ</strong>がある。これは要素の値が<code>0</code>か<code>1</code>であるベクタ。
ビットベクタの場合は<code>:element-type 'bit</code>を指定する。<br />
<code>#*00001111</code>のような読み取り及び印字のシンタックスと、ビット配列の論理積などの演算用の関数が多数用意されている。</p>

<h2 id="11-3-シーケンスとしてのベクタ">11.3 シーケンスとしてのベクタ</h2>

<p>ベクタとリストは、いずれもシーケンスという型の部分型だ。<br />
ここからの節で説明する関数はすべてシーケンス関数であり、ベクタとリストに対して使用可能。</p>

<h3 id="シーケンス関数-length">シーケンス関数 <code>length</code></h3>

<p><code>length</code>は、シーケンスの長さを返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*x*</span> <span class="p">(</span><span class="nv">vector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nv">length</span> <span class="vg">*x*</span><span class="p">)</span> <span class="c1">; 3</span></code></pre></div>
<h3 id="シーケンス関数-elt">シーケンス関数 <code>elt</code></h3>

<p><code>elt</code>は、シーケンスの指定要素を返す。(elt: elementの略)</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*x*</span> <span class="p">(</span><span class="nv">vector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nv">elt</span> <span class="vg">*x*</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; 1</span>
<span class="p">(</span><span class="nv">elt</span> <span class="vg">*x*</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; 2</span>
<span class="p">(</span><span class="nv">elt</span> <span class="vg">*x*</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; 3</span>
<span class="p">(</span><span class="nv">elt</span> <span class="vg">*x*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; エラー発生</span></code></pre></div>
<p><code>elt</code>によって返される値に対して<code>setf</code>を使用することが可能。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*x*</span> <span class="p">(</span><span class="nv">vector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">elt</span> <span class="vg">*x*</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>
<span class="vg">*x*</span> <span class="c1">; #(10 2 3)</span></code></pre></div>
<h2 id="11-4-シーケンス反復関数">11.4 シーケンス反復関数</h2>

<p><code>length</code> <code>elt</code> <code>setf</code> を使用すれば如何なるget setも可能だが、利便性のために更に高機能な関数が用意されている。</p>

<table>
<thead>
<tr>
<th>名前</th>
<th>&nbsp;引数</th>
<th>&nbsp;戻り値</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>count</code></td>
<td>&nbsp;<code>(count item sequence)</code></td>
<td>&nbsp;アイテムのシーケンス中における出現回数</td>
</tr>

<tr>
<td><code>find</code></td>
<td>&nbsp;<code>(find item sequence)</code></td>
<td>&nbsp;アイテム、見つからなかったら<code>nil</code></td>
</tr>

<tr>
<td><code>position</code></td>
<td>&nbsp;<code>(position item sequence)</code></td>
<td>&nbsp;指定アイテムの最初のインデックス、<br/>見つからなかったら<code>nil</code></td>
</tr>

<tr>
<td><code>remove</code></td>
<td>&nbsp;<code>(remove item sequence)</code></td>
<td>&nbsp;アイテムを除いたシーケンス</td>
</tr>

<tr>
<td><code>substitute</code></td>
<td>&nbsp;<code>(substitute new-item target-item sequence)</code></td>
<td>&nbsp;<code>target-item</code>を<code>new-item</code>に置き換えたシーケンス</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">count</span> <span class="mi">1</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; 3</span>

<span class="p">(</span><span class="nv">remove</span> <span class="mi">1</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; #(2 2 3 2 3 4)</span>
<span class="p">(</span><span class="nv">remove</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; (2 2 3 2 3 4)</span>
<span class="p">(</span><span class="nv">remove</span> <span class="sc">#\a</span> <span class="s">&#34;foobarbaz&#34;</span><span class="p">)</span> <span class="c1">; &#34;foobrbz&#34;</span>

<span class="p">(</span><span class="nv">substitute</span> <span class="mi">10</span> <span class="mi">1</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; #(10 2 10 2 3 10 2 3 4)</span>
<span class="p">(</span><span class="nv">substitute</span> <span class="mi">10</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; (10 2 10 2 3 10 2 3 4)</span>
<span class="p">(</span><span class="nv">substitute</span> <span class="sc">#\x</span> <span class="sc">#\b</span> <span class="s">&#34;foobarbaz&#34;</span><span class="p">)</span> <span class="c1">; &#34;fooxarxaz&#34;</span>

<span class="p">(</span><span class="nv">find</span> <span class="mi">10</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; nil</span>
<span class="p">(</span><span class="nv">find</span> <span class="mi">1</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; 0</span></code></pre></div>
<p><strong>NOTE</strong> <code>remove</code>と<code>substitute</code>は引数のシーケンスと同じ型のシーケンスを戻り値として返す。</p>

<h3 id="デフォルトの挙動を変更する">デフォルトの挙動を変更する</h3>

<p>上記の関数はキーワード引数によって挙動を変えられる。<br />
例えば、デフォルトではシーケンス中の要素とアイテムの引数との比較に<code>eql</code>を使用するが、これをキーワード引数によって変更できる。</p>

<h4 id="test-引数2つの関数"><code>:test 引数2つの関数</code></h4>

<p>引数を2つ持ち真偽値を返す関数を指定して、デフォルトの比較方法を変更する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">count</span> <span class="sc">#\b</span> <span class="s">&#34;abcabcB&#34;</span><span class="p">)</span> <span class="c1">; 2</span>
<span class="p">(</span><span class="nv">count</span> <span class="sc">#\b</span> <span class="s">&#34;abcabcB&#34;</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nv">char-equal</span><span class="p">)</span> <span class="c1">; 3</span>

<span class="p">(</span><span class="nv">count</span> <span class="s">&#34;foo&#34;</span> <span class="o">#(</span><span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span> <span class="c1">; 0</span>
<span class="p">(</span><span class="nv">count</span> <span class="s">&#34;foo&#34;</span> <span class="o">#(</span><span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nv">string=</span><span class="p">)</span> <span class="c1">; 1</span></code></pre></div>
<p><strong>NOTE</strong> <code>:test</code>に与えた比較関数の<strong>否定</strong>を比較関数としたい場合、 <code>complement</code>を使うこと。(非推奨のため<code>test-not</code>を使用してはいけない。)<br />
※<code>complement</code>関数は、「与えられた関数の否定を返す関数」を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">count</span> <span class="sc">#\b</span> <span class="s">&#34;abcabcB&#34;</span> <span class="ss">:test</span> <span class="p">(</span><span class="nv">complement</span> <span class="nf">#&#39;</span><span class="nv">char-equal</span><span class="p">))</span> <span class="c1">; 4</span></code></pre></div>
<h4 id="key-引数1つの関数"><code>:key 引数1つの関数</code></h4>

<p>引数を1つ持つ関数を指定して、シーケンス中の要素に対して適用された値が、シーケンス側の比較対象となる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">find</span> <span class="ss">&#39;c</span> <span class="o">#(</span><span class="p">(</span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nv">d</span> <span class="mi">40</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span><span class="p">)</span> <span class="c1">; (c 30)</span></code></pre></div>
<h4 id="start-数値-end-数値"><code>:start 数値</code> <code>:end 数値</code></h4>

<p>シーケンス関数の範囲をサブシーケンスに限定したい場合、<code>:start</code>、<code>:end</code>を使用する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">find</span> <span class="ss">&#39;a</span> <span class="o">#(</span><span class="p">(</span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">40</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span> <span class="ss">:start</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; (a 30)</span>
<span class="p">(</span><span class="nv">find</span> <span class="ss">&#39;a</span> <span class="o">#(</span><span class="p">(</span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">40</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span> <span class="ss">:end</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">; nil</span></code></pre></div>
<h3 id="from-end-数値"><code>:from-end 数値</code></h3>

<p><code>:from-end</code>に<code>nil</code>以外の値を与えると、シーケンス内の要素を逆順に探索する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">find</span> <span class="ss">&#39;a</span> <span class="o">#(</span><span class="p">(</span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">40</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span> <span class="ss">:from-end</span> <span class="no">t</span><span class="p">)</span> <span class="c1">; (a 30)</span>
<span class="p">(</span><span class="nv">remove</span> <span class="sc">#\a</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="ss">:count</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; &#34;foobrbaz&#34;</span>
<span class="p">(</span><span class="nv">remove</span> <span class="sc">#\a</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="ss">:count</span> <span class="mi">1</span> <span class="ss">:from-end</span> <span class="no">t</span><span class="p">)</span> <span class="c1">; &#34;foobarbz&#34;</span></code></pre></div>
<h3 id="count-数値"><code>:count 数値</code></h3>

<p><code>:count</code>は、<code>remove</code>または<code>substitute</code>する要素の個数を指定する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">remove</span> <span class="sc">#\a</span> <span class="s">&#34;foobarbaz&#34;</span><span class="p">)</span> <span class="c1">; &#34;foobrbz&#34;</span>
<span class="p">(</span><span class="nv">remove</span> <span class="sc">#\a</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="ss">:count</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; &#34;foobrbaz&#34;</span></code></pre></div>
<h3 id="キーワード引数一覧">キーワード引数一覧</h3>

<table>
<thead>
<tr>
<th>引数</th>
<th>&nbsp;意味</th>
<th>&nbsp;デフォルト</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>:test</code></td>
<td>&nbsp;パラメータで渡した値と要素との比較に使う関数</td>
<td>&nbsp;<code>eql</code></td>
</tr>

<tr>
<td><code>:key</code></td>
<td>&nbsp;実際のシーケンスの要素から、キーとなる値を取り出すための関数</td>
<td>&nbsp;<code>nil</code></td>
</tr>

<tr>
<td><code>:start</code></td>
<td>&nbsp;部分シーケンスの開始位置</td>
<td>&nbsp;<code>0</code></td>
</tr>

<tr>
<td><code>:end</code></td>
<td>&nbsp;部分シーケンスの終了位置</td>
<td>&nbsp;<code>nil</code></td>
</tr>

<tr>
<td><code>:from-end</code></td>
<td>&nbsp;真ならばシーケンスの末尾から遡って走査する</td>
<td>&nbsp;<code>nil</code></td>
</tr>

<tr>
<td><code>:count</code></td>
<td>&nbsp;削除もしくは置換する要素の最大数</td>
<td>&nbsp;<code>nil</code></td>
</tr>
</tbody>
</table>

<h2 id="11-5-さまざまな高階関数">11.5 さまざまな高階関数</h2>

<p>Common Lispには高階関数(<code>xxx-if</code>,<code>xxx-if-not</code>)が用意されている。<br />
高階関数の引数には、シーケンスの各要素に対して呼び出される関数を渡す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">count-if</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; 2</span>
<span class="p">(</span><span class="nv">count-if-not</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; 3</span>
<span class="p">(</span><span class="nv">position-if</span> <span class="nf">#&#39;</span><span class="nv">digit-char-p</span> <span class="s">&#34;abcd0001&#34;</span><span class="p">)</span> <span class="c1">; 4</span>
<span class="p">(</span><span class="nv">remove-if-not</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">char=</span> <span class="p">(</span><span class="nv">elt</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="sc">#\f</span><span class="p">))</span>
  <span class="o">#(</span><span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span> <span class="s">&#34;baz&#34;</span> <span class="s">&#34;foom&#34;</span><span class="p">))</span> <span class="c1">; #(&#34;foo&#34; &#34;foom&#34;)</span></code></pre></div>
<p>言語標準では<code>xxx-if-not</code>は非推奨(deprecated)とされているが、実際には普通に使用されており、特に<code>remove-if-not</code>は広く使われている。<br />
<code>remove-if-not</code>は引数の述語を満たさない要素をシーケンスから取り除いたシーケンスを返す。<br />
すなわち、述語を満たす要素のみをシーケンスから抽出してシーケンスを作る関数だと言える。</p>

<p>これらの高階関数は、<code>:test</code>以外のキーワード引数が使用できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">count-if</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="p">(</span><span class="mi">1</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="nv">e</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span><span class="p">)</span> <span class="c1">; 2</span>
<span class="p">(</span><span class="nv">count-if-not</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="p">(</span><span class="mi">1</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="nv">e</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span><span class="p">)</span> <span class="c1">; 3</span>
<span class="p">(</span><span class="nv">remove-if-not</span> <span class="nf">#&#39;</span><span class="nv">alpha-char-p</span> <span class="o">#(</span><span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span> <span class="s">&#34;1baz&#34;</span><span class="p">)</span>
  <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">elt</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)))</span> <span class="c1">; #(&#34;foo&#34; &#34;bar&#34;)</span></code></pre></div>
<p><code>remove-duplicates</code>関数はシーケンス中の重複した要素を1つだけにしたシーケンスを返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">remove-duplicates</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; #(1 2 3 4)</span></code></pre></div>
<h2 id="11-6-シーケンス全体の操作">11.6 シーケンス全体の操作</h2>

<p><code>copy-seq</code>関数は引数に渡したシーケンスをコピーして、そのシーケンスを返す。<br />
<code>reverse</code>関数は引数に渡したシーケンスを<strong>逆順にして</strong>コピーして、そのシーケンスを返す。</p>

<p>どちらの関数も、<strong>複製されるのはシーケンス(容器の部分)のみであり、要素自体はコピーされず、元のものが参照される</strong>。</p>

<p><code>concatenate</code>関数は複数のシーケンスをつなぎ合わせた新しいシーケンスを作る。<br />
<code>concatenate</code>関数では、作成するシーケンスの型を指定する必要がある。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">concatenate</span> <span class="ss">&#39;vector</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>    <span class="c1">; #(1 2 3 4 5 6)</span>
<span class="p">(</span><span class="nv">concatenate</span> <span class="ss">&#39;list</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>      <span class="c1">; (1 2 3 4 5 6)</span>
<span class="p">(</span><span class="nv">concatenate</span> <span class="ss">&#39;string</span> <span class="s">&#34;abc&#34;</span> <span class="o">&#39;</span><span class="p">(</span><span class="sc">#\d</span> <span class="sc">#\e</span> <span class="sc">#\f</span><span class="p">))</span> <span class="c1">; &#34;abcdef&#34;</span></code></pre></div>
<h2 id="11-7-ソートとマージ">11.7 ソートとマージ</h2>

<h3 id="ソート">ソート</h3>

<p>シーケンスの方法には、非安定ソートと安定ソートの2種類が用意されている。どちらも<strong>破壊的関数</strong>。</p>

<ul>
<li><code>sort</code> : 非安定ソート</li>
<li><code>stable-sort</code> : 安定ソート</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">sort</span> <span class="p">(</span><span class="nv">vector</span> <span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span> <span class="s">&#34;baz&#34;</span><span class="p">))</span> <span class="c1">; #(&#34;bar&#34; &#34;baz&#34; &#34;foo&#34;)</span></code></pre></div>
<p>ソート関数は破壊的関数であるから、下記を絶対に守ること。</p>

<ul>
<li>ベクタはリテラルではなく<code>vector</code>関数で作成すること。</li>
<li>ソート関数呼び出し後は元の変数を使わないこと。つまり、必ず<strong>関数の戻り値</strong>を使用すること。</li>
<li>ソート関数呼び出しにも使用したいデータは直接渡さず、コピーを作ってそれをソート関数に渡すこと。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">; 下記のように書くこと</span>
<span class="p">(</span><span class="nv">setf</span> <span class="nv">my-sequence</span> <span class="p">(</span><span class="nv">sort</span> <span class="nv">my-sequence</span> <span class="nf">#&#39;</span><span class="nv">string&lt;</span><span class="p">))</span>

<span class="c1">; 下記のように書いてはいけない</span>
<span class="p">(</span><span class="nv">sort</span> <span class="nv">my-sequence</span> <span class="nf">#&#39;</span><span class="nv">string&lt;</span><span class="p">)</span></code></pre></div>
<p>ソート関数はキーワード引数<code>:key</code>を取る。<code>:key</code>には、実際の要素の代わりにソートのための述語に渡す値を得る関数を指定する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">princ</span> <span class="p">(</span><span class="nv">sort</span> <span class="p">(</span><span class="nv">vector</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="mi">3</span><span class="p">))</span> <span class="nf">#&#39;</span><span class="nv">string&lt;</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nv">first</span><span class="p">))</span>
<span class="c1">; =&gt;</span>
<span class="c1">; #((A 2) (B 3) (C 1))</span>
<span class="c1">; #((A 2) (B 3) (C 1))</span></code></pre></div>
<h3 id="マージ">マージ</h3>

<p><code>merge</code>関数は、2つのシーケンスを指定の述語に則ってマージして、1つの新しいシーケンスを生成して返す。<br />
引数には、生成されるシーケンスの型、2つのシーケンス、述語を渡す。<br />
<code>merge</code>関数が返すシーケンスは、引数の各々のシーケンスを述語に則ってソートした結果をマージしたシーケンスに等しい。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">merge</span> <span class="ss">&#39;vector</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="o">#(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nv">&lt;</span><span class="p">)</span> <span class="c1">; #(1 2 3 4 5 6)</span>
<span class="p">(</span><span class="nv">merge</span> <span class="ss">&#39;list</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="o">#(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nv">&lt;</span><span class="p">)</span>   <span class="c1">; (1 2 3 4 5 6)</span></code></pre></div>
<h2 id="11-8-部分シーケンスの操作">11.8 部分シーケンスの操作</h2>

<h3 id="subseq"><code>subseq</code></h3>

<p><code>subseq</code>は、シーケンスから指定したインデックス分の部分シーケンスを返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">subseq</span> <span class="nv">シーケンス</span> <span class="nv">先頭インデックス</span> <span class="nv">末尾インデックス</span><span class="p">)</span>
<span class="c1">; 末尾インデックスより1つ手前までが部分シーケンスの範囲になる</span>

<span class="p">(</span><span class="nv">subseq</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; &#34;barbaz&#34;</span>
<span class="p">(</span><span class="nv">subseq</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">; &#34;bar&#34;</span></code></pre></div>
<p><code>subseq</code>が返す値に対して<code>setf</code>できるが、これによってシーケンス長は変化しない。<br />
また、新しくセットする値の長さが、セット対象の部分シーケンスの長さと異なる場合、短い方の長さ分のみがセット対象となる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*x*</span> <span class="p">(</span><span class="nv">copy-seq</span> <span class="s">&#34;foobarbaz&#34;</span><span class="p">))</span>

<span class="c1">; 部分シーケンスと新しい値が同じ長さ</span>
<span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">subseq</span> <span class="vg">*x*</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="s">&#34;xxx&#34;</span><span class="p">)</span>
<span class="vg">*x*</span> <span class="c1">; &#34;fooxxxbaz&#34;</span>

<span class="c1">; 新しい値が長すぎるため、余分な文字は無視されれる</span>
<span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">subseq</span> <span class="vg">*x*</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="s">&#34;abcd&#34;</span><span class="p">)</span>
<span class="vg">*x*</span> <span class="c1">; &#34;fooabcbaz&#34;</span>

<span class="c1">; 新しい値が短すぎるため、2文字だけ変更される</span>
<span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">subseq</span> <span class="vg">*x*</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="s">&#34;xx&#34;</span><span class="p">)</span>
<span class="vg">*x*</span> <span class="c1">; &#34;fooxxcbaz&#34;</span></code></pre></div>
<h3 id="fill"><code>fill</code></h3>

<p><code>fill</code>は、シーケンス中の複数要素をある1つの数に設定する。<br />
<code>:start</code>、<code>:end</code>で設定範囲を指定できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">fill</span> <span class="o">#(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; #(1 1 1 1 1)</span>
<span class="p">(</span><span class="nv">fill</span> <span class="o">#(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span> <span class="mi">1</span> <span class="ss">:start</span> <span class="mi">1</span> <span class="ss">:end</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; #(A 1 1 1 E)</span></code></pre></div>
<h3 id="search"><code>search</code></h3>

<p><code>search</code>は、シーケンスの中から部分シーケンスを探し出し、マッチしたときのインデックスを返す。<br />
マッチしなかった場合は<code>nil</code>を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">search</span> <span class="nv">シーケンス</span> <span class="nv">探索対象の部分シーケンス</span><span class="p">)</span>
<span class="p">(</span><span class="nv">search</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span> <span class="c1">; 3</span></code></pre></div>
<h3 id="mismatch"><code>mismatch</code></h3>

<p><code>mismatch</code>は、共通のプリフィックス(つまり先頭から等しい部分シーケンス)を持つ2つのシーケンスに対して、枝分かれする場所を探し出し、そのインデックスを返す。<br />
枝分かれする場所がなかったら<code>nil</code>を返す。<br />
また、標準的なキーワード引数を指定できる。<code>:key</code>によりシーケンスから要素を取り出す関数を、<code>:test</code>により比較関数を、<code>:start1</code>、<code>:end1</code>、<code>:start2</code>、<code>:end2</code>引数により2つのシーケンスの比較範囲、<code>:from-end</code>により探索の向きを指定できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">mismatch</span> <span class="nv">シーケンス</span> <span class="nv">探索対象の部分シーケンス</span><span class="p">)</span>
<span class="p">(</span><span class="nv">mismatch</span> <span class="s">&#34;foobarbaz&#34;</span> <span class="s">&#34;foom&#34;</span><span class="p">)</span> <span class="c1">; 3</span>
<span class="p">(</span><span class="nv">mismatch</span> <span class="s">&#34;foobar&#34;</span> <span class="s">&#34;bar&#34;</span> <span class="ss">:from-end</span> <span class="no">t</span><span class="p">)</span> <span class="c1">; 3</span></code></pre></div>
<h2 id="11-9-シーケンス述語">11.9 シーケンス述語</h2>

<p>シーケンス全体に対して評価・比較するための関数がある。</p>

<h3 id="every"><code>every</code></h3>

<p><code>every</code>は、「<code>∀x. P(x)</code>」と同等。述語が1回でも<code>nil</code>を返すと即<code>nil</code>を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">every</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; nil</span></code></pre></div>
<h3 id="some"><code>some</code></h3>

<p><code>some</code>は、「<code>∃x. P(x)</code>」と同等。述語が1回でも<code>t</code>を返すと即<code>t</code>を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">some</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; t</span></code></pre></div>
<h3 id="notany"><code>notany</code></h3>

<p><code>notany</code>は、「<code>∀x. ¬P(x)</code>」と同等。1回でも<code>t</code>になると即<code>nil</code>を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">notany</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; nil</span></code></pre></div>
<h3 id="notevery"><code>notevery</code></h3>

<p><code>notevery</code>は、「<code>∃x. ¬P(x)</code>」と同等。1回でも<code>nil</code>になると即<code>t</code>を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">notevery</span> <span class="nf">#&#39;</span><span class="nv">evenp</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; t</span></code></pre></div>
<h3 id="2つのシーケンスに対するシーケンス述語">2つのシーケンスに対するシーケンス述語</h3>

<p>要素数が等しい2つのシーケンスに対して、述語を満たすのか否かを評価する。<br />
それぞれの関数の意味は上記説明を参照。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">every</span> <span class="nf">#&#39;</span><span class="nv">&gt;</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">#(</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; nil</span>
<span class="p">(</span><span class="nv">some</span> <span class="nf">#&#39;</span><span class="nv">&gt;</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">#(</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; t</span>
<span class="p">(</span><span class="nv">notany</span> <span class="nf">#&#39;</span><span class="nv">&gt;</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">#(</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; nil</span>
<span class="p">(</span><span class="nv">notevery</span> <span class="nf">#&#39;</span><span class="nv">&gt;</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">#(</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; t</span></code></pre></div>
<h2 id="11-10-シーケンスマッピング関数-map-など">11.10 シーケンスマッピング関数(<code>map</code>など)</h2>

<h3 id="map"><code>map</code></h3>

<p><code>map</code>は、各要素に関数を適用し、その結果を含む新しいシーケンスを返す。<br />
<code>map</code>には、どの型のシーケンスを返すのか指定する必要がある。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">map</span> <span class="ss">&#39;vector</span> <span class="nf">#&#39;</span><span class="nv">*</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="o">#(</span><span class="mi">10</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; #(10 18 24 28 30)</span></code></pre></div>
<h3 id="map-into"><code>map-into</code></h3>

<p><code>map-into</code>は、第1引数に指定したシーケンスに値を設定する。戻り値は、シーケンスに設定した値。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*a*</span> <span class="p">(</span><span class="nv">vector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*b*</span> <span class="p">(</span><span class="nv">vector</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">))</span>
<span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*c*</span> <span class="p">(</span><span class="nv">vector</span> <span class="mi">100</span> <span class="mi">200</span> <span class="mi">300</span><span class="p">))</span>
<span class="p">(</span><span class="nv">map-into</span> <span class="vg">*a*</span> <span class="nf">#&#39;</span><span class="nv">+</span> <span class="vg">*a*</span> <span class="vg">*b*</span> <span class="vg">*c*</span><span class="p">)</span> <span class="c1">; #(111 222 333)</span>
<span class="vg">*a*</span> <span class="c1">; #(111 222 333)</span></code></pre></div>
<p>各シーケンスの長さが異なる場合は、最も短いシーケンス分のみ計算して設定する。<br />
ただし、マッピングの結果になるシーケンス(つまり第1引数)がフィルポインタ付きのベクタだった場合、計算される範囲は、フィルポインタには制限されず、実際のベクタのサイズで決まる。</p>

<p><code>map-into</code>の呼び出し後には、フィルポインタはマッピングされた要素の個数になる。しかし、<code>map-into</code>は可変ベクタを拡張しない。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">f</span><span class="p">()</span>
  <span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*a*</span> <span class="p">(</span><span class="nv">make-array</span> <span class="mi">3</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">1</span> <span class="vg">*a*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">2</span> <span class="vg">*a*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">3</span> <span class="vg">*a*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*b*</span> <span class="p">(</span><span class="nv">make-array</span> <span class="mi">4</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">10</span> <span class="vg">*b*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">20</span> <span class="vg">*b*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">30</span> <span class="vg">*b*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">40</span> <span class="vg">*b*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*c*</span> <span class="p">(</span><span class="nv">make-array</span> <span class="mi">5</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="no">t</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">100</span> <span class="vg">*c*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">200</span> <span class="vg">*c*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">300</span> <span class="vg">*c*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">400</span> <span class="vg">*c*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">vector-push-extend</span> <span class="mi">500</span> <span class="vg">*c*</span><span class="p">))</span>
<span class="p">(</span><span class="nv">f</span><span class="p">)</span>
<span class="p">(</span><span class="nv">map-into</span> <span class="vg">*a*</span> <span class="nf">#&#39;</span><span class="nv">+</span> <span class="vg">*a*</span> <span class="vg">*b*</span> <span class="vg">*c*</span><span class="p">)</span> <span class="c1">; #(111 222 333)</span>
<span class="p">(</span><span class="nv">f</span><span class="p">)</span>
<span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*ret*</span> <span class="p">(</span><span class="nv">make-array</span> <span class="mi">2</span> <span class="ss">:fill-pointer</span> <span class="mi">0</span> <span class="ss">:adjustable</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nv">map-into</span> <span class="vg">*ret*</span> <span class="nf">#&#39;</span><span class="nv">+</span> <span class="vg">*a*</span> <span class="vg">*b*</span> <span class="vg">*c*</span><span class="p">)</span> <span class="c1">; #(111 222) ←*ret*を拡張していない</span></code></pre></div>
<h3 id="reduce"><code>reduce</code></h3>

<p><code>reduce</code>は、シーケンスの先頭の2つの要素に対して2つの引数を持つ関数を適用する。これをシーケンスの末尾まで繰り返して最終的な結果を返す。<br />
したがって、<code>reduce</code>は、第1引数の関数をシーケンスの各要素に適用して1つの値を得る関数。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">reduce</span> <span class="nf">#&#39;</span><span class="nv">+</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">; 55</span>
<span class="p">(</span><span class="nv">reduce</span> <span class="nf">#&#39;</span><span class="nv">max</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">; 55</span></code></pre></div>
<p><code>reduce</code>はキーワード引数を指定できる。</p>

<ul>
<li><code>:key</code> : シーケンスから要素を取り出すために使われる関数</li>
<li><code>:from-end</code> : <code>nil</code>以外を指定すると末尾から走査する</li>
<li><code>:start</code> : シーケンスの対象範囲の開始点を指定する</li>
<li><code>:end</code> : シーケンスの対象範囲の終了点を指定する(<code>:end</code>より1つ前まで範囲)</li>
<li><code>:initial-value</code> : シーケンスの先頭よりも論理的に前に来る値を指定する</li>
</ul>

<h2 id="11-11-ハッシュテーブル">11.11 ハッシュテーブル</h2>

<p>ベクタは整数でインデックスを付けられたデータ構造。<br />
これに対して、ハッシュテーブルは任意のオブジェクトでインデックス(キー)を付けられたデータ構造。</p>

<h3 id="ハッシュテーブル作成">ハッシュテーブル作成</h3>

<p><code>make-hash-table</code>関数でハッシュテーブルを作成する。<br />
引数なしの<code>make-hash-table</code>関数を使うと、<strong>キーの比較に<code>eql</code>を使う</strong>ハッシュテーブルを作成する(デフォルト)。<br />
※<code>eql</code>は、(シンボル・数値・文字・リストを含む)任意のオブジェクトの<strong>同一性</strong>を判定する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*h*</span> <span class="p">(</span><span class="nv">make-hash-table</span><span class="p">))</span></code></pre></div>
<p>文字列は<code>eql</code>だと異なるオブジェクトとして判定されるため、デフォルトのハッシュテーブルを使用できない。<br />
そこで、<code>equal</code>を使用するハッシュテーブルを生成したい。下記のように<code>:test</code>を使用して作成する。<br />
<code>:test</code>には、下記関数のみ指定できる。</p>

<ul>
<li><code>eq</code></li>
<li><code>eql</code></li>
<li><code>equal</code></li>
<li><code>eqals</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*h*</span> <span class="p">(</span><span class="nv">make-hash-table</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nv">equal</span><span class="p">))</span></code></pre></div>
<h3 id="ハッシュテーブルの要素にアクセス">ハッシュテーブルの要素にアクセス</h3>

<p>ハッシュテーブルの要素にアクセスするには<code>gethash</code>関数を使用する。<br />
この関数は指定されたキーに対応する値があればそれを返し、なければ<code>nil</code>を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">gethash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; nil</span>
<span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">gethash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span> <span class="ss">&#39;quux</span><span class="p">)</span>
<span class="c1">; QUUX</span>
<span class="p">(</span><span class="nv">gethash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; QUUX</span>
<span class="c1">; T</span></code></pre></div>
<p><strong>NOTE</strong> <code>gethash</code>の引数の順序は、インデックス・コレクションの順番で、これは<code>elt</code>と逆になってしまっている。</p>

<p>指定されたキーに<code>nil</code>が格納されていた場合を考えると、<code>gethash</code>で取得した値が、キーに対応した値なのか、キーに対応した値がなかったときの<code>nil</code>なのか判断できない。<br />
実は、<code>gethash</code>が返す値は<strong>多値</strong>で、第1戻り値は先述の通り、キーに対応する値か、なければ<code>nil</code>。第2戻り値は、キーがハッシュテーブルに存在したら<code>t</code>、しなければ<code>nil</code>になる。<br />
<code>gethash</code>の戻り値を多値として取得するには<code>multiple-value-bind</code>マクロを使用する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">multiple-value-bind</span> <span class="p">(</span><span class="nv">value</span> <span class="nv">present</span><span class="p">)</span> <span class="p">(</span><span class="nv">gethash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">print</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">print</span> <span class="nv">present</span><span class="p">))</span>
<span class="c1">; QUUX</span>
<span class="c1">; T</span></code></pre></div>
<h3 id="ハッシュテーブルの要素を削除">ハッシュテーブルの要素を削除</h3>

<p>ハッシュテーブルからエントリを削除するには<code>remhash</code>を使用する。<br />
エントリを削除したら<code>t</code>が返り、削除しなかったら<code>nil</code>が返る。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">remhash</span> <span class="nv">キー</span>　<span class="nv">コレクション</span><span class="p">)</span>

<span class="p">(</span><span class="nv">gethash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; QUUX</span>
<span class="p">(</span><span class="nv">remhash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; T</span>
<span class="p">(</span><span class="nv">gethash</span> <span class="ss">&#39;foo</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; NIL</span>
<span class="c1">; NIL</span>
<span class="p">(</span><span class="nv">remhash</span> <span class="ss">&#39;bar</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; NIL</span></code></pre></div>
<h3 id="ハッシュテーブルの初期化">ハッシュテーブルの初期化</h3>

<p><code>clrhash</code>で、ハッシュテーブルの全てのキーと値のペアを削除する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">clrhash</span> <span class="vg">*h*</span><span class="p">)</span>
<span class="c1">; #&lt;HASH-TABLE :TEST EQL :COUNT 0 {1004B772C3}&gt;</span></code></pre></div>
<h2 id="11-2-ハッシュテーブル上の反復">11.2 ハッシュテーブル上の反復</h2>

<p>ハッシュテーブルのエントリを走査するには、<code>maphash</code>関数を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">maphash</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nv">format</span> <span class="no">t</span> <span class="s">&#34;~a =&gt; ~a~%&#34;</span> <span class="nv">key</span> <span class="nv">value</span><span class="p">))</span> <span class="vg">*h*</span><span class="p">)</span></code></pre></div>
<p>ハッシュテーブルの走査中に、ハッシュテーブルに要素を追加/削除したときの結果は未定義であるため、実行してはいけない。<br />
ただし、現在のエントリの値を<code>(setf (gethash key hash-table) value)</code>で変更しても良い。<br />
また、現在のエントリを<code>(remhash key hash-table)</code>で削除しても良い。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">; 値が10より小さなエントリをすべて削除する</span>
<span class="p">(</span><span class="nv">maphash</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nv">when</span> <span class="p">(</span><span class="nv">&lt;</span> <span class="nv">value</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nv">remhash</span> <span class="nv">key</span> <span class="vg">*h*</span><span class="p">)))</span> <span class="vg">*h*</span><span class="p">)</span></code></pre></div>
<p><code>loop</code>マクロを使用してもハッシュテーブルを操作できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">loop</span> <span class="nv">for</span> <span class="nv">key</span> <span class="nv">being</span> <span class="nv">the</span> <span class="nv">hash-keys</span> <span class="nv">in</span> <span class="vg">*h*</span>
          <span class="nv">using</span> <span class="p">(</span><span class="nv">hash-value</span> <span class="nv">value</span><span class="p">)</span>
  <span class="nv">do</span> <span class="p">(</span><span class="nv">format</span> <span class="no">t</span> <span class="s">&#34;~a =&gt; ~a~%&#34;</span> <span class="nv">key</span> <span class="nv">value</span><span class="p">))</span></code></pre></div>
  </article>

  
  
    
    <div class="author-card">
    <div class="underline"></div>
    <div class="author-box">
      <div class="author-image"><a href="https://github.com/otaon"><img src="/web/images/otaon.png" alt="otaon" /></a></div>
      <div class="author-content">
      <p class="author-title">著者</p>
      <p class="author-name">otaon</p>
      <p class="author-desc">こんにちは</p>
      </div>
    </div>
  </div>
    
  
  


</div>

  </main><div class="footer gradient-2">
  <div class="container footer-container ">
    <div class="row">
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        <div class="footer-title">サイトマップ</div>
        <ul class="list-unstyled">
            
              
                <li><a href="https://otaon.github.io/web/ja-jp/tags/">タグ</a></li>
              
              
                <li><a href="https://otaon.github.io/web/ja-jp/categories/">カテゴリ</a></li>
              
            
            
            
            <li><a rel="alternate" type="application/rss&#43;xml" href="https://otaon.github.io/web/ja-jp/index.xml"><i class="fas fa-rss-square"></i> RSS Feed</a></li>
            
            
            
        </ul>
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">SNS</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/otaon" rel="noopener" target="_blank">GitHub</a></li>
          
        </ul>
        
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">リンク</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/otaon" rel="noopener" target="_blank">著者について</a></li>
          
        </ul>
        
      </div> 
      <div class="col-xs-12 col-sm-3 col-md-3 col-lg-3">
        <p class="pull-right text-right">
          <small><em>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a></em></small><br/>
          <small><em>Theme - <a href="https://github.com/shaform/hugo-theme-den" rel="noopener" target="_blank">Den</a></em></small><br/>
          <small>
            &copy; 
            otaon
            2019
          </small>
          
        </p>
      </div>
    </div>
  </div>
</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/web/asset/mermaid/mermaid.js"></script>

</body>
</html>
