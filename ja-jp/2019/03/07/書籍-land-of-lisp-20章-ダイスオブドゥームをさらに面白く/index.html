<!DOCTYPE html>
<html lang="ja-jp" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta name="generator" content="Hugo 0.54.0" />
  <meta charset="utf-8">
  <title>書籍 Land of Lisp 20章 ダイスオブドゥームをさらに面白く · Lazy Lambda</title>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="T.O.C. 20.1 プレイヤーの数を増やす 20.2 サイコロを降る 20.3 ダイスオブドゥームの補給ルールの改善 20.4 終わりに ダイスオブドゥームのバージョン4を作る。 今までのバ" />

  <meta name="keywords" content="programming, make" />

<link rel="canonical" href="https://otaon.github.io/web/ja-jp/2019/03/07/%E6%9B%B8%E7%B1%8D-land-of-lisp-20%E7%AB%A0-%E3%83%80%E3%82%A4%E3%82%B9%E3%82%AA%E3%83%96%E3%83%89%E3%82%A5%E3%83%BC%E3%83%A0%E3%82%92%E3%81%95%E3%82%89%E3%81%AB%E9%9D%A2%E7%99%BD%E3%81%8F/" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
<link rel="stylesheet" href="https://otaon.github.io/web/css/den.css">




<meta property="og:title" content="書籍 Land of Lisp 20章 ダイスオブドゥームをさらに面白く" />
<meta property="og:description" content="T.O.C. 20.1 プレイヤーの数を増やす 20.2 サイコロを降る 20.3 ダイスオブドゥームの補給ルールの改善 20.4 終わりに ダイスオブドゥームのバージョン4を作る。 今までのバ" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://otaon.github.io/web/ja-jp/2019/03/07/%E6%9B%B8%E7%B1%8D-land-of-lisp-20%E7%AB%A0-%E3%83%80%E3%82%A4%E3%82%B9%E3%82%AA%E3%83%96%E3%83%89%E3%82%A5%E3%83%BC%E3%83%A0%E3%82%92%E3%81%95%E3%82%89%E3%81%AB%E9%9D%A2%E7%99%BD%E3%81%8F/" />
<meta property="article:published_time" content="2019-03-07T00:00:00&#43;09:00"/>
<meta property="article:modified_time" content="2019-03-07T00:00:00&#43;09:00"/>

<meta itemprop="name" content="書籍 Land of Lisp 20章 ダイスオブドゥームをさらに面白く">
<meta itemprop="description" content="T.O.C. 20.1 プレイヤーの数を増やす 20.2 サイコロを降る 20.3 ダイスオブドゥームの補給ルールの改善 20.4 終わりに ダイスオブドゥームのバージョン4を作る。 今までのバ">


<meta itemprop="datePublished" content="2019-03-07T00:00:00&#43;09:00" />
<meta itemprop="dateModified" content="2019-03-07T00:00:00&#43;09:00" />
<meta itemprop="wordCount" content="5095">



<meta itemprop="keywords" content="lisp," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="書籍 Land of Lisp 20章 ダイスオブドゥームをさらに面白く"/>
<meta name="twitter:description" content="T.O.C. 20.1 プレイヤーの数を増やす 20.2 サイコロを降る 20.3 ダイスオブドゥームの補給ルールの改善 20.4 終わりに ダイスオブドゥームのバージョン4を作る。 今までのバ"/>
</head>
<body>
  
  <div class="header-container" style="background: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)), url('https://otaon.github.io/web/images/background.jpg'); background-position: center; background-size: cover;">
  <div class="container">
  <nav class="header-nav navbar navbar-expand-md navbar-dark light-dark">
    <div class="header-logo navbar-brand">
      
        <a class="float-left" href="https://otaon.github.io/web/ja-jp/">
      
        
        <img class="mr20 header-logo-image" src="https://otaon.github.io/web/images/night.svg" alt="logo">
        
        
          LL
         
      </a>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="nav-menu collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://otaon.github.io/web/ja-jp/category/notes/">ノート</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://otaon.github.io/web/ja-jp/category/demos/">デモ</a>
              
            
          </li>
        
          <li class="nav-item">
            
              <a class="nav-link" href="https://otaon.github.io/web/ja-jp/about/">このサイトについて</a>
            
          </li>
        
        
          
            <li class="nav-item">
              <a class="nav-link" href="https://otaon.github.io/web/en/"><i class="fas fa-globe"></i> English</a>
            </li>
          
          
          
          
        
      </ul>
    </div>
  </nav>
</div>

<div class="container header-wrapper">
  <div class="row">
    <div class="col-lg-12">
      <div class="header-content">
        <h1 class="header-title">書籍 Land of Lisp 20章 ダイスオブドゥームをさらに面白く</h1>
        <p class="header-date">著者：
          otaon /
        
        2019-03-07
          / カテゴリ：
          <a href="https://otaon.github.io/web/ja-jp/category/notes/">Notes</a>
        </p>
        
        <div class="header-underline"></div>
        
          <div class="clearfix"></div>
          <p class="float-right header-tags">
              <i class="fas fa-tags" aria-hidden="true"></i>
              <a href="https://otaon.github.io/web/ja-jp/tag/lisp/">lisp</a>
          </p>
        
        

      </div>
    </div>
  </div>
</div>

  </div>
  <main>
<div class="container content">
  <article>
  
  

<h2 id="t-o-c">T.O.C.</h2>

<ul>
<li><a href="#201-プレイヤーの数を増やす">20.1 プレイヤーの数を増やす</a></li>
<li><a href="#202-サイコロを降る">20.2 サイコロを降る</a></li>
<li><a href="#203-ダイスオブドゥームの補給ルールの改善">20.3 ダイスオブドゥームの補給ルールの改善</a></li>
<li><a href="#204-終わりに">20.4 終わりに</a></li>
</ul>

<hr />

<p>ダイスオブドゥームのバージョン4を作る。<br />
今までのバージョンでは、プログラムを簡単にするため、重要なルールを省略していた。<br />
本章では、ゲームのプレイヤーを増やし、サイコロを振るようにし、さらにいくつかの改良をダイスオブドゥームに施す。</p>

<p>まず、前章で作ったコードをファイルに保存し、呼び出すだけで使用できるようにしておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">load</span> <span class="s">&#34;dice_of_doom_v3.lisp&#34;</span><span class="p">)</span></code></pre></div>
<h2 id="20-1-プレイヤーの数を増やす">20.1 プレイヤーの数を増やす</h2>

<p>最初の変更では、プレイヤーを2人から4人に増やす。<br />
うち3人は、ゲームAIプレイヤーである。</p>

<p>まず、変数<code>*num-players*</code>の値を4にし、新たなプレイヤーのためのサイコロの色を追加する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*num-players*</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*die-colors*</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">255</span> <span class="mi">63</span> <span class="mi">63</span><span class="p">)</span>     <span class="c1">; 赤</span>
                             <span class="p">(</span><span class="mi">63</span> <span class="mi">63</span> <span class="mi">255</span><span class="p">)</span>     <span class="c1">; 青</span>
                             <span class="p">(</span><span class="mi">63</span> <span class="mi">255</span> <span class="mi">63</span><span class="p">)</span>     <span class="c1">; 緑</span>
                             <span class="p">(</span><span class="mi">255</span> <span class="mi">63</span> <span class="mi">255</span><span class="p">)))</span>  <span class="c1">; 紫</span></code></pre></div>
<p>プレイヤーの数の定数を変更したため、他の定数も変えておく。<br />
サイコロの最大数を5個に増やし、そしてAIのレベルを4から2に減らした。<br />
ゲームAIが3人もいるため、対人としては賢さがそれほど必要ではなくなったわけである。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*max-dice*</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1">; サイコロの最大数</span>
<span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*ai-level*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">; AIが思考するゲーム木の深さ</span></code></pre></div>
<h3 id="パラノイド戦略">パラノイド戦略</h3>

<p>これまで作ってきたゲームAIプレイヤーは、いわゆる「パラノイド戦略」をとっている。
すなわち、それぞれのAIプレイヤーは「他のプレイヤーはすべて敵で、他人を攻撃することしか眼中にない」と考えている。<br />
これは必ずしも悪い戦略ではないが、プレイヤーが3人以上になると、他の有効な戦略も存在することは覚えておきたい。
例えば、負けているプレイヤー同士が結託して、トップのプレイヤーを攻撃する、などである。</p>

<p>しかしながら、本書のAIエンジンは、そういった協力プレイは一切計算できない。</p>

<h2 id="20-2-サイコロを降る">20.2 サイコロを降る</h2>

<p>これまでのゲームにおける重大な欠陥の1つは、サイコロを一切振っていない点である。
これはつまりサイコロのランダム性を全く使っていないということである。</p>

<p>このバージョンにおいては、攻撃にあたって、攻撃元のマスのサイコロ、攻撃先のサイコロ、それぞれをまとめて振り、目の合計の多いほうが勝つ。
目が同じだった場合は、防御側の勝ちとする。
攻撃側が失敗した場合は、攻撃側のマスはサイコロを1つだけ残して、残りを防御側のプレイヤーに渡すルールとする。</p>

<p>上記のルールを実現するためには、AIプログラミング用語でいう<strong>確率ノード</strong>(chance node)をゲーム木に足す必要がある。<br />
次に、実装を示す。</p>

<h3 id="確率ノードを作る">確率ノードを作る</h3>

<p>今まで、ゲーム木の次の手を表す遅延リストの要素は、下記の2つの項目を持つリストであった。</p>

<ul>
<li>car: 手の記述(攻撃の場合は、攻撃元と攻撃先のマス。手番終了)</li>
<li>cadr: 手が選ばれた場合の、次のゲーム木のノード</li>
</ul>

<p>ここに、3つ目の項目として、攻撃が失敗した場合のゲーム木のノードを追加する。<br />
すなわち、ゲーム木のそれぞれの手から伸びる枝が、攻撃の成否によってさらに2つに分岐することになる。</p>

<p>では、<code>attacking-moves</code>関数を拡張し、それぞれの手が確率ノードとして動作するように要素を付け足していく。<br />
ここでの変更における新しい変更は、ゲーム木に新たな手を付け加える時にもう一つの枝を足してやることである。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">attacking-moves</span> <span class="p">(</span><span class="nv">board</span> <span class="nv">cur-player</span> <span class="nv">spare-dice</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">labels</span> <span class="p">((</span><span class="nv">player</span> <span class="p">(</span><span class="nv">pos</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">car</span> <span class="p">(</span><span class="nv">aref</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">)))</span>
           <span class="p">(</span><span class="nv">dice</span> <span class="p">(</span><span class="nv">pos</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">cadr</span> <span class="p">(</span><span class="nv">aref</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">lazy-mapcan</span>
      <span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">src</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">eq</span> <span class="p">(</span><span class="nv">player</span> <span class="nv">src</span><span class="p">)</span> <span class="nv">cur-player</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">lazy-mapcan</span>
            <span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">dst</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">eq</span> <span class="p">(</span><span class="nv">player</span> <span class="nv">dst</span><span class="p">)</span> <span class="nv">cur-player</span><span class="p">))</span>
                       <span class="p">(</span><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">src</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
                  <span class="p">(</span><span class="nv">make-lazy</span> <span class="p">(</span><span class="nv">list</span>
                               <span class="p">(</span><span class="nv">list</span>
                                 <span class="p">(</span><span class="nv">list</span> <span class="nv">src</span> <span class="nv">dst</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nv">game-tree</span> <span class="p">(</span><span class="nv">board-attack</span> <span class="nv">board</span> <span class="nv">cur-player</span>
                                                          <span class="nv">src</span> <span class="nv">dst</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">src</span><span class="p">))</span>
                                             <span class="nv">cur-player</span>
                                             <span class="p">(</span><span class="nv">+</span> <span class="nv">spare-dice</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">dst</span><span class="p">))</span>
                                             <span class="no">nil</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nv">game-tree</span> <span class="p">(</span><span class="nv">board-attack-fail</span> <span class="nv">board</span> <span class="nv">cur-player</span>
                                                               <span class="nv">src</span> <span class="nv">dst</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">src</span><span class="p">))</span>
                                            <span class="nv">cur-player</span>
                                            <span class="p">(</span><span class="nv">+</span> <span class="nv">spare-dice</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">dst</span><span class="p">))</span>
                                            <span class="no">nil</span><span class="p">))))</span>
                  <span class="p">(</span><span class="nv">lazy-nil</span><span class="p">)))</span>
            <span class="p">(</span><span class="nv">make-lazy</span> <span class="p">(</span><span class="nv">neighbors</span> <span class="nv">src</span><span class="p">)))</span>
          <span class="p">(</span><span class="nv">lazy-nil</span><span class="p">)))</span>
      <span class="p">(</span><span class="nv">make-lazy</span> <span class="p">(</span><span class="nv">loop</span> <span class="nv">for</span> <span class="nv">n</span> <span class="nv">below</span> <span class="vg">*board-hexnum*</span>
                   <span class="nv">collect</span> <span class="nv">n</span><span class="p">)))))</span></code></pre></div>
<p>この確率ノードから伸びる追加の枝のゲーム盤を作るには、次に示す<code>board-attack-fail</code>を呼び出してやる。<br />
<code>board-attack-fail</code>は、ゲーム盤を受け取り、そして失敗した攻撃の攻撃元となったマスから、サイコロを1つだけ残して残りを取り上げた状態のゲーム盤を返す。<br />
この関数は、ゲーム盤をループして、各マスを単純にコピーしている。<br />
ただし、マスの番号が攻撃元と一致した場合に限り、そこに1個だけサイコロを残すようにする。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">board-attack-fail</span> <span class="p">(</span><span class="nv">board</span> <span class="nv">player</span> <span class="nv">src</span> <span class="nv">dst</span> <span class="nv">dice</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">board-array</span> <span class="p">(</span><span class="nv">loop</span> <span class="nv">for</span> <span class="nv">pos</span> <span class="nv">from</span> <span class="mi">0</span>
                     <span class="nv">for</span> <span class="nv">hex</span> <span class="nv">across</span> <span class="nv">board</span>
                     <span class="nv">collect</span> <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">eq</span> <span class="nv">pos</span> <span class="nv">src</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nv">list</span> <span class="nv">player</span> <span class="mi">1</span><span class="p">)</span>
                                 <span class="nv">hex</span><span class="p">))))</span></code></pre></div>
<h3 id="サイコロを実際に振る">サイコロを実際に振る</h3>

<p>サイコロを振るロジックを実装する。<br />
次の関数では、引数で与えられた数のサイコロをまとめて振る。
そして、サイコロを振った結果をメッセージに表示し、合計を返す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">roll-dice</span> <span class="p">(</span><span class="nv">dice-num</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">let</span> <span class="p">((</span><span class="nv">total</span> <span class="p">(</span><span class="nv">loop</span> <span class="nv">repeat</span> <span class="nv">dice-num</span>
                     <span class="nv">sum</span> <span class="p">(</span><span class="nv">1+</span> <span class="p">(</span><span class="nv">random</span> <span class="mi">6</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nv">fresh-line</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">format</span> <span class="no">t</span> <span class="s">&#34;On ~a dice rolled ~a. &#34;</span> <span class="nv">dice-num</span> <span class="nv">total</span><span class="p">)</span>
    <span class="nv">total</span><span class="p">))</span></code></pre></div>
<p>サイコロは常に攻撃側と守備側それぞれで振ることになるため、それらをまとめて行う関数も定義する。<br />
この関数は単に<code>roll-dice</code>を2回呼び、結果を比べるのみである。<br />
ゲーム木をたどる過程でプレイヤーがサイコロを降る手を選択したらこの関数を呼び出し、結果に応じて勝った場合の枝か、負けた場合の枝のどちらかを次のゲーム木にする。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">roll-against</span> <span class="p">(</span><span class="nv">src-dice</span> <span class="nv">dst-dice</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">roll-dice</span> <span class="nv">src-dice</span><span class="p">)</span> <span class="p">(</span><span class="nv">rill-dice</span> <span class="nv">dst-dice</span><span class="p">)))</span></code></pre></div>
<h3 id="ゲームエンジンからサイコロを振るコードを呼び出す">ゲームエンジンからサイコロを振るコードを呼び出す</h3>

<p>ゲームエンジンにとっては、サイコロを振るのは人間かコンピュータのプレイヤーが手を選んだ時に確率ノードの枝のどちらかを選ぶときだけである。<br />
この動作は、<code>pick-chance-branch</code>関数で実現される。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">pick-chance-branch</span> <span class="p">(</span><span class="nv">branch</span> <span class="nv">move</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">labels</span> <span class="p">((</span><span class="nv">dice</span> <span class="p">(</span><span class="nv">pos</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">cadr</span> <span class="p">(</span><span class="nv">aref</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">let</span> <span class="p">((</span><span class="nv">path</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">move</span><span class="p">)))</span>
      <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">or</span> <span class="p">(</span><span class="nv">null</span> <span class="nv">path</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">roll-against</span> <span class="p">(</span><span class="nv">dice</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">path</span><span class="p">))</span>
                            <span class="p">(</span><span class="nv">dice</span> <span class="p">(</span><span class="nv">cadr</span> <span class="nv">path</span><span class="p">))))</span>
          <span class="p">(</span><span class="nv">cadr</span> <span class="nv">move</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">caddr</span> <span class="nv">move</span><span class="p">)))))</span></code></pre></div>
<p>この関数は現在のゲーム盤と指し手のエントリを受け取り、指し手が確率ノードを持っていたら、そのどちらの枝を選ぶかを決定する。<br />
まず、指し手の<code>car</code>を、すなわち<code>path</code>を見て、これが<code>nil</code>でなければこの指し手は攻撃なので、そこから攻撃元<code>(car path)</code>と攻撃先<code>(cadr path)</code>のマスを取り出し、それぞれのサイコロの個数を求めて<code>roll-against</code>を呼び出す。<br />
<code>path</code>が<code>nil</code>ならこの手は「手番を終える」手であるため、サイコロを振る必要はない。</p>

<p>サイコロを振って攻撃が成功と出れば、確率ノードの最初のゲーム木を返す。
攻撃が失敗に終われば、確率ノードの2番目のゲーム木を返す。</p>

<p>人間やコンピュータが指し手を選んだ時に、<code>pick-chance-branch</code>が呼ばれるようにする。<br />
まず、人間側を実装する。以前の<code>web-handle-human</code>からの変更点は、次のゲームの状態を表すゲーム木を返す箇所に<code>pick-chance-branch</code>を足しただけである。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">web-handle-human</span> <span class="p">(</span><span class="nv">pos</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">cond</span> <span class="p">((</span><span class="nv">not</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34;Please choose a hex to move from:&#34;</span><span class="p">))</span>
        <span class="p">((</span><span class="nv">eq</span> <span class="nv">pos</span> <span class="ss">&#39;pass</span><span class="p">)</span> <span class="p">(</span><span class="nv">setf</span> <span class="vg">*cur-game-tree*</span>
                              <span class="p">(</span><span class="nv">cadr</span> <span class="p">(</span><span class="nv">lazy-car</span> <span class="p">(</span><span class="nv">caddr</span> <span class="vg">*cur-game-tree*</span><span class="p">))))</span>
         <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34;Your reinforcements have been placed.&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">tag</span> <span class="nv">a</span> <span class="p">(</span><span class="nv">href</span> <span class="p">(</span><span class="nv">make-game-link</span> <span class="no">nil</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34;continue&#34;</span><span class="p">)))</span>
        <span class="p">((</span><span class="nv">not</span> <span class="vg">*from-tile*</span><span class="p">)</span> <span class="p">(</span><span class="nv">setf</span> <span class="vg">*from-tile*</span> <span class="no">nil</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34;Move cancelled.&#34;</span><span class="p">))</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">setf</span> <span class="vg">*cur-game-tree*</span>
                 <span class="p">(</span><span class="nv">pick-chance-branch</span>
                   <span class="p">(</span><span class="nv">cadr</span> <span class="vg">*cur-game-tree*</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">lazy-find-if</span> <span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">move</span><span class="p">)</span>
                                   <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">move</span><span class="p">)</span>
                                          <span class="p">(</span><span class="nv">list</span> <span class="vg">*from-tile*</span> <span class="nv">pos</span><span class="p">)))</span>
                                 <span class="p">(</span><span class="nv">caddr</span> <span class="vg">*cur-game-tree*</span><span class="p">))))</span>
        <span class="p">(</span><span class="nv">setf</span> <span class="vg">*from-tile*</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34;You may now &#34;</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">tag</span> <span class="nv">a</span> <span class="p">(</span><span class="nv">href</span> <span class="p">(</span><span class="nv">make-game-link</span> <span class="ss">&#39;pass</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34;pass&#34;</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">princ</span> <span class="s">&#34; or make another move:&#34;</span><span class="p">))))</span></code></pre></div>
<p>コンピュータ側の<code>handle-computer</code>も同様に変更する。<br />
関数の最後に<code>pick-chance-branch</code>を加えている。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">handle-computer</span> <span class="p">(</span><span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">let</span> <span class="p">((</span><span class="nv">ratings</span> <span class="p">(</span><span class="nv">get-ratings</span> <span class="p">(</span><span class="nv">limit-tree-depth</span> <span class="nv">tree</span> <span class="vg">*ai-level*</span><span class="p">)</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">tree</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">pick-chance-branch</span>
      <span class="p">(</span><span class="nv">cadr</span> <span class="nv">tree</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">lazy-nth</span> <span class="p">(</span><span class="nv">position</span> <span class="p">(</span><span class="nv">apply</span> <span class="nf">#&#39;</span><span class="nv">max</span> <span class="nv">ratings</span><span class="p">)</span> <span class="nv">ratings</span><span class="p">)</span> <span class="p">(</span><span class="nv">caddr</span> <span class="nv">tree</span><span class="p">)))))</span></code></pre></div>
<p>ここまでの変更により、新しいダイスオブドゥームをプレイできるようになっているはずである。<br />
ただ、このコードでは、ゲームAIは確率ノードのことを考慮できておらず、全ての攻撃が成功すると思って手を計算してしまう。<br />
そこで、次章ではAIエンジンを改良して、サイコロのランダム要素を考慮できるようにする。</p>

<h3 id="aiの改良">AIの改良</h3>

<p>ゲームAIがサイコロについて考慮できるようにするためには、サイコロを振ったときの統計について知っておく必要がある。<br />
全ての可能なサイコロの個数の組み合わせについて、攻撃が成功する確率を計算したものを表で用意しておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*dice-probability*</span> <span class="o">#(#(</span><span class="mf">0.84</span> <span class="mf">0.97</span> <span class="mf">1.0</span>  <span class="mf">1.0</span><span class="p">)</span>
                                   <span class="o">#(</span><span class="mf">0.44</span> <span class="mf">0.78</span> <span class="mf">0.94</span> <span class="mf">0.99</span><span class="p">)</span>
                                   <span class="o">#(</span><span class="mf">0.15</span> <span class="mf">0.45</span> <span class="mf">0.74</span> <span class="mf">0.91</span><span class="p">)</span>
                                   <span class="o">#(</span><span class="mf">0.04</span> <span class="mf">0.19</span> <span class="mf">0.46</span> <span class="mf">0.72</span><span class="p">)</span>
                                   <span class="o">#(</span><span class="mf">0.01</span> <span class="mf">0.06</span> <span class="mf">0.22</span> <span class="mf">0.46</span><span class="p">)))</span></code></pre></div>
<p>この表は、各行が守備側のサイコロの個数(1個〜5個)、各列が攻撃側のサイコロの個数(2個〜5個)の確率を表す。<br />
例えば、攻撃側が2個、守備側が1個の時、攻撃が成功する確率は84%である。</p>

<p>AIのコードの中心となる関数は<code>get-ratings</code>である。<br />
この関数は、可能な次の手それぞれに点数を与えるものであった。
点数の計算にサイコロを振る成功確率を考慮に入れる変更を施すこととする。
それぞれの攻撃について、成功した場合と失敗した場合それぞれの点数を、<code>*dice-probability*</code>から分かる確率を使って結合する。<br />
この新しい<code>get-ratings</code>関数では、攻撃の手について、その成功確率をテーブルから取り出し、攻撃が成功した場合の点数に乗算する。<br />
また、失敗確率(= 1 - 成功確率)を、失敗した場合の点数に乗算する。<br />
この両者の我が、攻撃手の点数である。<br />
これにより、<code>get-ratings</code>関数は確率ノードを考慮した点数を返せるようになった。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">get-ratings</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">player</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">let</span> <span class="p">((</span><span class="nv">board</span> <span class="p">(</span><span class="nv">cadr</span> <span class="nv">tree</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">labels</span> <span class="p">((</span><span class="nv">dice</span> <span class="p">(</span><span class="nv">pos</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">cadr</span> <span class="p">(</span><span class="nv">aref</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))))</span>
      <span class="p">(</span><span class="nv">take-all</span> <span class="p">(</span><span class="nv">lazy-mapcar</span>
                  <span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">move</span><span class="p">)</span>
                    <span class="p">(</span><span class="nv">let</span> <span class="p">((</span><span class="nv">path</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">move</span><span class="p">)))</span>
                       <span class="p">(</span><span class="nv">if</span> <span class="nv">path</span>
                           <span class="p">(</span><span class="nv">let*</span> <span class="p">((</span><span class="nv">src</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">path</span><span class="p">))</span>
                                  <span class="p">(</span><span class="nv">dst</span> <span class="p">(</span><span class="nv">cadr</span> <span class="nv">path</span><span class="p">))</span>
                                  <span class="p">(</span><span class="nv">probability</span> <span class="p">(</span><span class="nv">aref</span> <span class="p">(</span><span class="nv">aref</span> <span class="vg">*dice-probability*</span>
                                                           <span class="p">(</span><span class="nv">1-</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">dst</span><span class="p">)))</span>
                                                     <span class="p">(</span><span class="nv">-</span> <span class="p">(</span><span class="nv">dice</span> <span class="nv">src</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>
                             <span class="p">(</span><span class="nv">+</span> <span class="p">(</span><span class="nv">*</span> <span class="nv">probability</span> <span class="p">(</span><span class="nv">rate-position</span> <span class="p">(</span><span class="nv">cadr</span> <span class="nv">move</span><span class="p">)</span> <span class="nv">player</span><span class="p">))</span>
                                <span class="p">(</span><span class="nv">*</span> <span class="p">(</span><span class="nv">-</span> <span class="mi">1</span> <span class="nv">probability</span><span class="p">)</span> <span class="p">(</span><span class="nv">rate-position</span> <span class="p">(</span><span class="nv">caddr</span> <span class="nv">move</span><span class="p">)</span>
                                                                    <span class="nv">player</span><span class="p">))))</span>
                           <span class="p">(</span><span class="nv">rate-position</span> <span class="p">(</span><span class="nv">cadr</span> <span class="nv">move</span><span class="p">)</span> <span class="nv">player</span><span class="p">))))</span>
                <span class="p">(</span><span class="nv">caddr</span> <span class="nv">tree</span><span class="p">))))))</span></code></pre></div>
<p>ゲームAIを確率ノードに完全に対応させるには、もう1つ小さな変更を行う。<br />
ゲーム木の大きさを制限する関数は、確率ノードから2つ枝が伸びていることを考慮する。
そして、勝つ場合と負ける場合の両方の枝を刈り込む必要がある。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">limit-tree-depth</span> <span class="p">(</span><span class="nv">tree</span> <span class="nv">depth</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">list</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">tree</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">cadr</span> <span class="nv">tree</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="nv">depth</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">lazy-nil</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">lazy-mapcar</span> <span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">move</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">cons</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">move</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nv">mapcar</span> <span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                                           <span class="p">(</span><span class="nv">limit-tree-depth</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">1-</span> <span class="nv">depth</span><span class="p">)))</span>
                                   <span class="p">(</span><span class="nv">cdr</span> <span class="nv">move</span><span class="p">))))</span>
              <span class="p">(</span><span class="nv">caddr</span> <span class="nv">tree</span><span class="p">)))))</span></code></pre></div>
<p>各指し手のリスト<code>(move)</code>の<code>cdr</code>に気を刈り込む関数を<code>mapcar</code>することで、確率ノードの両方の枝を刈り込める。</p>

<p><strong>NOTE</strong><br />
ダイスオブドゥームのバージョン4では、アルファベータ法は使用しない。<br />
なぜなら、確率ノードがある場合のアルファベータ法は非常に複雑になるためである。</p>

<h2 id="20-3-ダイスオブドゥームの補給ルールの改善">20.3 ダイスオブドゥームの補給ルールの改善</h2>

<p>これまで、手番を終えた時に補給されるサイコロは、常に<code>その手番で得たサイコロの総数 - 1</code>であった。<br />
この補給ルールは、ゲームが進むに連れて必ずサイコロの総数が減るため、ゲームが必ず終了し、ゲーム木が有限の大きさを持つことを保証できる。<br />
しかし、バージョン2からゲーム木は遅延ツリーになっているため、大きさが無限になっても全く問題ない。
そこで、補給ルールを変更して、ゲームをより戦略的に面白くしてみよう。</p>

<p>新しいルールでは、補給サイコロの数は、プレイヤーが専有している連続した領域のうち最も大きいものの広さに等しいとする。<br />
こうすると、プレイヤーは、常に、領域が分断されるリスクを取れるかどうかの判断を迫れられる。あるいは、小さな領域を捨てて特攻攻撃を仕掛けるという手段もある。</p>

<p>新たな補給ルールを実現するため、まず、指定したマスを起点として、現在のプレイヤーが専有する連続した領域のマスのリストを返す<code>get-connected</code>を定義する。<br />
この関数は、8章のGTWと同様のアルゴリズムを用いて、連続するマスを見つけ出す。
すなわち、注目しているマスから隣接するマスへと再帰的に移動しながら、既に見たマスのリストを更新していくわけである。<br />
<code>get-connected</code>関数では、2つのローカルな再帰関数を定義している。</p>

<ul>
<li><code>check-pos</code>関数は現在見ているマスがプレイヤーの所有であり、かつまだ見たことがなければそれを<code>visited</code>リストに追加する。</li>
<li><code>check-neighbors</code>関数は隣接したマスのリストを受け取ってその全てをチェックする。</li>
</ul>

<p>この2つの関数は、相互に再帰して、連続したマスの一塊を見つけ出す。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">get-connected</span> <span class="p">(</span><span class="nv">board</span> <span class="nv">player</span> <span class="nv">pos</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">labels</span> <span class="p">((</span><span class="nv">check-pos</span> <span class="p">(</span><span class="nv">pos</span> <span class="nv">visited</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">and</span> <span class="p">(</span><span class="nv">eq</span> <span class="p">(</span><span class="nv">car</span> <span class="p">(</span><span class="nv">aref</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))</span> <span class="nv">player</span><span class="p">)</span>
                      <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">member</span> <span class="nv">pos</span> <span class="nv">visited</span><span class="p">)))</span>
                 <span class="p">(</span><span class="nv">check-neighbors</span> <span class="p">(</span><span class="nv">neighbors</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nv">cons</span> <span class="nv">pos</span> <span class="nv">visited</span><span class="p">))</span>
                 <span class="nv">visited</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">check-neighbors</span> <span class="p">(</span><span class="nv">lst</span> <span class="nv">visited</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">if</span> <span class="nv">lst</span>
               <span class="p">(</span><span class="nv">check-neighbors</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">check-pos</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">visited</span><span class="p">))</span>
               <span class="nv">visited</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">check-pos</span> <span class="nv">pos</span> <span class="o">&#39;</span><span class="p">())))</span></code></pre></div>
<p>相互再帰の起点は、目標のマス1つと、空の<code>visited</code>リストで<code>check-pos</code>を呼び出すことである。
この関数で連続するマスの1つの領域は見つけられるが、<strong>最大の領域</strong>を見つけるために、<code>largest-cluster-size</code>関数が必要となる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">largest-cluster-size</span> <span class="p">(</span><span class="nv">boardd</span> <span class="nv">player</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">labels</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nv">pos</span> <span class="nv">visited</span> <span class="nv">best</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">&lt;</span> <span class="nv">pos</span> <span class="vg">*board-hexnum*</span><span class="p">)</span>
                 <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">and</span> <span class="p">(</span><span class="nv">eq</span> <span class="p">(</span><span class="nv">car</span> <span class="p">(</span><span class="nv">aref</span> <span class="nv">board</span> <span class="nv">pos</span><span class="p">))</span> <span class="nv">player</span><span class="p">)</span>
                          <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">member</span> <span class="nv">pos</span> <span class="nv">visited</span><span class="p">)))</span>
                     <span class="p">(</span><span class="nv">let*</span> <span class="p">((</span><span class="nv">cluster</span> <span class="p">(</span><span class="nv">get-connected</span> <span class="nv">board</span> <span class="nv">player</span> <span class="nv">pos</span><span class="p">))</span>
                            <span class="p">(</span><span class="nv">size</span> <span class="p">(</span><span class="nv">length</span> <span class="nv">cluster</span><span class="p">)))</span>
                       <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">&gt;</span> <span class="nv">size</span> <span class="nv">best</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">1+</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nv">append</span> <span class="nv">cluster</span> <span class="nv">visited</span><span class="p">)</span> <span class="nv">size</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">1+</span> <span class="nv">pos</span><span class="p">)</span> <span class="p">(</span><span class="nv">append</span> <span class="nv">cluster</span> <span class="nv">visited</span><span class="p">)</span> <span class="nv">best</span><span class="p">)))</span>
                     <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">1+</span> <span class="nv">pos</span><span class="p">)</span> <span class="nv">visited</span> <span class="nv">best</span><span class="p">))</span>
               <span class="nv">best</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">f</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">()</span> <span class="mi">0</span><span class="p">)))</span></code></pre></div>
<p>最後に、この新しい補給ルールを反映するため、<code>add-new-dice</code>を変更する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">add-new-dice</span> <span class="p">(</span><span class="nv">board</span> <span class="nv">player</span> <span class="nv">spare-dice</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">labels</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nv">lst</span> <span class="nv">n</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">lst</span><span class="p">)</span>
                   <span class="p">((</span><span class="nv">null</span> <span class="nv">lst</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
                   <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">let</span> <span class="p">((</span><span class="nv">cur-player</span> <span class="p">(</span><span class="nv">caar</span> <span class="nv">lst</span><span class="p">))</span>
                            <span class="p">(</span><span class="nv">cur-dice</span> <span class="p">(</span><span class="nv">cadar</span> <span class="nv">lst</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">and</span> <span class="p">(</span><span class="nv">eq</span> <span class="nv">cur-player</span> <span class="nv">player</span><span class="p">)</span> <span class="p">(</span><span class="nv">&lt;</span> <span class="nv">cur-dice</span> <span class="vg">*max-dice*</span><span class="p">))</span>
                            <span class="p">(</span><span class="nv">cons</span> <span class="p">(</span><span class="nv">list</span> <span class="nv">cur-player</span> <span class="p">(</span><span class="nv">1+</span> <span class="nv">cur-dice</span><span class="p">))</span>
                                  <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">1-</span> <span class="nv">n</span><span class="p">)))</span>
                            <span class="p">(</span><span class="nv">cons</span> <span class="p">(</span><span class="nv">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">cdr</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">n</span><span class="p">))))))))</span>
  <span class="p">(</span><span class="nv">board-array</span> <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">coerce</span> <span class="nv">board</span> <span class="ss">&#39;list</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">largest-cluster-size</span> <span class="nv">board</span> <span class="nv">player</span><span class="p">)))))</span></code></pre></div>
<p>新しい<code>add-new-dice</code>でも<code>spare-dice</code>引数を受け取っているが、これは<code>add-new-dice</code>を呼び出している箇所との互換性のためだけで、この引数は無視される。<br />
すなわち、追加される補給サイコロの数は最も大きな連続領域の大きさのみで決まる。<br />
<code>add-new-dice</code>関数の変更箇所はここのみである。</p>

<p>これで、新たな補給ルールを有効にするための全てのコードが完成した。<br />
この設計では、ゲームAIのプレイヤーがゲーム木の全てにアクセスできるようになっている。
ゲーム木はこの新たな補給を考慮したデータを持つので、ゲームAIは自動的に新たな補給ルールに合わせた最適な戦略を見つけるようになる。</p>

<h2 id="20-4-終わりに">20.4 終わりに</h2>

<p>ダイスオブドゥームのゲームは、これにて完成である。<br />
プレイするには、下記のとおりコマンドを実行する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">serve</span> <span class="nf">#&#39;</span><span class="nv">dod-request-handler</span><span class="p">)</span></code></pre></div>
<p>そして、webブラウザで<a href="http://localhost:8080/game.html">ゲームページ</a>を開く。</p>

  </article>

  
  
    
    <div class="author-card">
    <div class="underline"></div>
    <div class="author-box">
      <div class="author-image"><a href="https://github.com/otaon"><img src="/web/images/otaon.png" alt="otaon" /></a></div>
      <div class="author-content">
      <p class="author-title">著者</p>
      <p class="author-name">otaon</p>
      <p class="author-desc">こんにちは</p>
      </div>
    </div>
  </div>
    
  
  


</div>

  </main><div class="footer gradient-2">
  <div class="container footer-container ">
    <div class="row">
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        <div class="footer-title">サイトマップ</div>
        <ul class="list-unstyled">
            
              
                <li><a href="https://otaon.github.io/web/ja-jp/tags/">タグ</a></li>
              
              
                <li><a href="https://otaon.github.io/web/ja-jp/categories/">カテゴリ</a></li>
              
            
            
            
            <li><a rel="alternate" type="application/rss&#43;xml" href="https://otaon.github.io/web/ja-jp/index.xml"><i class="fas fa-rss-square"></i> RSS Feed</a></li>
            
            
            
        </ul>
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">SNS</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/otaon" rel="noopener" target="_blank">GitHub</a></li>
          
        </ul>
        
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">リンク</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/otaon" rel="noopener" target="_blank">著者について</a></li>
          
        </ul>
        
      </div> 
      <div class="col-xs-12 col-sm-3 col-md-3 col-lg-3">
        <p class="pull-right text-right">
          <small><em>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a></em></small><br/>
          <small><em>Theme - <a href="https://github.com/shaform/hugo-theme-den" rel="noopener" target="_blank">Den</a></em></small><br/>
          <small>
            &copy; 
            otaon
            2019
          </small>
          
        </p>
      </div>
    </div>
  </div>
</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/web/asset/mermaid/mermaid.js"></script>

</body>
</html>
