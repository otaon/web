<!DOCTYPE html>
<html lang="ja-jp" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta name="generator" content="Hugo 0.54.0" />
  <meta charset="utf-8">
  <title>書籍 実践 Common Lisp 第3章 実践：簡単なデータベース · Lazy Lambda</title>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第3章 実践：簡単なデータベース ここでは、CD情報をデータベースのレコードとして残すコードを実装しながら、Lispの基本的なデータ操作方法を学" />

  <meta name="keywords" content="programming, make" />

<link rel="canonical" href="https://otaon.github.io/web/ja-jp/2019/03/07/%E6%9B%B8%E7%B1%8D-%E5%AE%9F%E8%B7%B5-common-lisp-%E7%AC%AC3%E7%AB%A0-%E5%AE%9F%E8%B7%B5%E7%B0%A1%E5%8D%98%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9/" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
<link rel="stylesheet" href="https://otaon.github.io/web/css/den.css">




<meta property="og:title" content="書籍 実践 Common Lisp 第3章 実践：簡単なデータベース" />
<meta property="og:description" content="第3章 実践：簡単なデータベース ここでは、CD情報をデータベースのレコードとして残すコードを実装しながら、Lispの基本的なデータ操作方法を学" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://otaon.github.io/web/ja-jp/2019/03/07/%E6%9B%B8%E7%B1%8D-%E5%AE%9F%E8%B7%B5-common-lisp-%E7%AC%AC3%E7%AB%A0-%E5%AE%9F%E8%B7%B5%E7%B0%A1%E5%8D%98%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9/" />
<meta property="article:published_time" content="2019-03-07T00:00:00&#43;09:00"/>
<meta property="article:modified_time" content="2019-03-07T00:00:00&#43;09:00"/>

<meta itemprop="name" content="書籍 実践 Common Lisp 第3章 実践：簡単なデータベース">
<meta itemprop="description" content="第3章 実践：簡単なデータベース ここでは、CD情報をデータベースのレコードとして残すコードを実装しながら、Lispの基本的なデータ操作方法を学">


<meta itemprop="datePublished" content="2019-03-07T00:00:00&#43;09:00" />
<meta itemprop="dateModified" content="2019-03-07T00:00:00&#43;09:00" />
<meta itemprop="wordCount" content="5790">



<meta itemprop="keywords" content="lisp," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="書籍 実践 Common Lisp 第3章 実践：簡単なデータベース"/>
<meta name="twitter:description" content="第3章 実践：簡単なデータベース ここでは、CD情報をデータベースのレコードとして残すコードを実装しながら、Lispの基本的なデータ操作方法を学"/>
</head>
<body>
  
  <div class="header-container" style="background: linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2)), url('https://otaon.github.io/web/images/background.jpg'); background-position: center; background-size: cover;">
  <div class="container">
  <nav class="header-nav navbar navbar-expand-md navbar-dark light-dark">
    <div class="header-logo navbar-brand">
      
        <a class="float-left" href="https://otaon.github.io/web/ja-jp/">
      
        
        <img class="mr20 header-logo-image" src="https://otaon.github.io/web/images/night.svg" alt="logo">
        
        
          LL
         
      </a>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="nav-menu collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://otaon.github.io/web/ja-jp/category/notes/">ノート</a>
              
            
          </li>
        
          <li class="nav-item">
            
              
                <a class="nav-link" href="https://otaon.github.io/web/ja-jp/category/demos/">デモ</a>
              
            
          </li>
        
          <li class="nav-item">
            
              <a class="nav-link" href="https://otaon.github.io/web/ja-jp/about/">このサイトについて</a>
            
          </li>
        
        
          
            <li class="nav-item">
              <a class="nav-link" href="https://otaon.github.io/web/en/"><i class="fas fa-globe"></i> English</a>
            </li>
          
          
          
          
        
      </ul>
    </div>
  </nav>
</div>

<div class="container header-wrapper">
  <div class="row">
    <div class="col-lg-12">
      <div class="header-content">
        <h1 class="header-title">書籍 実践 Common Lisp 第3章 実践：簡単なデータベース</h1>
        <p class="header-date">著者：
          otaon /
        
        2019-03-07
          / カテゴリ：
          <a href="https://otaon.github.io/web/ja-jp/category/notes/">Notes</a>
        </p>
        
        <div class="header-underline"></div>
        
          <div class="clearfix"></div>
          <p class="float-right header-tags">
              <i class="fas fa-tags" aria-hidden="true"></i>
              <a href="https://otaon.github.io/web/ja-jp/tag/lisp/">lisp</a>
          </p>
        
        

      </div>
    </div>
  </div>
</div>

  </div>
  <main>
<div class="container content">
  <article>
  

<h1 id="第3章-実践-簡単なデータベース">第3章 実践：簡単なデータベース</h1>

<p>ここでは、CD情報をデータベースのレコードとして残すコードを実装しながら、Lispの基本的なデータ操作方法を学ぶ。</p>

<h2 id="3-1-cdとレコード">3.1 CDとレコード</h2>

<p>リッピング対象のCDの情報を管理するため、下記の情報を管理するデータベースを作成する。</p>

<ul>
<li>CDタイトル</li>
<li>アーティスト</li>
<li>CDのレーティング</li>
<li>リッピング完了したか</li>
</ul>

<p>CDのデータベースには、keyとvalueの組み合わせを持つリストを使うのが良さそうである。<br />
Lispでは、連想配列の実現方法として主に2種類のデータ構造が使える。</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>データ構造</th>
<th>コード例</th>
</tr>
</thead>

<tbody>
<tr>
<td>連想リスト(association list, alist)</td>
<td>keyとvalueのドットペアをリストの要素に持つ</td>
<td><code>'((key1 . value1) (key2 . value2) ...)</code></td>
</tr>

<tr>
<td>属性リスト(property list, plist)</td>
<td>keyとvalueを交互にリストの要素に持つ</td>
<td><code>'(key1 value1 key2 value2 ...)</code></td>
</tr>
</tbody>
</table>

<p>ここでは、<strong>属性リスト</strong>を採用する。</p>

<p>CDのレコード情報を取り、CDを表す属性リストを返す関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">make-cd</span> <span class="p">(</span><span class="nv">title</span> <span class="nv">artist</span> <span class="nv">rating</span> <span class="nv">ripped</span><span class="p">)</span>
  <span class="s">&#34;CDを表す属性リストを返す
</span><span class="s">   title:  CDタイトル
</span><span class="s">   artist: アーティスト名
</span><span class="s">   rating: CDのレーティング
</span><span class="s">   ripped: リッピング完了したか
</span><span class="s">   ret: CDを表す属性リスト&#34;</span>
  <span class="p">(</span><span class="nv">list</span> <span class="ss">:title</span> <span class="nv">title</span> <span class="ss">:artist</span> <span class="nv">artist</span> <span class="ss">:rating</span> <span class="nv">rating</span> <span class="ss">:ripped</span> <span class="nv">ripped</span><span class="p">))</span></code></pre></div>
<h2 id="3-2-cdのファイリング">3.2 CDのファイリング</h2>

<p>複数のレコードを保持するデータ構造には、リストを採用する。</p>

<p>ダイナミック変数として<code>*db*</code>を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;; CDデータベース</span>
<span class="p">(</span><span class="nv">defparameter</span> <span class="vg">*db*</span> <span class="no">nil</span><span class="p">)</span></code></pre></div>
<p>レコードを<code>*db*</code>に格納する関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">add-record</span> <span class="p">(</span><span class="nv">cd</span><span class="p">)</span>
  <span class="s">&#34;CD情報をデータベースに追加する
</span><span class="s">   cd: CDを表す属性リスト
</span><span class="s">   ret: CD情報追加後のCDデータベース&#34;</span>
  <span class="p">(</span><span class="nv">push</span> <span class="nv">cd</span> <span class="vg">*db*</span><span class="p">))</span></code></pre></div>
<h2 id="3-3-データベースの中身を見てみる">3.3 データベースの中身を見てみる</h2>

<p>CD情報のデータベースを全てダンプする関数を定義する。<br />
この関数では、<code>format</code>関数のフォーマット指定子によって、複数のレコードを1行で表示する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">dump-db</span> <span class="p">()</span>
  <span class="s">&#34;CDデータベースの内容をダンプする
</span><span class="s">  ret: -&#34;</span>
  <span class="c1">;; 1レコード分の表示例</span>
  <span class="c1">;;   TITLE:  Syro</span>
  <span class="c1">;;   ARTIST: Aphex Twin</span>
  <span class="c1">;;   RATING: 3</span>
  <span class="c1">;;   RIPPED: T</span>
  <span class="p">(</span><span class="nv">format</span> <span class="no">t</span> <span class="s">&#34;~{~{~a:~10t~a~%~}~%~}&#34;</span> <span class="vg">*db*</span><span class="p">))</span></code></pre></div>
<h2 id="3-4-ユーザインタラクションを改善する">3.4 ユーザインタラクションを改善する</h2>

<p>ユーザフレンドリなレコード追加仕組みを作成する。</p>

<p>ユーザプロンプトを表示して、標準ストリームへの入力を促す関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">prompt-read</span> <span class="p">(</span><span class="nv">prompt</span><span class="p">)</span>
  <span class="s">&#34;prompt: ユーザ入力画面のプロンプト文字
</span><span class="s">   ret: ユーザが入力したデータ1行&#34;</span>
  <span class="c1">;; 標準I/Oストリームを*query-io*に接続し、promptの値を流し込む</span>
  <span class="p">(</span><span class="nv">format</span> <span class="vg">*query-io*</span> <span class="s">&#34;~a: &#34;</span> <span class="nv">prompt</span><span class="p">)</span>
  <span class="c1">;; *query-io*ストリームを、改行コードがなくても表示する</span>
  <span class="p">(</span><span class="nv">force-output</span> <span class="vg">*query-io*</span><span class="p">)</span>
  <span class="c1">;; ユーザに*query-io*ストリームへの入力を促す</span>
  <span class="p">(</span><span class="nv">read-line</span> <span class="vg">*query-io*</span><span class="p">))</span></code></pre></div>
<p>上記の、ユーザへの入力を促す機能を利用して、ユーザにCD1枚分のデータを入力させる関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">prompt-for-cd</span> <span class="p">()</span>
  <span class="s">&#34;ユーザにCD1枚分のデータを入力させる
</span><span class="s">   ret: CDを表す属性リスト&#34;</span>
  <span class="p">(</span><span class="nv">make-cd</span>
    <span class="c1">;; CDタイトル</span>
    <span class="p">(</span><span class="nv">prompt-read</span> <span class="s">&#34;Title: &#34;</span><span class="p">)</span>
	<span class="c1">;; アーティスト名</span>
    <span class="p">(</span><span class="nv">prompt-read</span> <span class="s">&#34;Artist: &#34;</span><span class="p">)</span>
	<span class="c1">;; CDのレーティング</span>
    <span class="p">(</span><span class="nv">or</span>
	  <span class="c1">;; レーティングは数値で取得する</span>
	  <span class="c1">;; レーティングデフォルト値: 0</span>
	  <span class="p">(</span><span class="nv">parse-integer</span> <span class="p">(</span><span class="nv">prompt-read</span> <span class="s">&#34;Rating: &#34;</span><span class="p">)</span> <span class="ss">:junk-allowed</span> <span class="no">t</span><span class="p">)</span>
	  <span class="mi">0</span><span class="p">)</span>
	<span class="c1">;; リッピング完了したか</span>
    <span class="p">(</span><span class="nv">y-or-n-p</span> <span class="s">&#34;Ripped [y/n]: &#34;</span><span class="p">)))</span></code></pre></div>
<p>上記の、ユーザにCD1枚分のデータを入力させる関数を利用して、ユーザにCDのデータを好きなだけ入力させる関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">add-cds</span> <span class="p">()</span>
  <span class="s">&#34;ユーザにCD情報を登録させる
</span><span class="s">   ret: -&#34;</span>
  <span class="p">(</span><span class="nv">loop</span> <span class="p">(</span><span class="nv">add-record</span> <span class="p">(</span><span class="nv">prompt-for-cd</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">y-or-n-p</span> <span class="s">&#34;Anther? [y/n]: &#34;</span><span class="p">))</span>
	    <span class="p">(</span><span class="nv">return</span><span class="p">))))</span></code></pre></div>
<h2 id="3-5-データベースの保存と読み出し">3.5 データベースの保存と読み出し</h2>

<p>データベースの保存では、単純に<code>*db*</code>の中身をファイルに書き出すことにする。<br />
あとでファイルから変数に代入できるように、あとからREPLが読み直す事のできる<code>print</code>関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">save-db</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="s">&#34;指定したファイルにデータベースの中身を保存する
</span><span class="s">   filename: 保存先のファイルパス
</span><span class="s">   ret: -&#34;</span>
  <span class="p">(</span><span class="nv">with-open-file</span> <span class="p">(</span><span class="nv">out</span> <span class="nv">filename</span>
                   <span class="ss">:direction</span> <span class="ss">:output</span>      <span class="c1">; 出力先とする</span>
				   <span class="ss">:if-exists</span> <span class="ss">:supersede</span><span class="p">)</span>  <span class="c1">; 既存のファイルを上書き</span>
    <span class="p">(</span><span class="nv">with-standard-io-syntax</span>  <span class="c1">; print関数に影響する変数を標準に保つ</span>
	  <span class="p">(</span><span class="nv">print</span> <span class="vg">*db*</span> <span class="nv">out</span><span class="p">))))</span>     <span class="c1">; REPLで読み直せる形でファイルに書き出す</span></code></pre></div>
<p>ファイルに書き出したデータベースの情報を<code>*bd*</code>に代入する関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">load-db</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="s">&#34;ファイルに書き込まれたデータベースを*db*に読み込む
</span><span class="s">   filename: CDデータベースが保存されたファイルパス
</span><span class="s">   ret: -&#34;</span>
  <span class="p">(</span><span class="nv">with-open-file</span> <span class="p">(</span><span class="nv">in</span> <span class="nv">filename</span><span class="p">)</span> <span class="c1">; inにfilenameの内容を入力する</span>
    <span class="p">(</span><span class="nv">with-standard-io-sytax</span>		<span class="c1">; read関数に影響する変数を標準に保つ</span>
	  <span class="p">(</span><span class="nv">setf</span> <span class="vg">*db*</span> <span class="p">(</span><span class="nv">read</span> <span class="nv">in</span><span class="p">)))))</span></code></pre></div>
<h2 id="3-6-データベースにクエリを投げる">3.6 データベースにクエリを投げる</h2>

<p>特定のアーティストのレコードのみを取得したい場合、<code>remove-if-not</code>関数を利用することが簡単に実現できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">select-by-artist</span> <span class="p">(</span><span class="nv">artist</span><span class="p">)</span>
  <span class="s">&#34;指定したアーティストのレコードのみ返す
</span><span class="s">   artist: アーティスト名
</span><span class="s">   ret: レコードのリスト&#34;</span>
  <span class="p">(</span><span class="nv">remove-if-not</span>
    <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">cd</span><span class="p">)</span>
	    <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:artist</span><span class="p">)</span> <span class="nv">artist</span><span class="p">))</span>
	<span class="nv">artist</span><span class="p">))</span></code></pre></div>
<p>これを応用して、任意のアトリビュートに対して値を指定してレコードを取得する関数を定義する。<br />
タイトル指定用の関数、アーティスト名指定用の関数を全てのアトリビュート分用意すれば、全てのアトリビュートに対して絞り込みをかけることができる。</p>

<p><strong><code>select</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">select</span> <span class="p">(</span><span class="nv">selector-fn</span><span class="p">)</span>
  <span class="s">&#34;データベースからアトリビュート指定用の関数が真となるレコードのみ返す
</span><span class="s">   selector-fn: レコードの検索条件を満たすか判定する関数(セレクタ)
</span><span class="s">   ret: レコードのリスト&#34;</span>
   <span class="p">(</span><span class="nv">remove-if-not</span> <span class="nv">selector-fn</span> <span class="vg">*bd*</span><span class="p">))</span></code></pre></div>
<p>しかしながら、全てのアトリビュートに対して指定用の関数を定義するのは拡張性や保守性が悪くなる。<br />
そこで、キーワードパラメータを使用する。キーワードパラメータとは<code>&amp;key</code>を使用した引数の指定方法で、これを使用すると関数の引数の個数に依存されることがなくなる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">&amp;key</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">list</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span></code></pre></div>
<p>この<code>foo</code>は、下記のように呼び出せる。<br />
見ての通り、<code>&amp;key</code>に続く仮引数の変数は、引数におけるキーワードに続く値により束縛されている。<br />
また、引数の値はキーワードとの対応のみによって仮引数に関連付けられており、引数の位置は全く関係しない。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span> <span class="ss">:c</span> <span class="mi">3</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="no">NIL</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span><span class="p">)</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span></code></pre></div>
<p>また、<code>&amp;key</code>の後に定義された<strong>キーワードパラメータ</strong>では、単純にキーワードパラメータを指定するだけではなく、<br />
<code>(キーワードパラメータ名 デフォルト値 キーワード引数が与えられたかを表す変数)</code><br />
という値を指定できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="nv">&amp;key</span> <span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="mi">30</span> <span class="nv">c-p</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">list</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">c-p</span><span class="p">))</span>

<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="no">T</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span> <span class="ss">:c</span> <span class="mi">3</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="no">T</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">20</span> <span class="mi">3</span> <span class="no">T</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">foo</span><span class="p">)</span>
<span class="p">(</span><span class="no">NIL</span> <span class="mi">20</span> <span class="mi">30</span> <span class="no">NIL</span><span class="p">)</span></code></pre></div>
<p>この<code>&amp;key</code>を利用して、SQLなどの<code>where</code>のような機能を実現する。<br />
where句に相当する関数を返す関数を定義している。
where関数が返す無名関数は、<code>title</code>、<code>artist</code>、<code>rating</code>、<code>ripped</code>をwhere関数から保持している。(クロージャ)</p>

<p><strong><code>where</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">where</span> <span class="p">(</span><span class="nv">&amp;key</span> <span class="nv">title</span> <span class="nv">artist</span> <span class="nv">rating</span> <span class="p">(</span><span class="nv">ripped</span> <span class="no">nil</span> <span class="nv">ripped-p</span><span class="p">))</span>
  <span class="s">&#34;レコードの検索条件を満たすか判定する関数を返す
</span><span class="s">   &amp;key
</span><span class="s">   title: タイトル
</span><span class="s">   artist: アーティスト名
</span><span class="s">   rating: CDのレーティング
</span><span class="s">   ripped: リッピング完了したか
</span><span class="s">   ret: 引数で指定した条件を判定する関数&#34;</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">cd</span><span class="p">)</span>
      <span class="c1">;; レコードが指定された検索条件に合致するか判断する</span>
      <span class="c1">;; cd: 対象レコード</span>
      <span class="c1">;; ret: レコードが指定された検索条件に合致するか</span>
      <span class="p">(</span><span class="nv">and</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">title</span> 
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:title</span><span class="p">)</span> <span class="nv">title</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">artist</span>
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:artist</span><span class="p">)</span> <span class="nv">artist</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">rating</span>
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:rating</span><span class="p">)</span> <span class="nv">rating</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">ripped-p</span>
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:ripped</span><span class="p">)</span> <span class="nv">ripped</span><span class="p">)</span>
          <span class="no">t</span><span class="p">))))</span></code></pre></div>
<p>キーワードパラメータ<code>ripped</code>については、<code>(ripped nil ripped-p)</code>という3つの要素を持つリストを指定している。<br />
これにより、<code>where</code>関数の<code>ripped</code>引数について下記を区別できるようになる。</p>

<ul>
<li><code>where</code>を呼び出した側が、「フィールド<code>ripped</code>の値が<code>nil</code>のCDを選び出せ」という意味で<code>:ripped nil</code>と指定した</li>
<li><code>where</code>を呼び出した側が、「フィールド<code>ripped</code>の値は任意」という意味で、<code>:ripped</code>を指定しなかった</li>
</ul>

<p>これを実行すると、下記のようになる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;;; アーティスト名を指定してレコードを取得する</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:artist</span> <span class="s">&#34;Dixie Chicks&#34;</span><span class="p">))</span>
<span class="c1">;;; レーティングとリッピング歴を指定してレコードを取得する</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:rating</span> <span class="mi">10</span> <span class="ss">:ripped</span> <span class="no">nil</span><span class="p">))</span></code></pre></div>
<h2 id="3-7-既存のレコードを更新する-もう1つの-where-の使い方">3.7 既存のレコードを更新する - もう1つの<code>WHERE</code>の使い方</h2>

<p>ここまでで、SQLクエリの<code>select</code>と<code>where</code>句に相当する関数を定義できた。</p>

<p>次に、SQLクエリの<code>update</code>句に相当する関数を定義する。</p>

<p><strong><code>update</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">update</span> <span class="p">(</span><span class="nv">selector-fn</span> <span class="nv">&amp;key</span> <span class="nv">title</span> <span class="nv">artist</span> <span class="nv">rating</span> <span class="p">(</span><span class="nv">ripped</span> <span class="no">nil</span> <span class="nv">ripped-p</span><span class="p">))</span>
  <span class="s">&#34;特定のレコードを更新する
</span><span class="s">   selector-fn: レコードの検索条件を満たすか判定する関数(セレクタ)
</span><span class="s">   &amp;key
</span><span class="s">   title: 更新後のタイトル
</span><span class="s">   artist: 更新後のアーティスト名
</span><span class="s">   rating: 更新後のレーティング
</span><span class="s">   ripped: 更新後のリッピング歴
</span><span class="s">   ret: -&#34;</span>
  <span class="p">(</span><span class="nv">setf</span> <span class="vg">*db*</span>
        <span class="p">(</span><span class="nv">mapcar</span>
          <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">row</span><span class="p">)</span>
              <span class="c1">;; セレクタで条件にマッチするレコード(row)のみ対象とする</span>
              <span class="p">(</span><span class="nv">when</span> <span class="p">(</span><span class="nv">funcall</span> <span class="nv">selector-fn</span> <span class="nv">row</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">if</span> <span class="nv">title</span>
                    <span class="c1">;; タイトルが指定されている場合、タイトルを更新</span>
                    <span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">row</span> <span class="ss">:title</span><span class="p">)</span> <span class="nv">title</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">if</span> <span class="nv">artist</span>
                    <span class="c1">;; アーティストが指定されている場合、アーティストを更新</span>
                    <span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">row</span> <span class="ss">:artist</span><span class="p">)</span> <span class="nv">artist</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">if</span> <span class="nv">rating</span>
                    <span class="c1">;; レーティングが指定されている場合、レーティングを更新</span>
                    <span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">row</span> <span class="ss">:rating</span><span class="p">)</span> <span class="nv">rating</span><span class="p">))</span>
                <span class="p">(</span><span class="nv">if</span> <span class="nv">ripped-p</span>
                    <span class="c1">;; リッピング歴が指定されている場合、リッピング歴を更新</span>
                    <span class="p">(</span><span class="nv">setf</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">row</span> <span class="ss">:ripped</span><span class="p">)</span> <span class="nv">ripped</span><span class="p">)))</span>
              <span class="nv">row</span><span class="p">)</span>
          <span class="vg">*db*</span><span class="p">)))</span></code></pre></div>
<p><code>update</code>は下記のように使用できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;;; update前</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:artist</span> <span class="s">&#34;Dixie Chicks&#34;</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span> <span class="s">&#34;Home&#34;</span> <span class="ss">:ARTIST</span> <span class="s">&#34;Dixie Chicks&#34;</span> <span class="ss">:RATING</span> <span class="mi">0</span> <span class="ss">:Ripped</span> <span class="no">T</span><span class="p">)</span>
 <span class="p">(</span><span class="ss">:TITLE</span> <span class="s">&#34;Fly&#34;</span> <span class="ss">:ARTIST</span> <span class="s">&#34;Dixie Chicks&#34;</span> <span class="ss">:RATING</span> <span class="mi">0</span> <span class="ss">:Ripped</span> <span class="no">T</span><span class="p">))</span>

<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">update</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:artist</span> <span class="s">&#34;Dixie Chicks&#34;</span><span class="p">)</span> <span class="ss">:rating</span> <span class="mi">11</span><span class="p">)</span>
<span class="no">NIL</span>

<span class="c1">;;; update後</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:artist</span> <span class="s">&#34;Dixie Chicks&#34;</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span> <span class="s">&#34;Home&#34;</span> <span class="ss">:ARTIST</span> <span class="s">&#34;Dixie Chicks&#34;</span> <span class="ss">:RATING</span> <span class="mi">11</span> <span class="ss">:Ripped</span> <span class="no">T</span><span class="p">)</span>
 <span class="p">(</span><span class="ss">:TITLE</span> <span class="s">&#34;Fly&#34;</span> <span class="ss">:ARTIST</span> <span class="s">&#34;Dixie Chicks&#34;</span> <span class="ss">:RATING</span> <span class="mi">11</span> <span class="ss">:Ripped</span> <span class="no">T</span><span class="p">))</span></code></pre></div>
<p><code>delete</code>関数を定義するには、下記のようにする。</p>

<p><strong><code>delete</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">delete-rows</span> <span class="p">(</span><span class="nv">selector-fn</span><span class="p">)</span>
  <span class="s">&#34;特定のレコードを削除する
</span><span class="s">   selector-fn:  レコードの検索条件を満たすか判定する関数(セレクタ)
</span><span class="s">   ret: -&#34;</span>
   <span class="c1">;; 古い*db*から値を削除したデータベースを新しい*db*に代入する</span>
  <span class="p">(</span><span class="nv">setf</span> <span class="vg">*db*</span> <span class="p">(</span><span class="nv">remove-if</span> <span class="nv">selector-fn</span> <span class="vg">*db*</span><span class="p">)))</span></code></pre></div>
<h2 id="3-8-ムダを排除して勝利を収める">3.8 ムダを排除して勝利を収める</h2>

<p>ここまでで、<code>select</code>、<code>where</code>、<code>update</code>、<code>delete</code>は、全て合わせて50行足らずで定義できた。<br />
しかしながら、コード上にはまだ重複が存在するので、それを取り除くことにする。</p>

<p>修正対象は<code>where</code>関数である。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">where</span> <span class="p">(</span><span class="nv">&amp;key</span> <span class="nv">title</span> <span class="nv">artist</span> <span class="nv">rating</span> <span class="p">(</span><span class="nv">ripped</span> <span class="no">nil</span> <span class="nv">ripped-p</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">and</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">title</span> 
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:title</span><span class="p">)</span> <span class="nv">title</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">artist</span>
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:artist</span><span class="p">)</span> <span class="nv">artist</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">rating</span>
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:rating</span><span class="p">)</span> <span class="nv">rating</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">if</span> <span class="nv">ripped-p</span>
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:ripped</span><span class="p">)</span> <span class="nv">ripped</span><span class="p">)</span>
          <span class="no">t</span><span class="p">))))</span></code></pre></div>
<p><code>where</code>関数の下記の部分は、フィールドごとに何度も出てくる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp">        <span class="p">(</span><span class="nv">if</span> <span class="nv">title</span> 
          <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:title</span><span class="p">)</span> <span class="nv">title</span><span class="p">)</span>
          <span class="no">t</span><span class="p">)</span></code></pre></div>
<p>このようなコードの重複は、フィールド構成を変更するときにコードの修正量が多くなるという欠点がある。
そこで、この部分をどうにか短縮することを考える。</p>

<p>まず、<code>where</code>で実現したいことの本質は、「意図したフィールドの値をチェックするコードを生成する」だけである。<br />
例えば、下記の<code>select</code>の呼び出しコードを考える。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:title</span> <span class="s">&#34;Give Us a Break&#34;</span> <span class="ss">:ripped</span> <span class="no">t</span><span class="p">))</span></code></pre></div>
<p>このコードの<code>where</code>部分は、下記のように書き換えられる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">select</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">cd</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">and</span> <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:title</span><span class="p">)</span> <span class="s">&#34;Give Us a Break&#34;</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="ss">:ripped</span><span class="p">)</span> <span class="no">t</span><span class="p">))))</span></code></pre></div>
<p>つまり、<code>where</code>で返される関数内で行われているムダな処理(=引数に渡されていないフィールドの有無まで確認する処理)を省く事ができる。
しかし、全ての<code>where</code>関数呼び出し部分でこの修正を加えるのは非常に骨が折れる。</p>

<p>上記の知見から、修正方針をまとめると下記の2点となる。</p>

<ul>
<li><code>where</code>には、呼び出し時に注目していない(=ムダな)フィールドの存在をチェックするコードを書きたくない</li>
<li><code>where</code>の呼び出し部分で、<code>where</code>を必要なフィールドのみチェックする関数に手作業で置き換えるのは大変なのでやりたくない</li>
</ul>

<p>これを実現するために、マクロを使用する。マクロを使用すれば、必要なフィールドのみチェックするコードを持つ<code>where</code>関数を生成することが可能となる。</p>

<p>例えば、下記のような<code>backwords</code>というマクロを定義すれば、Lispの逆表記バージョンの言語を作ることも可能となる。
このように、マクロを用いることで、REPL評価前の式を変形させることができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">defmacro</span> <span class="nv">backwords</span> <span class="p">(</span><span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nv">reverse</span> <span class="nv">expr</span><span class="p">))</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">backwords</span> <span class="p">(</span><span class="s">&#34;hello, world&#34;</span> <span class="no">t</span> <span class="nv">format</span><span class="p">))</span>
<span class="nv">hello,</span> <span class="nv">world</span>
<span class="nv">NIL</span></code></pre></div>
<p>このようにマクロを使用して、参照されるそれぞれのフィールドに対応した式を返す<code>where</code>マクロを定義してみる。<br />
ここからは、下記の手順で<code>where</code>の改良版を実現する。</p>

<ol>
<li><code>make-comparison-expr</code>関数：フィールドに対応する比較式を作る</li>
<li><code>make-comparison-list</code>関数：<code>make-comparison-expr</code>関数を使って、複数のフィールドに対応する比較式を作る</li>
<li><code>where</code>マクロ：<code>make-comparison-list</code>関数を使って、複数のフィールドに対応する比較式を<code>AND</code>で包んだ関数を返す</li>
</ol>

<p>まず、引数に指定したフィールドに対応した比較の式を返す<code>make-comparison-expr</code>関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">defun</span> <span class="nv">make-comparison-expr</span> <span class="p">(</span><span class="nv">field</span> <span class="nv">value</span><span class="p">)</span>
    <span class="s">&#34;指定したフィールドに対応する比較式を返す
</span><span class="s">     field: フィールド名
</span><span class="s">     value: 値
</span><span class="s">     ret: フィールドに対応する比較式&#34;</span>
    <span class="o">`</span><span class="p">(</span><span class="nv">equal</span> <span class="p">(</span><span class="nv">getf</span> <span class="nv">cd</span> <span class="o">,</span><span class="nv">field</span><span class="p">)</span> <span class="o">,</span><span class="nv">value</span><span class="p">))</span></code></pre></div>
<p>これを使用すると、下記のようになる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">make-comparison-expr</span> <span class="ss">:rating</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">GETF</span> <span class="nv">CD</span> <span class="ss">:RATING</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">make-comparison-expr</span> <span class="ss">:title</span> <span class="s">&#34;Give Us a Break&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">GETF</span> <span class="nv">CD</span> <span class="ss">:TITLE</span><span class="p">)</span> <span class="s">&#34;Give Us a Break&#34;</span><span class="p">)</span></code></pre></div>
<p>次に、<code>make-comparison-expr</code>関数が返す比較式を集める<code>make-comparison-list</code>関数を定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defun</span> <span class="nv">make-comparison-list</span> <span class="p">(</span><span class="nv">fields</span><span class="p">)</span>
  <span class="s">&#34;複数の指定したフィールドに対応する比較式のリストを返す
</span><span class="s">   fields: フィールドのキーワードと値が交互に並んだリスト
</span><span class="s">   ret: フィールドに対応する比較式のリスト&#34;</span>
  <span class="p">(</span><span class="nv">loop</span> <span class="nv">while</span> <span class="nv">fields</span>
    <span class="nv">collecting</span> <span class="p">(</span><span class="nv">make-comparison-expr</span> <span class="p">(</span><span class="nv">pop</span> <span class="nv">fields</span><span class="p">)</span> <span class="p">(</span><span class="nv">pop</span> <span class="nv">fields</span><span class="p">))))</span></code></pre></div>
<p>最後に、<code>make-comparison-list</code>関数が返す比較式のリストを<code>AND</code>で包む<code>where</code>マクロを定義する。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">defmacro</span> <span class="nv">where</span> <span class="p">(</span><span class="nv">&amp;rest</span> <span class="nv">clauses</span><span class="p">)</span>
  <span class="c1">;; 複数のフィールドに対応する比較式を`AND`で包んだ関数を返す</span>
  <span class="c1">;; clauses: whereで指定するフィールド(複数)</span>
  <span class="c1">;; ret: 指定された複数フィールドに対応するフィルタ関数</span>
  <span class="o">`</span><span class="nf">#&#39;</span><span class="p">(</span><span class="nv">lambda</span> <span class="p">(</span><span class="nv">cd</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">and</span> <span class="o">,@</span><span class="p">(</span><span class="nv">make-comparisons-list</span> <span class="nv">clauses</span><span class="p">))))</span></code></pre></div>
<p><strong>NOTE</strong><br />
<code>&amp;rest</code>が引数リストにあると、関数やマクロは任意個の引数をとれるようになり、その引数はリストとして<code>&amp;rest</code>の直後にある仮引数を束縛する。<br />
つまり、下記のようになる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">defun</span> <span class="nv">f</span> <span class="p">(</span><span class="nv">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
    <span class="nv">args</span><span class="p">)</span>
<span class="nv">&gt;</span> <span class="p">(</span><span class="nv">f</span> <span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span> <span class="ss">:d</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span> <span class="ss">:d</span> <span class="mi">4</span><span class="p">)</span></code></pre></div>
<p><strong>NOTE</strong><br />
<code>,@</code>は、評価された結果のリストを展開する。つまり、下記のようになる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="c1">;; ,@を使わない例</span>
<span class="o">`</span><span class="p">(</span><span class="nv">and</span> <span class="o">,</span><span class="p">(</span><span class="nv">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nv">AND</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1">;; ,@を使う例</span>
<span class="o">`</span><span class="p">(</span><span class="nv">and</span> <span class="o">,@</span><span class="p">(</span><span class="nv">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nv">AND</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">`</span><span class="p">(</span><span class="nv">and</span> <span class="o">,@</span><span class="p">(</span><span class="nv">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nv">AND</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span></code></pre></div>
<p><code>where</code>マクロを呼び出すとどんなコードが生成されるのかを知るには、<code>macroexpand-1</code>関数が使用できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">macroexpand-1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">where</span> <span class="ss">:title</span> <span class="s">&#34;Give Us a Break&#34;</span> <span class="ss">:ripped</span> <span class="no">t</span><span class="p">))</span>
<span class="nf">#&#39;</span><span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">CD</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">AND</span> <span class="p">(</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">GETF</span> <span class="nv">CD</span> <span class="ss">:TITLE</span><span class="p">)</span> <span class="s">&#34;Give Us a Break&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">GETF</span> <span class="nv">CD</span> <span class="ss">:RIPPED</span><span class="p">)</span> <span class="no">T</span><span class="p">))</span>
<span class="nv">T</span></code></pre></div>
<p>実際に、上記で定義した<code>where</code>マクロを試してみる。</p>
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">&gt;</span> <span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="nv">where</span> <span class="ss">:title</span> <span class="s">&#34;Give Us a Break&#34;</span> <span class="ss">:ripped</span> <span class="no">t</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span> <span class="s">&#34;Give Us a Break&#34;</span> <span class="ss">:ARTIST</span> <span class="s">&#34;Limpopo&#34;</span> <span class="ss">:RATING</span> <span class="mi">10</span> <span class="ss">:RIPPED</span> <span class="no">T</span><span class="p">))</span></code></pre></div>
<p>このように、<code>where</code>マクロは最初の<code>where</code>関数よりも短く簡潔で、かつ、特定のフィールドと結びついていないため、フィールドの構成変更に影響されない。</p>

<h2 id="3-9-まとめ">3.9 まとめ</h2>

<p>上記では、コードの重複を取り除こうとしたら、同時にコードの汎用性も向上した。何故だろうか？<br />
なぜなら、マクロはシンタックスレベルでの抽象化を施す仕組みの1つであり、抽象化というのは物事の普遍性を表現する手法の1つであるからである。</p>

<p>なお、この簡易データベースのコードにおいて、CDとそのフィールド固有のコードを含む箇所は、<code>make-cd</code>と<code>prompt-for-cd</code>と<code>add-cd</code>のみとなっていることにも注目するべきである。</p>

  </article>

  
  
    
    <div class="author-card">
    <div class="underline"></div>
    <div class="author-box">
      <div class="author-image"><a href="https://github.com/otaon"><img src="/web/images/otaon.png" alt="otaon" /></a></div>
      <div class="author-content">
      <p class="author-title">著者</p>
      <p class="author-name">otaon</p>
      <p class="author-desc">こんにちは</p>
      </div>
    </div>
  </div>
    
  
  


</div>

  </main><div class="footer gradient-2">
  <div class="container footer-container ">
    <div class="row">
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        <div class="footer-title">サイトマップ</div>
        <ul class="list-unstyled">
            
              
                <li><a href="https://otaon.github.io/web/ja-jp/tags/">タグ</a></li>
              
              
                <li><a href="https://otaon.github.io/web/ja-jp/categories/">カテゴリ</a></li>
              
            
            
            
            <li><a rel="alternate" type="application/rss&#43;xml" href="https://otaon.github.io/web/ja-jp/index.xml"><i class="fas fa-rss-square"></i> RSS Feed</a></li>
            
            
            
        </ul>
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">SNS</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/otaon" rel="noopener" target="_blank">GitHub</a></li>
          
        </ul>
        
      </div>
      <div class="col-xs-4 col-sm-3 col-md-3 col-lg-3">
        
        <div class="footer-title">リンク</div>
        <ul class="list-unstyled">
          
          <li><a href="https://github.com/otaon" rel="noopener" target="_blank">著者について</a></li>
          
        </ul>
        
      </div> 
      <div class="col-xs-12 col-sm-3 col-md-3 col-lg-3">
        <p class="pull-right text-right">
          <small><em>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a></em></small><br/>
          <small><em>Theme - <a href="https://github.com/shaform/hugo-theme-den" rel="noopener" target="_blank">Den</a></em></small><br/>
          <small>
            &copy; 
            otaon
            2019
          </small>
          
        </p>
      </div>
    </div>
  </div>
</div>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/web/asset/mermaid/mermaid.js"></script>

</body>
</html>
