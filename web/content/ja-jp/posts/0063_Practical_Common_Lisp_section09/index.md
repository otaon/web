---
title: "書籍 実践 Common Lisp 第9章 実践：ユニットテストフレームワーク"
date:    2019-05-28T00:00:00+09:00
lastmod: 2019-05-28T00:00:00+09:00
draft: false
toc: true
tags: ["lisp", "実践-Common-Lisp"]
categories: ["実践-Common-Lisp"]
authors:
- otaon
---

## この章について
この章では、マクロを使ってユニットテストフレームワークを作成する。

テストとは、結局のところ**承認(accept)**か**拒否(reject)**のどちらかに評価される。  
しかし、使い勝手を考えていくと、下記のような機能が無いと困ることに気付く。

- どのサブテストが失敗したのかを表示する
- 失敗したときの期待値と実行結果は何だったのかを表示する

## 9.1 最初の試みを2件
副作用を持つ機能に対しては、機能を呼び出した後に、正しい副作用が起こったのかを確かめる必要がある。  
反対に、副作用を持たない機能に対しては、機能の戻り値を受け取って、期待値と比較すれば良い。

例えば、加算`+`が正しく実行されているか確認するための簡単なテストなら、下記のコードで十分だ。

```lisp
(defun test-+ ()
  (and (= (+ 1 2) 3)
       (= (+ 1 2 3) 6)
       (= (+ -1 -3) -4)))

(test-+)
; => T
```

各テストケースで何が起こったのかを確認したいのであれば、下記のように愚直に各方法もある。  
`~:[FAIL~;pass~]`、最初の引数が偽の場合は"FAIL"を、そうでなければ"pass"を表示する。

```lisp
(defun test-+ ()
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ 1 2) 3)    '(= (+ 1 2) 3))
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ 1 2 3) 6)  '(= (+ 1 2 3) 6))
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ -1 -3) -4) '(= (+ -1 -3) -4)))
```

上記のコードでは、下記の点で使いにくい。

- 繰り返し`format`を呼び出している
- テストの式が表示用と評価用で2度記述されている
- 全体として合格か不合格かが分かりにくい(全テストケースがpassであると確認する必要がある)

## 9.2 先述のコードをリファクタリングする
ここで本当に実現したいのは、下記の両立だ。

- 1つ目の例のように、`T`か`NIL`を返す1つ目のバージョンの`test-+`くらい直感的
- 2つ目の例のように、個々のテストケースについての結果も報告される

似たような`format`の呼び出しを繰り返さないようにするには、新しい関数を定義する。

```lisp
(defun report-result (result form)
  (format t "~:[FAIL;pass~] ... ~a~%" result form))
```

`format`の代わりに上記の`report-result`を使うことで、結果のレポート方法の定義を一箇所にまとめられた。

```lisp
(defun test-+ ()
  (report-result (= (+ 1 2) 3)    '(= (+ 1 2) 3))
  (report-result (= (+ 1 2 3) 6)  '(= (+ 1 2 3) 6))
  (report-result (= (+ -1 -3) -4) '(= (+ -1 -3) -4)))
```

次に、テストケースの式が、表示用と評価用で繰り返されている部分をまとめる。  
マクロを使えば簡単に定義できる。

```lisp
(defmacro check (form)
  `(report-result ,form ',form))

(check (= (+ 1 2) 3))
; =>
; (report-result (= (+ 1 2) 3)    '(= (+ 1 2) 3))
```

`check`を使って`test-+`を書き換えると下記の通りになる。


```lisp
(test-+
  (check (= (+ 1 2) 3))
  (check (= (+ 1 2 3) 6))
  (check (= (+ -1 -3) -4)))
```

上記を見ると、そもそも`check`を繰り返していることに気付く。これも邪魔なので記述しないように`check`を修正する。  
下記では、**複数のフォームの並びを単一のフォームにするため`progn`で包み込む**というイディオムを利用している。
ここでは必須ではないが、紹介のために使用している。よく使うので覚えると良い。

```lisp
(defmacro check (&body forms)
  `(progn
     ,@(loop for f in forms
             collect `(report-result ,f ',f))))
```

こうすると、`test-+`は下記の通りになる。

```lisp
(test-+
  (check
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
```

上記の`check`を展開すると下記の通りになる。

```lisp
(defun test-+ ()
  (progn
    (report-result (= (+ 1 2) 3)    '(= (+ 1 2) 3))
    (report-result (= (+ 1 2 3) 6)  '(= (+ 1 2 3) 6))
    (report-result (= (+ -1 -3) -4) '(= (+ -1 -3) -4))))
```
