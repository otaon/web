---
title: "Go言語入門(リテラル・型変換)"
date:    2019-04-13T08:00:00+09:00
lastmod: 2019-04-13T08:00:00+09:00
draft: false
toc: true
tags: ["Go", "Golang"]
categories: ["Go"]
authors:
- otaon
---

# 目的
Go言語の基本構文を残す。

# 参考文献
- [スターティング Go言語](https://www.shoeisha.co.jp/book/detail/9784798142418)

# 基本構文
## 型の扱い
### 整数リテラル
Goの整数リテラルにはC言語と同じく3種類存在する。

- 10進数・・・`[1-9][0-9]*` 例: `123`
- 8進数・・・`0[1-7][0-7]*` 例: `0755`
- 16進数・・・`0[Xx][0-9A-Fa-f]+` 例: `0x0719BEEF`

### その他のリテラル
整数型以外も含めると、リテラルには下記がある。

```go
i := 1	// int型

f64 := 1.0	// float64型
f32 := float32(1.0)	// float32型のリテラルは存在しない。型変換が必要。

zero := 0.0	// float64型
pinf := 1.0 / zero	// +Inf 正の無限大(float64型)
ninf := -1.0 / zero	// -Inf 負の無限大(float64型)
nan := zero / zero	// NaN 非数(float64型)

// その他の浮動小数点型リテラル
0.
72.40
072.40	// 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

c := 1.0 + 3i	// complex128型
c2 := complex(1.0, 3)	// complex128型(組み込み関数を使用)
r := real(c2)	// 1.0(実部)
i := imag(c2)	// 3.0(虚部)

// その他の複素数型リテラル
0i
011i	// 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

rune := '松'	// == 26494 rune型(int32のエイリアス)

// その他のruneリテラル
'\a' 'U+0007'	// ベル
'\b' 'U+0008'	// バックスペース
'\f' 'U+000C'	// フィード
'\n' 'U+000A'	// 改行(LF)
'\r' 'U+000D'	// 改行(CR)
'\t' 'U+0009'	// 水平タブ
'\v' 'U+000b'	// 垂直タブ
'\\' 'U+005c'	// バックスラッシュ
'\'' 'U+0027'	// シングルクォート(ルーンリテラルのみ)
'\"' 'U+0022'	// ダブルクォート(文字列リテラルのみ)

'a'
'本'
'\t'

// 8進数3桁
'\000'
'\007'
'\377'

// 16進数2桁
'\x07'
'\xff'

// 16進数4桁(小さいUnicodeコードポイント)
'\u12e4'

// 16進数8桁(大きいUnicodeコードポイント)
'\U00101234'

"文字列"	// 文字列リテラル


`
abcd
efg
hijk
`	// RAW文字列リテラル(改行や特殊文字を後処理せずそのまま扱う)
```

### 型変換
Goでは、**異なる型の暗黙的な型変換を許容しない**。したがって、下記のコードはコンパイルエラーとなる。

```go
var (
	n1 int
	n2 int64
)
n1 = 1
n2 = n1	// コンパイルエラー
```

明示的な型変換は可能。下記のように、`型名(変換対象)`と記述することで型変換できる。

```go
i := 17				// 型指定子がないとリテラルの型(この場合はint型)の変数iにint型の17を代入
n := uint(17)		// uint型の変数nにuint型の17を代入
b := byte(n)		// byte型に変換
i64 := int64(n)		// int64型に変換
u32 := uint32(n)	// uint32型に変換
```

#### 整数型の型変換時の"ラップアラウンド"
下記の場合は、整数リテラル(int)からbyte型へのナローイング変換をコンパイラが検知して、コンパイルエラーとなる。

```go
b := byte(256)	// コンパイルエラー
```

しかし、いったんint型の変数に値を代入して、それを型変換変換すると、ナローイング変換できてしまう。下記の場合、`b`は`0`となる。

```go
n := 256
b := byte(n)	// b == byte(0)
```

Go言語は、C言語と同様に、オーバーフローした時にその型で扱えない桁のビットを単純に無視する。これにより、ある型において、演算結果を、ある型の`mod`のようなものとして扱うことをラップアラウンドと呼ぶ。

#### 各々の方の最大値・最小値を使ったラップアラウンド対策
Goでは、C言語と同様にオーバーフローを考慮した演算を行う必要がある。  
この際に、`math`パッケージに用意されている<u>各々の方の最大値・最小値</u>を使用することができる。


```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("uint32 max value = %d\n", math.MaxUint32)	// uint32 max value = 4294967295
}
```

各々の型の最大値・最小値は下記の通り。

```Go
MaxInt8 =  1 << (8 - 1) - 1
MinInt8 = -1 << (8 - 1)

MaxInt16 =  1 << (16 - 1) - 1
MinInt16 = -1 << (16 - 1)

MaxInt32 =  1 << (32 - 1) - 1
MinInt32 = -1 << (32 - 1)

MaxInt64 =  1 << (64 - 1) - 1
MinInt64 = -1 << (64 - 1)

MaxUInt8 = 1 << 8 - 1
MaxUInt16 = 1 << 16 - 1
MaxUInt32 = 1 << 32 - 1
MaxUInt64 = 1 << 64 - 1

MaxFloat32 = 2**127 * (2**24 - 1) / 2**23
SmallestNonzeroFloat32 = 1 / 2**(127 - 1 + 23)
MaxFloat64 = 2**1023 * (2**53 - 1) / 2**52
SmallestNonzeroFloat64 = 1 / 2**(1023 - 1 + 52)
```

上記の型の最大値・最小値を使用すれば、オーバーフローに(比較的)楽に対応できる。

```go
func sum(a, b uint32) bool {
	if (math.MaxUint32 - a) < b {
		// オーバーフローする
		return false;
	}

	sum := a + b	// このパスではオーバーフローしないことを保証済み
	return sum
}
```