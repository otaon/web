---
title: "ポリモーフィズム・部分型付け・派生型"
date:    2019-05-01T23:00:00+09:00
lastmod: 2019-05-01T23:00:00+09:00
draft: false
toc: true
tags: ["programming", "ポリモーフィズム", "部分型付け", "派生型", "リスコフの置換原則", "仮想関数テーブル"]
categories: ["programming"]
authors:
- otaon
---

# 目的
部分型付け・派生型・リスコフの置換原則・仮想関数テーブルについての学習記録を残す。

# 参考文献
本文中に記す。

# ポリモーフィズム(部分型付け)
とりあえずWikipediaの記事から、言葉を少し補って引用する。

[Wikipedia - ポリモーフィズム#部分型付け](https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0#%E9%83%A8%E5%88%86%E5%9E%8B%E4%BB%98%E3%81%91)

## 部分型付け(部分型多相)とは

> - いくつかのプログラミング言語では、特定の多相性の状況において使用できる型の範囲を制限するために**部分型付け(部分型多相とも呼ばれる)**を採用している。
> - そういった言語で部分型付けを使用すると、ある型`Type`のオブジェクトを受け取る関数は、`Type`の部分型である型`Subtype`のオブジェクトを渡された場合でも正しく動作する (**リスコフの置換原則**)。  
> この型の関係性はしばしば`Subtype<:Type`と表記される。
> - 一般的に部分型多相は動的に解決される (後述)。

部分型付け(部分型多相)は、基本型が使われている箇所を完全に置き換え可能な部分型を定義すること。
つまり、基本型(例:`Base`クラス)の箇所を派生型(例:`Derived`クラス)に置き換えられるように派生型を定義すること。  
C言語の場合、`char`型の箇所を`int`型に置き換えても成り立つ(今はエッジケースは無視する)ため、`int`型は`char`型の派生型だと言える。

### リスコフの置換原則
[Wikipedia - リスコフの置換原則](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87)」

> `T`型のオブジェクト`x`に関して真となる属性を`q(x)`とする。  
> このとき`S`が`T`の派生型であれば、`S`型のオブジェクト`y`について`q(y)`が真となる。

リスコフの置換原則を設計指針に置き換えると、「基本型が使われている任意の箇所は、派生型で置き換えても正しく動作する必要がある」となる。

## サブクラス化(継承)・仮想関数テーブルについて

> - オブジェクト指向言語は**サブクラス化 (継承)**によって部分型多相を提供する。  
> - 典型的な実装では、各クラスはそれぞれ**仮想関数テーブル(`vtable`)**と呼ばれる関数のテーブルを持ち、各オブジェクトは自らのクラスのvtableへのポインタを持つ。  
> 多相なメソッドを呼び出すときには、この仮想関数テーブルを参照する。

部分型付けは、大抵の場合**サブクラス化(継承)**によって実現される。  
サブクラス化(継承)機能を持つオブジェクト指向言語においては、典型的には仮想関数テーブル(`vtable`)を用いて、インスタンス自体の型に定義されるメソッドを呼び出す。  
仮想関数テーブルについては「[ディスパッチ・仮想関数テーブルについて学ぶ]({{<relref "posts/0054_Dispatch/index.md" >}})」を参照。

## ポリモーフィズム(部分型付け)の種類
部分型付けには、2種類(名前的部分型・構造的部分型)ある。

[数理科学的バグ撲滅方法論のすすめ - 第4回 関数型言語とオブジェクト指向，およびOCamlの"O"について](https://tech.nikkeibp.co.jp/it/article/COLUMN/20061107/252787/)

> - OCamlは，クラスや継承・インタフェースなどを宣言しなくても，オブジェクトやメソッドの型を自動で推論する。  
> - 部分型関係（いわゆるis-a関係の一種）も，実際のオブジェクトの型にしたがい，あらかじめ宣言をしなくても成立する。  
> - これを構造的部分型（structural subtyping）という。  
> - 逆に，JavaやC++のように，あらかじめ宣言しなければ成立しない部分型関係を名前的部分型（nominal subtyping）と呼ぶ。

### 名前的部分型(Nominal Subtyping)
部分型の実現方法のうち、継承関係をキーワードなどで明言して確定させるもの。  
例:  

- Java `class DerivedClass extends SuperClass`  
- C# `class DerivedBlass : SuperClass`  
- python `class DerivedClass(SuperClass):`

### 構造的部分型(Structural Subtyping)
部分型の実現方法のうち、継承関係を構造から静的に推論して確定させるもの。  
ある意味、静的なダックタイピングと捉えることもできる。  
例(実コードは省略):  

- OCaml  
- Scala  
- Go(`interface{}`の扱い方が構造的部分型)  
- Typescript
