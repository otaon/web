---
title: "書籍 実践 Common Lisp 第12章 リスト処理：やつらがLISPと呼ぶ理由"
date:    2019-06-02T00:00:00+09:00
lastmod: 2019-06-02T00:00:00+09:00
draft: false
toc: true
tags: ["lisp", "実践-Common-Lisp"]
categories: ["実践-Common-Lisp"]
authors:
- otaon
---

## この章について
この章では、リストついて説明する。

## 12.1 「リストなんてない」
Common Lispにおいては、リストというデータ構造が構築されているわけではない。  
実際には、コンスセルによって構築されたデータ構造があり、それをリスト操作用の関数群によってそう見せているに過ぎない。

```lisp
; コンスセルの生成
(cons 1 2) ; (1 . 2)
```

コンスセルを構成する各値を`(a . b)`のように括弧とドットで区切って表現したものをドット対(dotted pair)と呼ぶ。  
なお、コンスの語源はconstruct。

コンスセルの左側の値にアクセスするには`car`を用いる。  
コンスセルの右側の値にアクセスするには`cdr`を用いる。

```lisp
(car (cons 1 2)) ; 1
(cdr (cons 1 2)) ; 2
```

`car`も`cdr`も`setf`可能。すなわち、下記のような記述ができる。

```lisp
(defparameter *cons* (cons 1 2))
*cons*
; (1 . 2)
(setf (car *cons*) 10)
; 10
*cons*
; (10 . 2)
(setf (cdr *cons*) 20)
; 20
*cons*
; (10 . 20)
```

**NOTE** `setf`マクロの中では`car`は`rplaca`に、`cdr`は`rplacd`に変換される。

```lisp
(macroexpand-1 '(setf (car *x*) 100))
; (SB-KERNEL:%RPLACA *X* 100)
(macroexpand-1 '(setf (cdr *x*) 100))
; (SB-KERNEL:%RPLACD *X* 100)
```

リストとは、コンスセルを鎖の様に連結することで得られるデータ構造だと言える。  
リスト中の特定の要素の値は、その要素のコンスセルの`car`によって参照され、次の要素はコンスセルの`cdr`によって参照される。  
最後の要素のコンスセルは`cdr`に`nil`を持つ。  
したがって、あるデータがリストであるとは、そのデータが`nil`(空リスト)かコンスセルへの参照を持っていることと同義だ。

リストを扱うときに`car`と`cdr`を使用すると意味が伝わりにくいため、`car`には`first`を`rest`には`rest`を代わりに使うほうが良い。

```lisp
(defparameter *list* (list 1 2 3 4))
(car *list*) ; 1
(first *list*) ; 1
(cdr *list*) ; (2 3 4)
(rest *list*) ; (2 3 4)
```

## 12.2 関数プログラミングとリスト
Common Lispにおいては、リストを操作する関数は、リストを無駄に生成しないように、リストを構成するコンスセルの一部を共有してリストを生成することがある。  
したがって、共有されたリストを変更すると、意図しないリストに対しても影響してしまう可能性がある。

例えば、`append`は、与えられた引数のうち、最後の引数に対してはリストの複製を行わず、そのリストの先頭に対して、他の引数のリストの`cdr`の参照を繋げるのみの操作をする。これにより、下図のようなデータ構造が作成される。

{{<figure src="lists.svg" alt="litst" width="400" align="aligncenter">}}

このデータ構造を考慮せずに`*list-2*`を変更すると、意図せずして`*list-3*`も変更してしまう。

```lisp
(defparameter *list-1* (list 1 2))
(defparameter *list-2* (list 3 4))
(defparameter *list-3* (append *list-1* *list-2*))
; (1 2 3 4)
(setf (first *list-2*) 0)
; 0
*list-2*
; (0 4)
*list-3*
; (1 2 0 4) ; *list-3*も変更されている
```



## 12.3 破壊的な操作
関数には、副作用によってリストを破壊するものがある。これを破壊的な操作と呼ぶことにする。  
これは2種類に大別できる。

### 副作用を目的に使用される操作
そもそも副作用を目的として使用される操作がある。これは**非**関数プログラミングのスタイルの操作。  
12.1で示した例のとおり、この種類の操作は、共有されているリストを書き換えてしまわないように注意する必要がある。

代表的なものには`setf`がある。  
また、`vertor-push`や`vector-pop`のように、内部で`setf`を呼ぶような操作も破壊的な操作。  


### 「リサイクルする」操作
リサイクル操作はこの本の造語。  
この種類の操作は、操作の結果を生成する際に、引数に渡されたリストのメモリ領域を再利用する。  
また、この種類の操作は、**関数的**なコードの中で利用することを想定されている。  

例えば`reverse`は関数的な操作だ。すなわち、引数に渡されたリストは変更されない。  
一方、これのリサイクル版の`nreverse`は破壊的な操作だ。すなわち、結果が、引数に渡されたリストのメモリ領域に上書きされる。  

```lisp
(defparameter *list* (list 1 2 3 4))

; reverse
; 新しいメモリ領域にデータを格納して、参照を付け替えている
(setf *list* (reverse *list*))
*list* ; (4 3 2 1)

(defparameter *list* (list 1 2 3 4))

; nreverse
(nreverse *list*)
*list* ; (4 3 2 1)
```

上記コードにおいて、`(setf *list* (reverse *list*))`の方も`*list*`を上書きしているには違いない。  
しかし、こちらは`*list*`を新しいメモリ領域にアサインし、そこに`reverse`の戻り値を格納している。  
したがって、元々の`*list*`のメモリ領域もガベージコレクションが働くまで確保された状態になる。  
一方で`nreverse`は元々の`*list*`のメモリ領域のみ使用しているため、無駄にメモリを消費することがない。

### 関数的な操作と破壊的な操作の対応
大抵の破壊的な操作には、共通して語頭に`n`がついている。`n`は`non-consing`、すなわち、新しいコンスセルを確保しないという意味。

大抵の破壊的な操作には、同じ演算結果を返す非破壊的な関数が存在し、その関数名の語頭には`n`がついていない。
しかし、下記のように例外もある。

- 関数的な操作 : `append`  
  破壊バージョン : `nconc`
- 関数的な関数 : `remove`,`remove-if`,`remove-if-not`,...  
  破壊バージョン : `delete`,`delete-if`,`delete-if-not`,...

大抵の破壊的な操作は、その操作による副作用が厳密に規定されていないため、その副作用を目的に使用できない。  
ただし、例外があり、`nconc`,`nsubstitute`,`nsubstitute-if`,...などは副作用の結果が規定されており、それを利用できる。

`nconc`は、下記の通り動作する。

1. 渡された空ではない全てのリストについて、そのリストの最後のコンスセルの`cdr`に、次の引数のリストの先頭を参照させる。
1. 上記を繰り返す。
1. 最後に最初のリストの先頭を返す。

`nsubstutute`とその亜種は、下記の通り動作する。

1. 引数のリストをトラバースする。
1. 古い値を保持しているコンスセルの`car`を新しい値に`setf`する。

上記のように、副作用が明確に規定されたものもあるが、通常はこの副作用を期待したコードは書くべきではない。
