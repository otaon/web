---
title: "Go言語入門(参照型)"
date:    2019-04-13T16:00:00+09:00
lastmod: 2019-04-13T16:00:00+09:00
draft: false
tags: ["Go", "Golang"]
categories: ["Notes"]
authors:
- otaon
---

# 目的
Go言語の基本構文を残す。

# 参考文献
- [スターティング Go言語](https://www.shoeisha.co.jp/book/detail/9784798142418)

# 基本構文
## 参照型
Goには、参照型と呼ばれる下記の３つの型がある。

- `slice` スライス
- `map` マップ
- `channel` チャネル

### `make`関数の使用方法
参照型の生成には、組み込み関数`make`を使用する。

|呼び出し形式|&nbsp;&nbsp;型`T`|&nbsp;&nbsp;意味|
|---|---|---|
|`make(T, n)`|&nbsp;&nbsp;スライス|&nbsp;&nbsp;要素数と容量が`n`である`T`型のスライスを生成|
|`make(T, n, m)`|&nbsp;&nbsp;スライス|&nbsp;&nbsp;要素数が`n`で容量が`m`である`T`型のスライスを生成|
|`make(T)`|&nbsp;&nbsp;マップ|&nbsp;&nbsp;`T`型のマップを生成|
|`make(T, n)`|&nbsp;&nbsp;マップ|&nbsp;&nbsp;`T`型のマップを、要素数`n`をヒントにして生成|
|`make(T)`|&nbsp;&nbsp;チャネル|&nbsp;&nbsp;バッファ無しの`T`型のチャネルを生成|
|`make(T, n)`|&nbsp;&nbsp;チャネル|&nbsp;&nbsp;バッファサイズ`n`の`T`型のチャネルを生成|

### スライス(slice)
スライスは可変長配列を表現する型。  
スライスには、配列とは異なり、**要素数**と**容量**という概念がある。

要素数(length)
: スライスの生成時に、値を格納するために確保される領域。  
組み込み関数`len()`で取得できる。

容量(capacity)
: スライスの生成時に、後でスライスを拡張する際に使用するための領域。  
組み込み関数`cap()`で取得できる。

```go
// スライス生成の書式
make(型名, 要素数, 容量*)
```

```go
// int型を格納するスライス
var s []int

// 要素数と容量が10であるint型のスライスを生成する
s := make([]int, 10)
fmt.Println(s)
// =>
// [0 0 0 0 0 0 0 0 0 0]

// スライスの使い方
s = make([]float64, 3)
fmt.Println(a)	// => "[0, 0, 0]"
a[0] = 3.14
fmt.Println(a)	// => "[3.14, 0, 0]"
a[1] = 6.28
fmt.Println(a)	// => "[3.14, 6.28, 0]"
fmt.Println(a[0])	// => "3.14"
fmt.Println(a[4])	// 要素数を超えた要素にアクセスしたためランタイムパニック発生

// 要素数8, 容量8のスライス
s = make([]int, 8)
// スライスの要素数を調べる
len(s)	// == 8

// 要素数5, 容量5のスライス
s = make([]int, 5)
// スライスの要素数を調べる
len(s)	// == 5
// スライスの容量を調べる
cap(s)	// == 5

// 要素数5, 容量10のスライス
s = make([]int, 5, 10)
// スライスの要素数を調べる
len(s)	// == 5
// スライスの容量を調べる
cap(s)	// == 10
```

例えば、要素数5, 容量10のスライスは下記のようになる。  
`[n]`によるインデックスで参照・代入できる範囲は0～4までだが、スライスの容量としては10個分のメモリ領域を確保している。

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|

上記のスライスに要素を追加していくと、容量いっぱいまではそのまま残りの空き領域を使う。  
そして、容量がいっぱいになってしまった状態で、更に要素を追加すると、**容量10よりも大きなメモリ領域を確保して、元のスライスのデータを丸ごとコピーする**。  
データのコピーは計算コストが高いため、容量が推測できる場合はなるべくその推測値を設定してスライス生成したほうが良い。

#### リテラルでスライスを生成する
配列やスライスを元にして、新しいスライスを生成するために、**簡易スライス式(simple slice expressions)**という機能がある。

```go
// 要素数5の配列
a := [5]int{1, 2, 3, 4, 5}

// 配列aの要素0から要素1(2-1)までの要素を元にスライスを生成する
s := a[0:2]	// 変数sは[]int型

fmt.Println(s)	// => "[0, 1]"
```

簡易スライス式には下記の記述パターンがある。

|`a := [5]int{1, 2, 3, 4, 5}`|&nbsp;&nbsp;意味|&nbsp;&nbsp;結果|
|----|----|----|
|`a[0:2]`|&nbsp;&nbsp;要素0～1のスライス|&nbsp;&nbsp;`[0, 1]`|
|`a[2:]`|&nbsp;&nbsp;要素2～`len(a)-1`のスライス|&nbsp;&nbsp;`[3, 4, 5]`|
|`a[:4]`|&nbsp;&nbsp;要素0～3のスライス|&nbsp;&nbsp;`[1, 2, 3, 4]`|
|`a[:]`|&nbsp;&nbsp;要素0～`len(a)-1`のスライス|&nbsp;&nbsp;`[1, 2, 3, 4, 5]`|

見て分かるとおり、簡易スライス式の書式は下記の通り。  
簡易スライス式を使って生成したスライスは、生成元の配列の参照していない範囲が容量になる。

```go
配列[開始インデックス:末尾の次のインデックス]
// => 開始インデックス～末尾インデックスのスライス
```

`var a [10]int`のとき、`a[2:4]`は下記のような範囲となる。

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|||&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|
|**容量**|||&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|||||


文字列にも簡易スライス式を適用できる。ただしマルチバイト文字列の場合は注意が必要。

```go
s := "ABCDE"[1:3]	// => s == "BC"

// 文字列はバイト列として処理する必要があるため、
// "あ"を3バイト分でカウントする
s = "あいうえお"[3:9]	// => "いう"
```

#### 組み込み関数`append`で要素を追加する
`append`を使うことで、スライスの末尾に要素を追加した新たなスライスを生成できる。  
`append`の戻り値を変数に代入しないとコンパイルエラーとなることに注意。  
また、`append`の2番目以降の引数は可変長引数で、スライスの要素の型に合致する値を任意個指定できる。

```go
// 要素数3のスライス
s := []int{1, 2, 3}

// 4をスライスの末尾に追加
s = append(s, 4)	// s == [1, 2, 3, 4]

// 5, 6, 7をスライスの末尾に追加
s = append(s, 5, 6, 7)	// s == [1, 2, 3, 4, 5, 6, 7]
```

スライスの末尾に、別のスライスの要素を追加することもできる。  
`append()`に渡している第2引数が`s1...`という形式になっていることに注意。

```go
s0 := []int{1, 2, 3}
s1 := []int{4, 5, 6}
s2 := append(s0, s1...)	// s2 == [1, 2, 3, 4, 5, 6]

var b []byte
b = append(b, "あいうえお"...)
b = append(b, "かきくけこ"...)
b = append(b, "さしすせそ"...)
// b == [227 129 130 227 129 132 ...]
```

#### `append`とスライスの容量
要素数0、容量0のスライスを初期値として、`append`で要素を追加しつつ、要素数と容量を確認してみる。  
Goランタイムは、要素数の大きさによって拡張サイズを調整していることが分かる。

```go
// 要素数0,容量0のint型のスライス
s := make([]int, 0, 0)				// 要素数0, 容量0
s = append(s, 1)					// 要素数1, 容量1
s = append(s, []int{2, 3, 4}...)	// 要素数4, 容量4
s = append(s, 5)					// 要素数5, 容量8
s = append(s, 6, 7, 8, 9)			// 要素数9, 容量16
// 要素数が少なめの場合、容量の拡張は倍々で行われる

s1 := make([]int, 1024, 1024)	// 要素数1024, 容量1024
s = append(s, 0)				// 要素数1025, 容量1312
```

#### `copy`によるスライスの一括複製
組み込み関数`copy`を用いて、スライスにスライスの値を一括コピーできる。  
`copy`の使用方法には下記の2種類がある。


- 1番目の引数に指定したスライスを**コピー先**として、2番めの引数に指定したスライスの内容を、コピー先のスライスの先頭から上書きするようにコピーする。  
各々のスライスの要素数は異なっていても良い。

```go
// []T型のスライスsrcを、[]T型のスライスdstにコピーする
copy(dst, src []T) int	// copyの戻り値 == コピーが実行された要素数

s1 := []int{1, 2, 3, 4, 5}
s2 := []int{10, 11}
n := copy(s1, s2)	// n == 2, s1 == [10, 11, 3, 4, 5]
// copyの戻り値 == コピーが実行された要素数

s1 := []int{1, 2, 3, 4, 5}
s2 := []int{10, 11, 12, 13, 14, 15, 16}
n := copy(s1, s2)	// n == 5, s1 == [10, 11, 12, 13, 14]
```

- `[]byte`型のスライスを**コピー先**として、文字列型のデータをコピーする。  
この場合も`append()`と同様に、コピーする単位はバイト単位であり、文字単位ではない。

```go
// string型のスライスsrcを、[]byte型のdstにコピーする
copy(dst []byte, src string) int	// copyの戻り値 == コピーが実行された要素数

b := make([]byte, 9)
n := copy(b, "あいうえお")
fmt.Println(n, b)	// n == 9, b == []byte("あいう")
```

#### 完全スライス式
２つのパラメータを指定する簡易スライス式の他に、３つのパラメータを指定する**完全スライス式(full slice expression)**という記法がある。

完全スライス式では、整数3つを`:`で区切る。  
各々のパラメータは、`0 <= low <= high <= max <= cap(a)`という関係を満たす必要がある。  
簡易スライス式との違いは、`max`の指定によってスライスの容量を指定できるかどうか。

```go
a[low : high : max]
```

##### 配列 `var a [10]int`

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|
|**容量=10**|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|

##### 簡易スライス式 `a[2:4]`

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|
|**容量= 8**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|

##### 完全スライス式 `a[2:4:6]`

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|
|**容量= 4**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|


#### スライスを`for`文で使う
範囲節による`for`では、スライスを範囲として使用できる。

```go
s := []string{"Apple", "Banana", "Cherry"}

for i, v := range s {
	fmt.Println("[%d] => %s\n", i, v)
}
// =>
// [0] => Apple
// [1] => Banana
// [2] => Cherry
```

範囲節ではない`for`ループ内でスライスの要素数を変化させると、想定外の動作になる可能性がある。  
下記のコードでは、要素数が増え続けるため、`for`の条件式が常に真となってしまう。

```go
s := []string{"Apple", "Banana", "Cherry"}

for i := 0; i < len(s); i++ {
	fmt.Printf("[%d] => %s\n", i, s[i])
	s = append(s, "Melon")
}
// =>
// [0] => Apple
// [1] => Banana
// [2] => Cherry
// [3] => Melon
// [4] => Melon
// [5] => Melon
// ...無限ループ...
```

範囲節の`for`ループでは、ループ開始時の要素数をもとにループ回数を決定している。  
したがって、ループ内でスライスの要素数を増やしても、ループ回数に影響はない。

```go
s := []string{"Apple", "Banana", "Cherry"}

for i, v := range s {
	fmt.Printf("[%d] => %s\n", i, v)
	s = append(s, "Melon")
}
fmt.Println(s)
// =>
// [0] => Apple
// [1] => Banana
// [2] => Cherry
// ["Apple", "Banana", "Cherry", "Melon", "Melon", "Melon"]
```

#### スライスと可変長引数
`fmt.Printf`のような関数は、任意個数の引数を指定できる。  
このような関数の可変長引数を自分で定義するために、Goではスライスを使用する。

関数`fmt.Printf`は次のように定義される。  
1番目の引数にフォーマット引数を取り、2番目以降の引数は`interface{}`型のスライスである変数`a`にまとめられる。

```go
func Printf(format string, a ...interface{}) (n int, err error)
```

関数定義に可変長引数を指定することで、次のように任意個数のint型の値を引数に取る`sum`のような関数が定義できる。

```go
func sum(s ...int) int {
	n := 0
	for _, v := range s {
		n += v
	}
	return n
}

func main() {
	sum(1, 2, 3)		// 16
	sum(1, 2, 3, 4, 5)	// 15
	sum()				// 0
}
```

`s ...int`という引数の定義が、可変長引数のすべての値を`[]int`型のスライスにまとめる意味となる。  
注目すべきは、**任意個数とは0個も含まれる**点。この関数`sum`では要素数0個のスライスでもエラーとならない実装となっているため、0も含まれる。

**NOTE**  
関数における可変長引数は、**引数の末尾に1つのみ定義できる**。

```go
// エラーとなるパターン
func doSomething(a ...string, b bool)	// コンパイルエラー
func doSomething(a ...int, b float64)	// コンパイルエラー
```

#### スライスを可変長引数に代入して関数呼び出しする
前段で定義した関数`sum`に、スライスを使って可変長引数の代わりに渡すことができる。  
引数のスライスの後ろに`...`を付加すると、スライスの要素を可変長引数として展開する。

```go
s := []int{1, 2, 3}
sum(s...)	// 6
```

#### 参照型としてのスライス
そもそも**参照型**とは何か。一言で言うと、C言語などでも存在する、関数に渡すと**参照渡し**となる型のこと。  
スライス、マップ、チャネルは参照型であるため、関数の引数に渡してそれを関数内で変更すると、副作用が発生する。

##### 参照型の特性について確認する
**配列**  
まず、配列型を使った関数`pow`を考える。  
`pow`は、`[3]int`型を引数にとり、配列の各要素を2乗した値に更新したい。しかし、配列を渡した場合は参照渡しとならない。

```go
func pow(a [3]int) {
	for i, v := range a {
		a[i] = v * v
	}
	return
}

func main() {
	// 要素数3の配列
	a := [3]int{1, 2, 3}
	pow(a)
	fmt.Println(a)	// => "[1, 2, 3]"
}
```

**スライス**  
次に、スライスを使った関数`pow`を考える。  
この場合、スライスは参照型だから、期待通り、引数に渡したスライスの各要素が、2乗された値に更新される。

```go
func pow(a []int) {
	for i, v := range a {
		a[i] = v * v
	}
	return
}

func main() {
	// 要素数3のスライス
	a := []int{1, 2, 3}
	pow(a)
	fmt.Println(a)	// => "[1, 4, 9]"
}
```

##### `nil`の値を取りうるかどうか
基本型と値型の違いとして、`nil`を値として取り得るかどうかがある。

- 初期化をせずに**配列型**の変数を定義した場合、そのタイミングで`[3]int`に対応したメモリ領域が確保され、さらに要素の型の初期値によって要素が埋められる。
- 初期化をせずに**スライス型**の変数を定義した場合、スライスは`nil`が初期値となる。(いわゆるnull参照)

```go
var (
	a [3]int
	s []int
)
fmt.Println(a)	// => "[0, 0, 0]"
fmt.Println(s == nil)	// => "true"
```

##### スライス作成元の配列
配列を元にスライスを作成したとき、そのスライスは、作成元の配列を参照している。  
したがって、配列の値を変更したらスライスの値も変化したように見え、その逆も然り。

```go
a := [5]int{1, 2, 3, 4, 5}
s := a[0:2]	// s == [1, 2]
len(s)		// 2
cap(s)		// 5
a[1] = 0	// s == [1, 0]
```

では、`append()`関数などによってスライスの容量が拡張されたときはどうなるのか?  
その場合、スライスは作成元の配列とは全く異なるメモリ領域を確保し、配列の値をそこにコピーし、そのメモリ領域が新しいスライスとなる。
すなわち、下記コードのとおり、スライスが作成元のメモリ領域を参照しているとは限らない場合がある。

```go
// s0とs1が同じ配列データを共有するかは不定
s1 := append(s0, x)
```

### マップ(map)
マップは、いわゆる**連想配列**。  
関数型と参照型以外の、「任意の型のキーと任意の型の要素のペアを保持できる特殊な型」といえる。  
Goのマップを表す型は、`map[キーの型]要素の型`という書式で定義する。

```go
// 「int型のキーとstring型の値」を保持するマップ
var m map[int]string
```

マップも、スライスと同様に、関数`make`を使って生成する。  
マップは、一意に定まるキーと任意の要素の組み合わせで構成される。したがって、キーの値が重複する代入では、要素の値は上書きされる。

```go
m := make(map[int]string)

m[1] = "US"
m[81] = "UK"
m[81] = "Japan"
m[86] = "China"

fmt.Println(m)
// =>
// map[1:US 81:Japan 86:China]
```

**NOTE**  
キーを浮動小数点数にする場合は注意が必要。  
というのも、例えば`float64`型などの精度の上限によって値が丸められて同じ数値になってしまった場合、同じキーとして扱われてしまう。

#### マップのリテラル
マップにも、キーと要素のペアをまとめて生成するためのリテラル「`キーの値: 要素の値`」が有る。

```go
// マップリテラルで各要素を生成している
m := map[int]string {1: "Taro", 2: "Hanako", 3: "Jiro"}
fmt.Println(m)
// =>
// map[3:Jiro 1:Taro 2:Hanako]

// 下記のように改行も可能(末尾のカンマは必須)
m = map[int]string {
	1: "Taro",
	2: "Hanako",
	3: "Jiro",	// カンマは必須
}

// スライスをもたせることも可能
m = map[int][]int {
	1: []int{1},
	2: []int{1, 2},
	3: []int{1, 2, 3},	// カンマは必須
}
// => map[1:[1], 2:[1, 2], 3:[1, 2, 3]]

// []int{}型は下記のように書くことも可能
m = map[int][]int {
	1: {1},
	2: {1, 2},
	3: {1, 2, 3},	// カンマは必須
}

// マップを入れ子にすることも可能
m = map[int]map[float64]string {
	1: {3.14: "円周率"},
}
```

#### マップの要素を参照する
マップの要素を参照するには、配列と同じように`[キーの値]`とする。  

```go
m := map[int]{1: "A", 2: "B", 3: "C"}
s := m[1]	// "A"
s := m[9]	// ""
```

**指定したキーの値に対応する要素がないときは、型のデフォルト値が返される。**  
したがって、全く無関係のキーを誤って指定しても、それを検知しにくいことに注意すべき。  
もしくは、マップへの要素を参照した際は、その第2戻り値を確認することで、要素の有無が分かる。  

- 第2戻り値が`true`・・・要素が存在する
- 第2戻り値が`false`・・・要素が存在しない

**NOTE**  
このときの第2戻り値の名前は、特別な理由がなければ`ok`とすべき。(慣習的なもの)

```go
m := map[int]string{1: "A", 2: "B", 3: "C"}

s, ok := m[1]	// s == "A", ok == true
s, ok := m[9]	// s == "",  ok == false
_, ok := m[3]	// ok == true

if _, ok := m[1]; ok {
	// m[1]の要素が存在するときの処理
}
```

**NOTE**  
マップの要素型がスライス型の場合、要素の存在チェックを下記のように行ってはいけない。  
必ず第2戻り値を使うこと。

```go
m := map[int][]int {
	1: {1},
	2: {1, 2},
	3: {1, 2, 3},
}

s := m[1]
// **問題がある書き方**
// 下記の区別がつかない
// - m[1]に対応する要素が無くてnilの場合と、
// - m[1]に対応するスライスはあるが、その中のスライスが値を持っておらずnilの場合
if s != nil {
	// 中略
}
```

#### `for`の範囲節にマップを使う
マップも、スライスと同様に、`for`の範囲節に使用して、繰り返し処理できる。

**NOTE**  
マップを範囲節に指定した場合、キーが処理される順序は保証されないことに注意すべき。  
実行環境によっても異なる可能性があることに注意。

```go
m := map[int]string {
	1: "Apple",
	2: "Banana",
	3: "Cherry",
}

for k, v := range m {
	fmt.Printf("%d => %s\n", k, v)
}
// =>
// 1 => Apple
// 2 => Banana
// 3 => Cherry
```

#### まっぷの要素数を`len()`で取得する
マップの要素数は、スライスと同様に`len()`で取得できる。

```go
m := map[int]{1: "A", 2: "B", 3: "C"}
len(m)	// 3
m[4] = "D"
m[5] = "E"
len(m)	// 5
```

**NOTE**  
当然ながら、マップに`cap()`は使用できない。なぜなら、マップにスライスの容量に該当する概念はないため。  
内部的に確保しているメモリ領域は必ず有るだろうが、それをユーザに見せることはないため。

#### `delete()`でマップの要素を削除する
マップの要素は、組み込み関数`delete()`を使って削除できる。  
書式は「`delete(マップ, キーの値)`」。  
`delete()`で指定したキーの値に該当する要素がない場合、`delete()`は何もしない。

```go
m := map[int]{1: "A", 2: "B", 3: "C"}

delete(m, 2)	// マップmのキー2の要素を削除する

fmt.Println(m)

// =>
// map[1:A 3:C]
```


#### `make()`によるマップ生成時に要素数を指定する
組み込み関数`make()`を使ってマップを生成する場合、2番めの引数に**要素数に対応した初期スペース**を整数で指定できる。  
これが指定されると、これをヒントにGoランタイムが最適なメモリ領域を確保する。  
要素数が膨大なマップの場合はパフォーマンスに影響するが、小さい場合は指定しなくて良い。

```go
// map[int]string型のマップを初期スペース100で初期化
m := make(map[int]string, 100)
```

### チャネル(channel)
チャネルとは、**ゴルーチン間でのデータの受け渡しを行うためのGo特有のデータ構造**で、キューのようなデータ構造。  
したがって、ゴルーチンを使用する場合にのみ、チャネルを使用することになる。

ゴルーチン
: 前述の通り`go`文を用いて生成できる、Go特有の、スレッドよりも軽量な処理単位のこと。

#### チャネルの型名
チャネルの型は、「`chan データ型`」と記述する。  
型名の内側にスペースが入るため、見た目に違和感がある。


```go
// int型のチャネルch
var ch chan int
```

##### チャネルのサブタイプ
チャネルにはサブタイプがある。  
サブチャネルには双方向、受信専用、送信専用がある。

```go
// 送受信用(双方向)チャネル
var ch1 chan int

// 受信専用チャネル
var ch2 <-chan int

// 送信専用チャネル
var ch3 chan<- int
```

チャネルのサブタイプにおいて、異なるもの同士の代入が可能な場合がある。  
送受信用(双方向)チャネルの変数は、受信用または送信用の変数に代入できるが、反対向きの代入はできない。

```go
// 異なるサブタイプ同士の代入が可能
var (
	ch_in_out chan int
	ch_in <-chan int
	ch_out chan<- int
)

ch_in = ch_in_out
ch_out = ch_in_out
```

##### チャネルの生成と送受信
チャネルも、スライスやマップと同様に、組み込み関数`make`を使って生成する。  
`make`へ2番めの引数を渡すと、チャネルのバッファサイズを指定できる。指定されてない場合、チャネルのバッファサイズは0になる。

```go
// バッファサイズ0のチャネル
ch := make(chan int)

/// バッファサイズ8のチャネル
ch := make(chan int, 8)
```

チャネルは、キューの性質を備えるデータ構造。チャネルのバッファとは、このキューを格納する領域で、バッファサイズとはこのキューのサイズを意味する。  
キューはFIFO(先入れ先出し)であり、キューに挿入された順番にデータを取得できる。Goにおけるチャネルも、FIFOの性質が有る。

{{<figure src="go-channel.svg" alt="Goのチャネル" align="aligncenter" width="500" caption="Goのチャネル">}}

チャネルが保持するデータに対する操作は、「送信」か「受信」の2パターンのみ。  
送受信共に、演算子`<-`を使用する。

送信
: チャネルに対して、データを送る。

受信
: 他のゴルーチンがチャネルへデータを送信するのを待つ。そして、チャネルに入ったデータを受け取る。

```go
// バッファサイズ10のチャネル
ch := make(chan int, 10)

// チャネルchに整数5を送信
ch <- 5
// チャネルから整数値を受信
i := <-ch
```

`ch <- 5`はチャネルに整数5を送信する処理で、`i := <-ch`はチャネルからデータを受信する処理。

##### チャネルとゴルーチン
チャネルは、複数のゴルーチン間で安全にデータを共有するための仕組み。  
これを実際に使った例を下記コードに示す。(ただしこれは不完全)

```go
func main() {
	ch := make(chan int)
	// チャネルから受信から内容を出力
	fmt.Prinln(<-ch)
}
```

上記を実行するとランタイムエラー`fatal error: ass goroutines are asleep - deadloak!`が発生する。  
すなわち、「上記コードの`ch`にデータを送信するゴルーチンが動いておらず、`ch`が永遠に待ち続けてしまう」ことがデッドロックとして検知される。

下記コードでは、関数`main`からゴルーチンを生成して、チャネルを共有しつつ処理を行う。  
`go`の使用方法は「`go`文による並行処理」を参照。

```go
package main

import (
	"fmt"
)

func reveiver(ch <-chan int) {
	for {
		// チャネルからデータを受信してiに代入する
		i := <-ch
		fmt.Println(i)
	}
}
func main() {
	// バッファサイズ0のチャネルを作成する
	ch := make(chan int)

	// チャネルch受信して表示するゴルーチンを生成する
	go reveiver(ch)

	i := 0
	for i < 1000 {
		// チャネルに整数値iを送る
		ch <- i
		i++
	}
}
// =>
// 0
// 1
// 2
// 3
// 4
// 5
// ...
```

上記コードの処理を説明する。

1. 関数`main`は、`go`文でゴルーチンを生成し、関数`receiver`への引数を使ってチャネル`ch`を共有する。
1. 関数`main`側のゴルーチン(`main`関数自体)では、0始まりの整数値をインクリメントさせつつチャネルに送信する。
1. 関数`receiver`側のゴルーチンは、データを受信して、それを標準出力に出力し続ける。  
   関数定義の引数の型指定で、引数で受け取るチャネルの型を`<-chan int`型に限定する。

{{<mermaid align="center">}}
sequenceDiagram;
	participant main as main-goroutine
	participant ch as channel
	participant receiver as receiver-goroutine

	activate main
	main ->> ch: ch := make(chan int)
	main -x+ receiver: go receiver(ch)
	main ->> main: i := 0
	loop 無限ループ
		main ->> ch: ch <- i
		main ->> main: i++
	end

	loop 無限ループ
		receiver ->> ch: i := <-ch
		receiver ->> receiver: Prinln(i)
    end

	deactivate receiver
	deactivate main
{{</mermaid>}}

バッファサイズを設定したチャネルを使用した場合、ゴルーチンが停止するかどうかはチャネルのバッファサイズによる。  
下記のコードで分かるとおり、バッファサイズに収まる限りデータは正常に格納されてゴルーチンは停止しない。  
しかし、バッファに空きがないチャネルへの送信が発生した場合、デッドロック発生する。

```go
ch := make(chan rune, 3)

c <- 'a'	// 'a'
c <- 'b'	// 'a', 'b'
c <- 'c'	// 'a', 'b', 'c'
c <- 'd'	// サイズ超過によりデッドロック発生と判断される
```

ゴルーチンがチャネル操作によって停止する条件は下記の2通り。

- バッファサイズが0またはバッファ内が空のチャネルから**受信**する
- バッファサイズが0またはバッファ内が満杯のチャネルへ**送信**する

##### チャネルにおける`len`と`cap`
###### `len`関数
チャネルに対する組み込み関数`len`は、**チャネルのバッファ内に貯められているデータの個数**を返す。

```go
ch := make(chan string, 3)

ch <- "Apple"
len(ch)	// == 1
ch <- "Banana"
ch <- "Cherry"
len(ch)	// == 3
```

`len`チャネルのバッファ内の状態を動的に取得できるとしても、下記のコードはアトミックでないため、記述してはいけない。
すなわち、`if len(ch) > 0`が成り立って`if`節の中に入ったとしても、その直後に他のゴルーチンがチャネル`ch`からデータを受信してしまうと、`i := ch`の時点では`len(ch) > 0`が成り立たなくなっている可能性がある。

```go
if len(ch) > 0 {
	i := ch	//	この瞬間len(ch) > 0 は保証されない
}
```

###### `cap`関数
チャネルに対する組み込み関数`cap`は、チャネルのバッファサイズ。  
ただし、一度生成したチャネルのバッファサイズは変動しないため、取得したい場面は限られる。

```go
ch := make(chan string)
cap(ch)	// == 0

ch := make(chan string, 3)
cap(ch)	// == 3
```

##### `close`関数でチャネルをクローズする
チャネルは**クローズ(closed**という状態を持っている。`make`で生成したチャネルはオープンされた状態から始まるが、これを明示的にクローズ状態に変更するには組み込み関数`close`を使用する。

指定したチャネルをクローズする書式は「`close(チャネル)`」。

- **NOTE**  
  - クローズされたチャネルに対してデータの**送信**を行うと、ランタイムパニックが発生する。
  - クローズされたチャネルに対してデータの**受信**を行うと、バッファにデータがまだ溜まっていたら問題なく受信でき、既にチャネルが空ならチャネルの初期値を受信できる。

チャネルのクローズ判定は、第2戻り値によって行う。  

- 第2戻り値の意味
  - `false`:チャネルのバッファ内が空 and クローズされた状態
  - `true`:チャネルのバッファ内にデータがある or クローズされていない状態

```go
ch := make(chan int)
close(ch)
i, ok := <-ch	// i == 0, ok ==false


ch := make(chan int, 3)

ch <- 1
ch <- 2
ch <- 3

close(ch)

var (
	i int
	ok bool
)
i, ok = <-ch	// i == 1, ok == true
i, ok = <-ch	// i == 2, ok == true
i, ok = <-ch	// i == 3, ok == true
i, ok = <-ch	// i == 0, ok == false
```

##### ゴルーチンと`close`の実例
ゴルーチンを使用する際に、`close`を使用すると下記コードのような挙動となる。仕組みは上述のとおり。

```go
package main

import (
	"fmt"
	"time"
)


// receiveは、チャネルchから整数値を受信して表示する
func receive(name string, ch <- chan int) {
	for {	// 無限ループ
		i, ok := <-ch
		if ok == false {
			// 受信できなくなったため終了
			break
		}
		fmt.Println(name, i)
	}
}

func main() {
	ch := make(chan int, 20)

	// ゴルーチンを3つ生成
	go receive("1st goroutine", ch)
	go receive("2nd goroutine", ch)
	go receive("3rd goroutine", ch)

	// チャネルに整数値0~99を送信する
	for i := 0; i < 100; i++ {
		ch <- i
	}

	// チャネルをクローズする
	close(ch)

	// ゴルーチンの完了を3秒待つ(簡略的な処理)
	time.Sleep(3 * time.Second)
}

// =>
// 3rd goroutine 0
// 3rd goroutine 3
// 3rd goroutine 4
// 3rd goroutine 5
// 3rd goroutine 6
// 3rd goroutine 7
// 3rd goroutine 8
// ...中略...
// 3rd goroutine 93
// 3rd goroutine 94
// 3rd goroutine 95
// 1st goroutine 79
// 1st goroutine 97
// 1st goroutine 98
// 1st goroutine 99
// 3rd goroutine 96
// 2nd goroutine 88
```

##### チャネルを`for`と組み合わせる
範囲節の`for`において、チャネルを使用できる。下記コードのようにすると、チャネルからデータを延々と受信し続けることができる。  
`a := range ch`の形式で、チャネルから受信したデータが変数`a`に代入される。  
しかし、この方法には、チャネルがクローズされたかどうかを検出するタイミングが得られないという欠点がある。

```go
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3

for i := range ch {
	fmt.Println(i)
}

// =>
// 1
// 2
// 3
// fatal error: all goroutines are asleep - deadlock!
// 以下略
```

##### 制御構文`select`で複数のチャネルをコントロールする
下記のように、チャネル`ch1`、`ch2`と、チャネルが内包するデータ`e1`、`e2`について考える。  
チャネル`ch1`からデータが受信できない場合、この処理の流れを実行しているゴルーチン(`main`)は処理を停止する。
したがって、チャネル`ch2`の受信処理には、いつまで立ってもたどり着けない可能性がある。

```go
e1 := <-ch1	// 受信街でゴルーチンが停止
e2 := <-ch2
```

上記コードのように、1つの処理の流れの中で複数のチャネルを処理しようとする場合、チャネルの状態に応じてゴルーチンが停止する問題をどうにかして回避する必要がある。  
そこで、`select`文を使用する。これを使うと、複数チャネルの送受信処理を、ゴルーチンを停止させずに扱える。

```go
select {
case e1 := <-ch1
	// ch1からの受信が成功した場合の処理
case e2 := <-ch2
	// ch2からの受信が成功した場合の処理
default:
	// 上記条件のいずれも成立しなかった場合の処理
}
```

`select`文の全ての`case`節は、必ずチャネルへの処理を記述する必要がある。チャネルへの処理には、下記の種類がある。

```go
// ch1から受信
case e1 := <-ch1:

// ch2から受信(2変数で)
case e2, ok := <-ch2:

// ch3へe3を送信
case ch3 <- e3:

// ch5から受信したデータをch4へ送信
case ch4 <- (<-5):
```

`select`文は、`switch`文とは異なり、各`case`節を**ランダム**に選択して処理する。
(ただし`default`はすべての`case`が成立しない場合にのみ遷移する。)  
これは、最初の`case`ばかり処理されてそれ以降の`case`が処理されない問題を回避するための仕様。  
下記コードを実際に実行してみると、実行のたびにランダムに`case`が選択されている事が分かる。

```go
ch1 := make(chan int, 1)
ch2 := make(chan int, 1)
ch3 := make(chan int, 1)

ch1 <- 1
ch2 <- 2

// 複数のcaseが成立する場合はランダムに選択される
select {
case <-ch1:
	fmt.Println("ch1から受信")
case <-ch2:
	fmt.Println("ch2から受信")
case ch3 <- 3:
	fmt.Println("3をch3へ送信")
default:
	fmt.Println("ここへは到達しない")
}

// =>
// $ go run test.go
// ch2から受信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// ch2から受信
// $ go run test.go
// ch2から受信
// $ go run test.go
// ch1から受信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// 3をch3へ送信
```

複数のチャネルと複数のゴルーチンに`select`文を組み合わせたプログラムを下記に示す。  
このプログラムは、下記を実行している。

1. 整数値1～99をch1に送信する
1. ch1からデータを受信し、それを2倍したらch2に送信する
1. ch2からデータを受信し、それを-1したらch3に送信する
1. ch3からデータを受信し、それを表示する

```go
ch1 := make(chan int)
ch2 := make(chan int)
ch3 := make(chan int)

// ch1から受信した整数を2倍してch2へ送信する
go func() {
	for {
		i := <-ch1
		ch2 <- (i * 2)
	}
}()

// ch2から受信した整数を-1してch3へ送信する
go func() {
	for {
		i := <-ch2
		ch3 <- (i - 1)
	}
}()

n := 1
LOOP:
for {
	select {
	// 整数をインクリメントさせつつch1へ送信する
	case ch1 <- n:
		n++
	// ch3から受信した値を表示する
	case i := <-ch3:
		fmt.Println("received", i)
	// 上記caseの送受信が失敗したら実行
	default:
		// nが100以上になったらループを抜ける
		if n > 100 {
			break LOOP
		}
	}
}

// =>
// received 1
// received 3
// received 5
// received 7
// received 9
// received 11
// received 13
// received 15
// ...以下略...
```
