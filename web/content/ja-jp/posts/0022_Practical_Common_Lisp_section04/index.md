---
title: "書籍 実践 Common Lisp 第4章 シンタックスとセマンティクス"
date:    2019-03-07T00:00:00+09:00
lastmod: 2019-03-07T00:00:00+09:00
draft: false
toc: true
tags: ["lisp"]
categories: ["Notes"]
authors:
- otaon
---

## 4.1 なんでこんなに括弧があるの？
括弧がたくさんあるのは、M式よりもS式の方が初期のLisperに好まれたからである。

## 4.2 ブラックボックスをばらして中を見ると
Lispのシンタックスとセマンティクスがどのように定義されるのかを見る。

たいていの言語処理系は、ブラックボックスの中で、プログラムのテキストから動作やオブジェクトコードへと変換する作業を、それぞれ一部分ずつ担うサブシステムに分割されている。  
よくあるのは、処理系を3つのフェーズに分割し、それぞれの出力結果を次のフェーズに流し込む方式である。

**たいていの言語処理系の処理の流れ**  

```
文字列
 -> [字句解析器] 文字列を字句に分解する
 -> 字句
 -> [パーサ] 言語の文法に基づいてプログラムに置ける式を表す木を作る
 -> 抽象構文木(AST: abstract syntax tree)
 -> [評価器] インタプリタとして直接実行したり、機械語のような他の言語へとコンパイルする
```

Common Lispの場合、この処理のフェーズ分割が少し異なる。

```
文字列
 -> [読み取り器(reader)] 文字列をS式と呼ばれるLispオブジェクトに変換する
 -> Lispオブジェクト(S式)
 -> [評価器(evaluator)] セマンティクスを評価して、インタプリタとして直接実行したり、機械語のような他の言語へとコンパイルする
```

## 4.3 S式
### リストとアトム
S式の基本構成要素は、 **リスト** と **アトム** である。

- リスト：括弧で括られており、単数、または複数のS式を要素に持つ
- アトム：リスト以外のS式

LispのBNF(バッカス・ナウア記法)を参照すると、このあたりの詳細が分かる。

- [BNF Index of LISP](http://cui.unige.ch/isi/bnf/LISP/BNFindex.html)
- [arrdem/sad sad/test/lisp.bnf](https://github.com/arrdem/sad/blob/master/test/lisp.bnf)

### シンボル
先述の`format`や`*bd*`といった名前は、**シンボル**と呼ばれるオブジェクトによって表されている。  
読み取り器は、指定された名前が変数名なのか関数名なのかは一切知らない。  
名前には、下記以外、ほとんどの文字を使用することができる。

- 数字(シンボル名の全てが数字でなければ使用可能)
- 開き括弧 `(`
- 閉じ括弧 `)`
- ダブルクォート `"`
- シングルクォート `'`
- バッククォート `\``
- カンマ `,`
- コロン `:`
- セミコロン `;`
- バックスラッシュ `\`
- 縦線 `|`

読み取り器が名前をシンボルオブジェクトに変換する方法について、下記の2点を理解すべきである。

1. 名前に出てくる大文字と小文字を読み取り器が扱う方法
2. 同一の名前をいつも同一のシンボルとして読むのを読み取り器が保証する方法

#### 1. 名前に出てくる大文字と小文字を読み取り器が扱う方法
読み取り器は、名前を読む時に、エスケープされていない文字を全て大文字に変換する。  
つまり、読み取り器は、`foo`も`FOO`も`Foo`も、全て同じシンボルとして読む。  
そして、`\f\o\o`や`|foo|`は、エスケープされているため、`foo`というシンボルとして読まれる。  
現代の標準的なLispでは、コードを全て小文字で書き、読み取り機で名前を大文字に変換する。

#### 2. 同一の名前をいつも同一のシンボルとして読むのを読み取り器が保証する方法
同一の名前をいつも同一のシンボルとして読むのを読み取り器が保証するために、読み取り器はシンボルを **インターン(intern)** する。  
このインターンにより、S式のどこに同じ名前が現れてもそれを表すために同一のオブジェクトが使用されることになる。

**インターンの仕組み**  
1. 読み取り器は、名前を読み込んで大文字に変換したら、その名前のシンボルが **パッケージ(package)** と呼ばれる表に存在しているかどうか調べる。
2. シンボルが表に存在していたら、そのシンボルを返す。
3. 見つからなかったら、新しいシンボルを作成して表に追加し、それを返す。

## 4.4 LispフォームとしてのS式
ここからは、評価器について説明する。

読み取り器がテキストの集まりをS式に変換したら、そのS式はLispコードとして評価できる。
しかしながら、S式の全てがLispコードとして評価できるわけではない。
すなわち、S式がLispコードのセマンティクスを満たすかどうかを評価する必要がある。

評価器は、S式がLispコードとして評価できるかを決める評価規則を持つ。  
といっても、この評価規則は非常にシンプルである。
すなわち、「正規のLispフォームとは、任意のアトム、または、リストの先頭要素がシンボルとなっているリスト」という規則である。

アトムには2種類ある。シンボルと、シンボル以外である。

- シンボル： 変数の名前とみなされ、その変数の現在の値として評価される(定数もこちら)
- シンボル以外： シンボル意外である以外の **自己評価型(self-evaluating)** のオブジェクト(数値、文字列)

**NOTE**  
自己評価型とは、評価機構に渡したら自分自身を評価値として返すという意味である。

シンボルも、変数名にシンボル自身を代入すれば自己評価型になる。  
例えば、標準で用意されている真偽値である`t`と`nil`がそれにあたる。  
他にも、 **キーワードシンボル** も自己評価型のシンボルである。
キーワードシンボルとは、シンボル名の先頭に`:`がついたものである。
読み取り器は、`:`から始まる名前をインターンするとき、そのシンボルを値として持つ定数を自動的に定義する。

----

正規のリストフォームは、必ず先頭要素がシンボルである。  
そして、リストが評価される方法には、このシンボルの種類によって3種類に分けられる。

- シンボルが関数の名前、または、未定義の名前：関数呼び出し
- シンボルが特殊オペレータの名前：特殊オペレータ
- シンボルがマクロの名前：マクロ

## 4.5 関数呼び出し
関数呼び出しのルールは、「リストの先頭以外の要素を評価し、その結果の値を関数に渡す」である。  
したがって、関数呼び出しフォームのシンタックスにおいては、「リストの先頭以外の要素は **well-formed** である必要がある」というルールも自明的に存在する。

**関数呼び出しのシンタックス**  

```lisp
(function-name arguments*)
```

## 4.6 特殊オペレータ
関数で定義できないような操作は、特殊オペレータによって実現されている。  
例えば、`if`のように、先頭以外の要素について、片方を評価しない場合があるような操作は関数では定義できない。  
なぜなら、関数では、先頭以外の要素について最初に全て評価しきってしまうからである。

**例：`if`のシンタックス**

```lisp
(if test-form
    then-form
    [else-form])
```

また、他のフォームが評価される環境を操作するような特殊オペレータも存在する。
つまり、`let`などがそれにあたる。

## 4.7 マクロ
マクロとは、端的に言えば、シンタックスを拡張する手段をユーザに提供する機能である。  
マクロは、S式を引数として受け取り、そのS式(マクロフォーム)の代わりに評価される別のS式(Lispフォーム)を返す関数である。

マクロフォームの評価は2段階である。  

1. マクロフォームの要素がそのまま(=通常の手順で評価器に評価される前に)マクロ関数に渡される
2. マクロ関数が返すLispフォーム(=マクロ展開されたS式)が、通常の評価手順で評価される

したがって、例えば`compile-file`コマンドでコードをコンパイルする時は、下記の手順でマクロが展開される。

1. ファイル中の全てのマクロフォームが、関数と特殊フォームだけになるまで再帰的にマクロ展開される
2. マクロのない状態のコードが、`load`コマンドで読み込める形式の`fasl`ファイルへとコンパイルされる
3. コンパイルされたコードは、ロードされるまで実行されない

ここで、重要な事が2点分かる。

- マクロ展開されるのはコンパイル時なので、ファイルのロード時や、ファイル中に定義された関数の呼び出し時にマクロ展開のコストはかからない
- 評価器は、S式をマクロ関数に渡す前に評価しないため、マクロフォーム内のS式は、それぞれのマクロが解釈できる形で自由に記述可能である

## 4.8 真偽、等しさ
### 真偽
Lispの真偽は非常にシンプルである。  
すなわち、`nil`が偽で、それ以外は全て真である。  
ただし、明確に真偽値の真であることが分かるように、`t`が特別に用意されている。

`nil`と`'nil`と`()`と`'()`は、全て同じものとして評価されるように設計されているため、これらは全て偽である。  
同様に、`t`と`'t`も、全て同じものとして評価されるように設計されているためこれらは全て真である。  

**NOTE**  
上記のシンボルのうち、クォート有りのものは、特殊オペレータ`quote`によって、与えられたシンボルそのものとして評価され、クォート無しのものは、値としてシンボル`nil`やシンボル`t`を持つ定数への参照として評価される。  
これにより、実質的には`nil`が偽でそれ以外が真である、といえる。

### 等しさ(同一性、同値性)
#### `eq`
`eq`は「オブジェクト同一性」を比較する。  
すなわち、2つのオブジェクトが同一であるとき、それらは`eq`である、と換言できる。

ただし、同じ値を持つ2つの数値や2つの文字を同一であるとするかは **処理系依存** である。
そのため、数値や文字に対して同一性を比較したい時に`eq`を使ってはならない。

#### `eql`
数値や文字の「値が等しい」、つまり、同値であることを比較したい場合は、`eql`を使用する。  
ただし、`eql`は、同じ数値や文字の値を表している **同じクラス** のオブジェクトを等しいとみなす。
したがって、`(eql 1 1)`は真であるが、`(eql 1 1.0)`はオブジェクトのクラスが違うため偽である。

#### `equal`
`equal`は、同じ構造と内容を持つリストを再帰的に等しいとみなす。  
また、同じ文字で構成された文字列も`equal`では等しいと判断される。  
さらに、一次元配列やパス名といったデータ型に対しても、`equal`は`eql`よりもゆるい判断をする。  
それ以外のデータ型については、`eql`を用いたときと同じ判断をする。

#### `equalp`
`equalp`は、`equal`よりも判断基準がさらに緩く、文字列の比較において、大文字小文字の区別をしない。  
さらに、数値に対しては、数学的に同じ値であれば等しいと判断する。  
したがって、`(equalp 1 1.0)`は真となる。  
また、`equalp`で真となる要素を持つリスト同士も、`equalp`で真となる。  
同様に、`equalp`で真となる要素を持つ配列同士も、`equalp`で真となる。  
その他の大抵のデータ型については、`eql`を用いたときと同じ判断をする。

## 4.9 Lispコードの書式付け
### インデント
殊、Lispにおいては、コードのインデントには気を遣うべきである。  
しかし幸いなことに、SLIMEやSLIMVのようなエディタの機能を使用すれば、自動的にインデントを適切に修正してくれる。  
重要なのは、どのようなインデントが一般的であるのかを覚えておくことである。

### コメント
Lispのコメントの流儀として一般的なものを下記に示す。

```lisp
;;;; aaaaaa セミコロン4つ・・・ファイルヘッダのコメント

;;; bbbbbbb セミコロン3つ・・・以降のコードセクションに対する段落コメント
;;; bbbbbbb

(defun (foo)
  (let ((x 1))
    ;; cccc セミコロン2つ・・・以降のコードに対するコメント
    (some-function-call)
    (another-function-call x) ; dddd セミコロン1つ・・・この行のみに対するコメント
    (another)))
```

