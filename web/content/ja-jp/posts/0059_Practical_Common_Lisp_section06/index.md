---
title: "書籍 実践 Common Lisp 第6章 変数"
date:    2019-05-25T00:00:00+09:00
lastmod: 2019-05-25T00:00:00+09:00
draft: false
toc: true
tags: ["lisp", "実践-Common-Lisp"]
categories: ["実践-Common-Lisp"]
authors:
- otaon
---

## 6.1 変数の基礎
- Common Lispは、**動的型付け(dynamically typed)**であり、型エラーは動的に検出される。  
- また、**強い型付け(strongly typed)**であり、全ての型エラーを検出できる。  
  言い換えると、あるオブジェクトを別のクラスのインスタンスとして扱う方法は存在しない。  
  ただし、コンパイラのオプションによって、ある変数が特定の型であると宣言しておいて実行時のチェックをオフにできる。
- Common Lispにおける全ての値は、少なくとも概念上は**オブジェクトへの参照**。
  - プリミティブなオブジェクト(巨大ではない数値や文字列)はイミュータブルのため、メモリ上に直接展開される。

特殊オペレータ`let`を使うことで、何らかの値を変数に束縛できる。  
下記コードのとおり、`let`では、より内部の束縛が優先される。

```lisp
(let ((x "outer"))
  (princ x)
  (let ((x "inner"))
    (princ x)))
; =>
; outer
; inner
```

特殊オペレータ`let*`では、初期化フォームでの各変数が参照する初期値のフォームで、変数リストの中で前に出てきたものを使うことができる。

```lisp
(let* ((x 10) (y (* x 2)))
  (princ y))
; => 20
```

## 6.2 レキシカル変数とクロージャ
Common Lispにおける束縛フォームが導入する変数は、すべてデフォルトでは**レキシカルなスコープ**を持つ。  
レキシカルなスコープを持つ変数は、束縛フォームの内部にあるコードだけが参照できる。

ただし、Common Lispはクロージャをサポートしているため、予め束縛した値は、関数オブジェクトを持ち運んだ後も生き残っている。
したがって、下記コードが実現できる。

```lisp
(let ((count 0))
  #'(lambda ()
      (setf count (1+ count))))
```

上記のように、関数定義の外側にある変数を内部に束縛した関数を**クロージャ**という。  
クロージャを生成したときに束縛した変数は、そのクロージャ自体が存在して変数を参照し続ける限り、存在し続ける。

```lisp
(defparameter *fn*
  (let ((count 0))
    #'(lambda ()
        (incf count))))

(funcall *fn*) ; => 1
(funcall *fn*) ; => 2
(funcall *fn*) ; => 3
```

## 6.3 ダイナミック変数(=スペシャル変数)
レキシカルなスコープを持つ束縛は、その名前が意味を持つ範囲が字句によって決まる。  
これに対して、ダイナミック変数は、実際に束縛が評価されたらそれをずっと保持し続ける。いわゆるグローバル変数として使われる。

**書式**

`defvar`
: 変数が未定義だった場合のみ初期値を代入する。  
  値を指定しなければ、初期値のない**未束縛な**グローバル変数定義となる。

`defparameter`
: 評価されるたびに常に初期値を代入する。

```lisp
(defvar *変数* "変数の説明")
(defparameter *変数* "変数の説明")
```

**使用例**

```lisp
(defvar *count* 0 "製造済みの部品数")
(defparameter *gap-tolerance* 0.001 "部品間の隙間の許容幅")
```

`defvar`と`defparameter`の使い分けについては下記の通りにすべき。  

- 変数定義する時、その変数を使うソースコードを変更したとしても維持しておきたいデータを含むものには`defvar`を使うべき。  
  例: プログラム全体で共有したい、何らかの個数など。
- コード全体に影響する値を定義したい場合は`defparameter`を使うべき。  
  例: プログラム全体の挙動を制御するためのフラグなど。

`defvar`で定義した`*count*`を使って、下記のように個数をカウントするクロージャを容易に定義できる。

```lisp
(defparameter *count* 0)
(defun increment-count () (incf *count*))

(increment-count) ; => 1
(increment-count) ; => 2
(increment-count) ; => 3
```

ダイナミック変数を`let`で束縛すると、`let`の外側では束縛前の値を参照し、`let`の内側では束縛中の値を参照する。  
これを利用すると、標準出力ストリームを一時的に別のものに束縛し、何らかの処理が完了したら元のストリームに自動的に戻すことができる。

```lisp
; *standard-output* = 自動的に定義されている
(let ((*standard-output* *別のストリーム*))
  (処理))
```

束縛を参照できる期間を**エクステント(extent)**と呼ぶ。  
束縛を参照できる字句的な範囲を**スコープ(scope)**と呼ぶ。  
したがって、エクステントは時間を、スコープは場所を指す。

レキシカル変数はのスコープはレキシカルに決まり、エクステントは**無限(indefinite)**、つまり期限はなく、必要とされている期間だけ参照できる。
これと対照的に、ダイナミック変数はスコープは無限、つまりどこからでも参照でき、エクステントは**ダイナミック**[^1]。  

[^1]: ダイナミック変数のエクステントは束縛フォーム(例:`defvar`)を実行している間のみであり、束縛フォームの実行が終了すると値は消える、という意味。

下記コードは、下記項目の注意点を示唆している。

- **呼び出したコードによって、自分の知らないうちにダイナミック変数の束縛の値を変更してしまうかもしれない(予期せぬ副作用)**
  - **ダーティな**関数を呼び出すとき、その副作用に注意する。
- **コードが確立したスタック上の束縛を自分で隠してしまうかもしれない(予期せぬシャドーイング)**
  - 束縛する変数が既に束縛の外でダイナミックに定義されており、かつ、関数内で使用している、ということが無いことを注意する。

```lisp
(defparameter *x* 10)

(defun foo ()
  (format t "Before assignment X: ~d~%" *x*)
  (incf *x*)
  (format t "After assignment  X: ~d~%" *x*))

(defun bar ()
  (foo)
  (let ((*x* 20))
    (foo))
  (foo))

(bar)
; =>
;; ダイナミック変数を用いた関数を呼び出した
; Before assignment X: 11
; After assignment  X: 12

;; letによってダイナミック変数がシャドーイングされたことを知っている必要がある
; Before assignment X: 20
; After assignment  X: 21

;; (foo)の内部でダイナミック変数を使用していることを知っている必要がある
; Before assignment X: 12
; After assignment  X: 13  
```

## 6.4 定数

定数は下記の通り定義する。

```lisp
(defconstant +名前+ 初期値 "説明")

(defconstant +pi+ 3.14 "円周率")
```

**注意**  
`defconstant`で定義された定数をさらに再定義したとき、言語仕様では許可しているものの、どんなことが起こるのかは定義されていない。  
変更する可能性が少しでもある場合は`defparameter`を使用すべき。

## 6.5 代入
代入には`setf`を用いる。`setq`もあるが、最近では全ての代入に`setf`を用いる事が多い。  

```lisp
(setf 代入対象 値)

(setf x 100)
```

束縛に新しい値を代入しても、他の束縛には影響しないことに注意。すなわち、代入前に束縛に保存されていた値にも影響しない。

```lisp
(defun foo (x)
  (setf 10))

(let ((y 20))
  (foo y)
  (print y))
; => 20
```

`setf`は複数の代入を連続して実行できる。

```lisp
(setf x 1 y 2)

; 上記と下記は同じ
(setf x 1)
(setf y 2)
```

`setf`は新しく代入した値を返す。  
したがって、`setf`を入れ子にすれば、複数の変数に同一の値を代入することも簡単にできる。  
cf. C言語における`a = b = rand();`

```lisp
(setf x (setf y (random 10)))
```

## 6.6 ジェネリックな代入
どんなデータ構造への代入にも`setf`が使える。


|代入対象|&nbsp;`Java`, `C`, `C++`|&nbsp;`Perl`|&nbsp;`Python`|
|--------|------------------|------|--------|
|変数                       |&nbsp;`x = 10;`      |&nbsp;`$x = 10;`           |&nbsp;`x = 10`|
|配列要素                   |&nbsp;`a[0] = 10;`   |&nbsp;`$a[0] = 10;`        |&nbsp;`a[0] = 10`|
|ハッシュテーブルのエントリ |&nbsp;`x = 10;`      |&nbsp;`$hash{'key'} = 10;` |&nbsp;`hash['key'] = 10`|
|オブジェクトのフィールド   |&nbsp;`o.field = 10;`|&nbsp;`$o->{'field'} = 10;`|&nbsp;`o.field = 10`|

Common Lispの場合は、下記の通り`setf`によって代入できる。

|データのタイプ|代入方法|
|--------------|--------|
|単純な値|&nbsp;`(setf x 10)`|
|配列|&nbsp;`(setf (aref a 0) 10)`|
|ハッシュテーブル|&nbsp;`(setf (gethash 'key hash) 10)`|
|`field`という名前のスロット|&nbsp;`(setf (field o) 10)`|

## 6.7 場所の値を変更する別の方法
**モディファイマクロ**によっても、値を変更できる。  
モディファイマクロとは、`setf`上に定義されたマクロで、ある場所の現在の値に基づいた新しい値を代入するもの。  
**一般的に**、モディファイマクロでは、引数および場所を表すフォームの一部分が、正確に一度だけ左から右に評価されることが保証されている。

```lisp
(defparameter *x* 100)
(incf *x*) ; => 101
(decf *x*) ; => 100
(incf *x* 10) ; => 110
```

他にも、`push`、`pop`、`pushnew`、`rotatef`などのモディファイマクロがある。

```lisp
; aとbをswapする
(ratatef a b)

; 上記と等価
(let ((tmp a))
  (setf a b b tmp)
  nil) ; setfによって戻り値がaであるのを回避するため
```

```lisp
; 残りの引数の値を一つずつ左にずらす
; 最初の引数の値だったものを戻り値とする
(shiftf a b 10)

; 上記と等価
(let ((tmp a))
  (setf a b b 10)
  tmp)
```