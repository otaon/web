---
title: "書籍 実践 Common Lisp 第10章 数、文字、そして文字列"
date:    2019-05-31T00:00:00+09:00
lastmod: 2019-05-31T00:00:00+09:00
draft: false
toc: true
tags: ["lisp", "実践-Common-Lisp"]
categories: ["実践-Common-Lisp"]
authors:
- otaon
---

## この章について
この章では、Lispの**スカラー**のデータ型である数、文字、文字列(の一部の仕様)について説明する。

## 10.1 数
Common Lispでは、分数、浮動小数点数、複素数など、数学に必要な基本的なデータ型を標準でサポートしている。

## 10.2 数値リテラル
ある方の数値には、テキストでの表現がいくつも存在する。その全てがLispの読み取り器で同じオブジェクトの表現に変換される。  
例えば整数の`10`は、`10`や`20/2`や`#xA`の様に記述できるが、これらを読み取り器では全て同じオブジェクトに変換する。  
さらに、数が書き戻される(=REPLで印字される)ときは、標準的な文字列からなるシンタックス(= **canonical textual syntax**)で印字される。

```lisp
CL-USER> 10
10
CL-USER> 20/2
10
CL-USER> #xa
10
```

### 整数
整数値のシンタックスは、正規表現で`[+-]?[0-9]+`となる。

```lisp
; 整数の例
123  ; 123
+123 ; 123
-123 ; -213
123. ; 123
```

### 分数
分数は、正規表現で`[+-]?[0-9]+/[1-9][0-9]*\.*`となる。  

```lisp
; 分数の例
2/3  ; 2/3
-2/3 ; -2/3
4/6  ; 2/3
6/3  ; 2
```

### 有理数
有理数は全て、読み込まれる時に**正規化**される。すなわち約分される。  

有理数は基数を`10`以外にすることも可能。

- `#B`か`#b`で始まる場合、有理数リテラルは各桁が`[01]`のみの2進数として読み込まれる。
- `#O`か`#o`で始まる場合、有理数リテラルは各桁が`[0-7]`の8進数として読み込まれる。
- `#X`か`#x`で始まる場合、有理数リテラルは各桁が`[0-9A-Fa-f]`の8進数として読み込まれる。
- `#nR`(`n`は10進の数)始まる場合、有理数リテラルは各桁が`[0-9A-Za-z]`のn進数として読み込まれる。

指定した基数は、分子と分母の両方を同時に規定する。

```lisp
; 有理数
#b10101     ; 21
#b1010/1011 ; 10/11
#o777       ; 511
#xDADA      ; 56026
#36rABCDEFG ; 22453731916
```

### 浮動小数点数
有理数とは違い、小数のシンタックスは読み込まれる数値の実際の型に影響する。  
Common Lispには小数のサブタイプが4種類あり、サブタイプごとに異なるビット列で数を表している。

- `short`
- `single`
- `double`
- `long`

これらのサブタイプごとに表せる数の範囲と精度が異なる。  
使うビットが多いほど広範囲かつ高精度に表現できる。

浮動小数点数は、正規表現で`[+-]?[0-9]+\.[0-9]+`となる。  
また、指数表現も可能。(`[+-]?[0-9]+\.?[0-9]*[Ee][+-][0-9]+`)  
指数部のマーカーには上記の`[Ee]`以外にも`[Ss]`(short)、`[Ff]`(single)、`[Dd]`(double)、`[Ll]`(long)が使用できる。  
これらのマーカーを使うと、どの精度を用いるのかを指定できる。  
`[Ee]`は標準(デフォルトでは`short`)の精度を意味する。

浮動小数点数に使われる数字は、常に**10進数**として扱われる。

```lisp
; 浮動小数点数の例
1.0      ; 1.0
1e0      ; 1.0
1d0      ; 1.0d0
123.0    ; 123.0
123e0    ; 123.0
0.123    ; 0.123
.123     ; 0.123
123e-3   ; 0.123
123E-3   ; 0.123
0.123e20 ; 1.23e+19
123d23   ; 1.23d+25
```

### 複素数
複素数は、正規表現`#[Cc](有理数 有理数)`または`#[Cc](浮動小数点数 浮動小数点数)`となる。  
もし実部と虚部それぞれに有理数と浮動小数点数を混合したら、有理数が適切な表現の浮動小数点数に変換される。  
もし実部と虚部それぞれに異なる精度の浮動小数点数を混合したら、より制度の高い浮動小数点数の方に統一される。  
虚部が有理数で`0`の場合は、実数に等しいため、実数として扱われる。ただし、虚部が浮動小数点数で`0.0`の場合は、複素数として扱われる。(精度を考慮した結果なのか？)

```lisp
; 複素数の例
#c(2 1)       ; #c(2 1)
#c(2/3 3/4)   ; #c(2/3 3/4)
#c(2 1.0)     ; #c(2.0 1.0)
#c(2.0 1.0d0) ; #c(2.0d0 1.0d0)
#c(1/2 1.0)   ; #c(0.5 2.0)
#c(3 0)       ; 3
#c(3.0 0.0)   ; #c(3.0 0.0)
#c(1/2 0)     ; 1/2
#c(-6/3 0)    ; -2
```

## 10.3 基本的な数学
基本的な算術演算を示す。

### 加算 `+` `1+`
```lisp
(+ 1 2)              ; 3
(+ 1 2 3)            ; 6
(+ 10.0 3.0)         ; 13.0
(+ #c(1 2) #c(3 4))  ; #c(4 6)
(+ 1 2.0)            ; 3.0
(+ #c(1 2) 3)        ; #c(4 2)
(+ #c(1 2) 3/2)      ; #c(5/2 2)
(+ #c(1 1) #c(2 -1)) ; 3

(1+ 20)              ; 21
```

### 減算 `-` `1-`
```lisp
(- 5 4)    ; 1
(- 2)      ; -2
(- 10 3 5) ; 3

(1- 20)    ; 19
```

### 乗算 `*`
```lisp
(* 2 3)   ; 6
(* 2 3 4) ; 24
```

### 除算 `/`
```lisp
(/ 10 5)   ; 2
(/ 10 5 2) ; 1
(/ 2 3)    ; 2/3
(/ 4)      ; 1/4
(/ 2 3.0)  ; 0.6666667
```

### 剰余を求める演算 `mod` `rem`
`mod`と`rem`の両方とも、剰余を求める関数だが、詳細が異なるため、負の数での結果が異なる。

`mod`は、割られる数 - 割られる数より小さい、最大の**割る数の倍数**で計算される。  
すなわち、後述する丸め演算の関数を使用すると下記の通りの関係がある。

```lisp
(+ (* (floor (/ x y)) y) (mod x y)) ; = x
```

```lisp
(mod 7 5)
; 2
(mod -7 5)
; 3
```

`rem`は、割られる数 - 割られる数より絶対値が小さい、絶対値最大の**割る数の倍数**で計算される。
すなわち、後述する丸め演算の関数を使用すると下記の通りの関係がある。

```lisp
(+ (* (truncate (/ x y)) y) (rem x y)) ; = x
```

```lisp
(rem 7 5)
; 2
(rem -7 5)
; -2
```

### 数値を丸める演算 `floor` `ceiling` `truncate` `round`
`floor`は負の無限大の方向に切り捨てて、引数と等しいか小さい値のうち一番大きな整数を返す。(床関数)  
また、`floor`は返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(floor 2.3)
; 2
; 0.29999995
(floor -1.25)
; -2
; 0.75
```

`ceiling`は正の無限大の方向に切り上げて、引数と等しいか大きい値のうち一番小さな整数を返す。(天井関数)  
また、`ceiling`も返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(ceiling 2.3)
; 3
; -0.70000005
(ceiling -2.3)
; -2
; -0.29999995
```

`truncate`は`0`の方向に丸める。  
また、`truncate`も返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(truncate 2.3)
; 2
; 0.29999995
(truncate -2.3)
; -2
; -0.29999995
(truncate 2.7)
; 2
; 0.70000005
(truncate -2.7)
; -2
; -0.70000005
```

`round`は最も近い整数に丸める。  
また、`round`も返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(round 2.3)
; 2
; 0.29999995
(round -2.3)
; -2
; -0.29999995
(round 2.7)
; 3
; -0.29999995
(round -2.7)
; -3
; 0.29999995
```

## 10.4 数値比較
