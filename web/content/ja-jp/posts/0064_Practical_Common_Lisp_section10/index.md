---
title: "書籍 実践 Common Lisp 第10章 数、文字、そして文字列"
date:    2019-05-31T00:00:00+09:00
lastmod: 2019-05-31T00:00:00+09:00
draft: false
toc: true
tags: ["lisp", "実践-Common-Lisp"]
categories: ["実践-Common-Lisp"]
authors:
- otaon
---

## この章について
この章では、Lispの**スカラー**のデータ型である数、文字、文字列(の一部の仕様)について説明する。

## 10.1 数
Common Lispでは、分数、浮動小数点数、複素数など、数学に必要な基本的なデータ型を標準でサポートしている。

## 10.2 数値リテラル
ある方の数値には、テキストでの表現がいくつも存在する。その全てがLispの読み取り器で同じオブジェクトの表現に変換される。  
例えば整数の`10`は、`10`や`20/2`や`#xA`の様に記述できるが、これらを読み取り器では全て同じオブジェクトに変換する。  
さらに、数が書き戻される(=REPLで印字される)ときは、標準的な文字列からなるシンタックス(= **canonical textual syntax**)で印字される。

```lisp
CL-USER> 10
10
CL-USER> 20/2
10
CL-USER> #xa
10
```

### 整数
整数値のシンタックスは、正規表現で`[+-]?[0-9]+`となる。

```lisp
; 整数の例
123  ; 123
+123 ; 123
-123 ; -213
123. ; 123
```

### 分数
分数は、正規表現で`[+-]?[0-9]+/[1-9][0-9]*\.*`となる。  

```lisp
; 分数の例
2/3  ; 2/3
-2/3 ; -2/3
4/6  ; 2/3
6/3  ; 2
```

### 有理数
有理数は全て、読み込まれる時に**正規化**される。すなわち約分される。  

有理数は基数を`10`以外にすることも可能。

- `#B`か`#b`で始まる場合、有理数リテラルは各桁が`[01]`のみの2進数として読み込まれる。
- `#O`か`#o`で始まる場合、有理数リテラルは各桁が`[0-7]`の8進数として読み込まれる。
- `#X`か`#x`で始まる場合、有理数リテラルは各桁が`[0-9A-Fa-f]`の8進数として読み込まれる。
- `#nR`(`n`は10進の数)始まる場合、有理数リテラルは各桁が`[0-9A-Za-z]`のn進数として読み込まれる。

指定した基数は、分子と分母の両方を同時に規定する。

```lisp
; 有理数
#b10101     ; 21
#b1010/1011 ; 10/11
#o777       ; 511
#xDADA      ; 56026
#36rABCDEFG ; 22453731916
```

### 浮動小数点数
有理数とは違い、小数のシンタックスは読み込まれる数値の実際の型に影響する。  
Common Lispには小数のサブタイプが4種類あり、サブタイプごとに異なるビット列で数を表している。

- `short`
- `single`
- `double`
- `long`

これらのサブタイプごとに表せる数の範囲と精度が異なる。  
使うビットが多いほど広範囲かつ高精度に表現できる。

浮動小数点数は、正規表現で`[+-]?[0-9]+\.[0-9]+`となる。  
また、指数表現も可能。(`[+-]?[0-9]+\.?[0-9]*[Ee][+-][0-9]+`)  
指数部のマーカーには上記の`[Ee]`以外にも`[Ss]`(short)、`[Ff]`(single)、`[Dd]`(double)、`[Ll]`(long)が使用できる。  
これらのマーカーを使うと、どの精度を用いるのかを指定できる。  
`[Ee]`は標準(デフォルトでは`short`)の精度を意味する。

浮動小数点数に使われる数字は、常に**10進数**として扱われる。

```lisp
; 浮動小数点数の例
1.0      ; 1.0
1e0      ; 1.0
1d0      ; 1.0d0
123.0    ; 123.0
123e0    ; 123.0
0.123    ; 0.123
.123     ; 0.123
123e-3   ; 0.123
123E-3   ; 0.123
0.123e20 ; 1.23e+19
123d23   ; 1.23d+25
```

### 複素数
複素数は、正規表現`#[Cc](有理数 有理数)`または`#[Cc](浮動小数点数 浮動小数点数)`となる。  
もし実部と虚部それぞれに有理数と浮動小数点数を混合したら、有理数が適切な表現の浮動小数点数に変換される。  
もし実部と虚部それぞれに異なる精度の浮動小数点数を混合したら、より制度の高い浮動小数点数の方に統一される。  
虚部が有理数で`0`の場合は、実数に等しいため、実数として扱われる。ただし、虚部が浮動小数点数で`0.0`の場合は、複素数として扱われる。(精度を考慮した結果なのか？)

```lisp
; 複素数の例
#c(2 1)       ; #c(2 1)
#c(2/3 3/4)   ; #c(2/3 3/4)
#c(2 1.0)     ; #c(2.0 1.0)
#c(2.0 1.0d0) ; #c(2.0d0 1.0d0)
#c(1/2 1.0)   ; #c(0.5 2.0)
#c(3 0)       ; 3
#c(3.0 0.0)   ; #c(3.0 0.0)
#c(1/2 0)     ; 1/2
#c(-6/3 0)    ; -2
```

## 10.3 基本的な数学
基本的な算術演算を示す。

### 加算 `+` `1+`
```lisp
(+ 1 2)              ; 3
(+ 1 2 3)            ; 6
(+ 10.0 3.0)         ; 13.0
(+ #c(1 2) #c(3 4))  ; #c(4 6)
(+ 1 2.0)            ; 3.0
(+ #c(1 2) 3)        ; #c(4 2)
(+ #c(1 2) 3/2)      ; #c(5/2 2)
(+ #c(1 1) #c(2 -1)) ; 3

(1+ 20)              ; 21
```

### 減算 `-` `1-`
```lisp
(- 5 4)    ; 1
(- 2)      ; -2
(- 10 3 5) ; 3

(1- 20)    ; 19
```

### 乗算 `*`
```lisp
(* 2 3)   ; 6
(* 2 3 4) ; 24
```

### 除算 `/`
```lisp
(/ 10 5)   ; 2
(/ 10 5 2) ; 1
(/ 2 3)    ; 2/3
(/ 4)      ; 1/4
(/ 2 3.0)  ; 0.6666667
```

### 剰余を求める演算 `mod` `rem`
`mod`と`rem`の両方とも、剰余を求める関数だが、詳細が異なるため、負の数での結果が異なる。

`mod`は、割られる数 - 割られる数より小さい、最大の**割る数の倍数**で計算される。  
すなわち、後述する丸め演算の関数を使用すると下記の通りの関係がある。

```lisp
(+ (* (floor (/ x y)) y) (mod x y)) ; = x
```

```lisp
(mod 7 5)
; 2
(mod -7 5)
; 3
```

`rem`は、割られる数 - 割られる数より絶対値が小さい、絶対値最大の**割る数の倍数**で計算される。
すなわち、後述する丸め演算の関数を使用すると下記の通りの関係がある。

```lisp
(+ (* (truncate (/ x y)) y) (rem x y)) ; = x
```

```lisp
(rem 7 5)
; 2
(rem -7 5)
; -2
```

### 数値を丸める演算 `floor` `ceiling` `truncate` `round`
`floor`は負の無限大の方向に切り捨てて、引数と等しいか小さい値のうち一番大きな整数を返す。(床関数)  
また、`floor`は返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(floor 2.3)
; 2
; 0.29999995
(floor -1.25)
; -2
; 0.75
```

`ceiling`は正の無限大の方向に切り上げて、引数と等しいか大きい値のうち一番小さな整数を返す。(天井関数)  
また、`ceiling`も返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(ceiling 2.3)
; 3
; -0.70000005
(ceiling -2.3)
; -2
; -0.29999995
```

`truncate`は`0`の方向に丸める。  
また、`truncate`も返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(truncate 2.3)
; 2
; 0.29999995
(truncate -2.3)
; -2
; -0.29999995
(truncate 2.7)
; 2
; 0.70000005
(truncate -2.7)
; -2
; -0.70000005
```

`round`は最も近い整数に丸める。  
また、`round`も返り値を2つ持つ。2つ目の返り値には、丸めた値を持つ。  
したがって、`第1戻り値+第2戻り値=丸め対象の値`となる。

```lisp
(round 2.3)
; 2
; 0.29999995
(round -2.3)
; -2
; -0.29999995
(round 2.7)
; 3
; -0.29999995
(round -2.7)
; -3
; 0.29999995
```

## 10.4 数値比較
### `=`
`=`は、数の等値を、**型の違いを無視して**判定する。  
引数が3つ以上ある場合は、全てが等しいときのみ`t`を返す。

```lisp
(= 1 1) ; t
(= 10 20/2) ; t
(= 1 1.0 #c(1.0 0.0) #c(1 0)) ; t
```

### `/=`
`/=`は、2引数の場合は`(not (= a b))`と等価だが、引数が3つ以上ある場合は、全てが異なるときのみ`t`を返す。

```lisp
(/= 1 1) ; nil
(/= 1 2) ; t
(/= 1 2 3) ; t
(/= 1 2 3 1) ; nil
(/= 1 2 3 1.0) ; nil
```

### `<` `>` `>=` `<=`
`<` `>` `>=` `<=`は有理数と浮動小数点数に対する順序関数。  
引数が3つ以上ある場合は、それぞれの引数を左から右に向かって比較する。

```lisp
(< 2 3) ; t
(> 2 3) ; nil
(> 3 2) ; t
(< 2 3 4) ; t
(< 2 3 3) ; nil
(<= 2 3 3) ; t
(<= 2 3 3 4) ; t
(<= 2 3 4 3) ; nil
```

### `max` `min`
`max` `min`は、引数のうち最大または最小の値を選ぶ。

```lisp
(max 10 11) ; 11
(min -12 -10) ; -12
(max -1 2 -3) ; 2
```

### `zerop` `plusp` `minusp` `oddp` `evenp`
`zerop`は単一の実数が`0`に等しいかを評価する。  
`plusp`は単一の実数が正数かを評価する。  
`minusp`は単一の実数が負数かを評価する。  
`oddp`は単一の整数が奇数かを評価する。  
`evenp`は単一の整数が偶数かを評価する。

## 10.5 高度な数学
下記のような数学的な関数も標準でサポートしている。

- 対数関係の関数`log` `exp` `expt`
- 三角関数`sin` `cos` `tan`
- 三角関数の逆関数`asin` `acos` `atan`
- 双曲線関数`sinh` `cosh` `tanh`
- 双曲線関数の逆関数`asinh` `acosh` `atanh`

## 10.6 文字
文字は`#\任意の文字`で表される。  
例： `#\a` `#\X` `#\)`

特殊な文字を表すためのキーワードが設定されている。

- `Space` : スペース
- `Tab` : タブ
- `Page` : 改頁
- `NewLine` : 改行(LF)
- `Linefeed` : 改行(LF)
- `Return` : 改行(CR)
- `Rubout` : 削除(右)
- `Backspace` : 削除(左)

参考: [バッファ内の Common Lisp の特殊文字を #xyzzy Lisp 用に変換する](https://gist.github.com/miyamuko/1202374)

```lisp
;;   Common Lisp    xyzzy Lisp    char-code
;;   --------------------------------------
;;   #\Backspace    #\C-h                 8
;;   #\Tab          #\TAB                 9
;;   #\Newline      #\LFD                10
;;   #\Linefeed     #\LFD                10
;;   #\Page         #\C-l                12
;;   #\Return       #\RET                13
;;   #\Space        #\SPC                32
;;   #\Rubout       #\DEL               127
```

## 10.8 文字列
文字列リテラルは`"`で囲う。`\`は、次の文字をエスケープする。  
`"`と`\`を文字列リテラルに含めるには、これらの文字を`\`でエスケープする必要がある。

```lisp
"foobar" ; foobar
"foo\"bar" ; foo"bar
"foo\\bar" ; foo\bar
"\"foobar\"" ; "foobar"
"foo\bar" ; foobar
```

**NOTE:**  
REPLでは通常読み込み可能なフォームで文字列を印字する。つまり全体をダブルクォートで囲い、エスケープが必要なものにはバックスラッシュを漬ける。  
したがって、文字列の実際の見た目を確認するには`format`関数などを使用する必要がある。  
```lisp
(format t "~a" str) ; 文字列リテラルstrが印字される
```

## 10.7 文字比較 10.9 文字列比較
### 
|対応する数の比較関数|&nbsp;文字<br/>大/小文字区別|&nbsp;文字<br/>大/小文字無視|&nbsp;文字列<br/>大/小文字区別|&nbsp;文字列<br/>大/小文字無視|
|--------------------|----------------------------|----------------------------|------------------------------|------------------------------|
|`=`                 |&nbsp;`char=`               |&nbsp;`char-equal`          |&nbsp;`string=`               |&nbsp;`string-equal`          |
|`/=`                |&nbsp;`char/=`              |&nbsp;`char-not-equal`      |&nbsp;`string/=`              |&nbsp;`string-not-equal`      |
|`<`                 |&nbsp;`char<`               |&nbsp;`char-lessp`          |&nbsp;`string<`               |&nbsp;`string-lessp`          |
|`>`                 |&nbsp;`char>`               |&nbsp;`char-greaterp`       |&nbsp;`string>`               |&nbsp;`string-greaterp`       |
|`<=`                |&nbsp;`char<=`              |&nbsp;`char-not-greaterp`   |&nbsp;`string<=`              |&nbsp;`string-not-greaterp`   |
|`>=`                |&nbsp;`char>=`              |&nbsp;`char-not-lessp`      |&nbsp;`string>=`              |&nbsp;`string-not-lessp`      |

部分文字列を比較したい場合は、`string=`に下記のようにキーワード引数を利用する。

```lisp
(string= "foobarbaz" "quuxbarfoo" :start1 3 :end1 6 :start2 4 :end2 7)
; barを比較してtを返す
```

- `start1` 左の文字列の比較開始文字のインデックス
- `end1` 左の文字列の比較終了文字の**次の**インデックス
- `start2` 右の文字列の比較開始文字のインデックス
- `end2` 右の文字列の比較終了文字の**次の**インデックス

上表の比較関数のうち、文字列が異なる場合に`t`になるもの(つまり`string=`と`string-equal`以外)は、文字列に違いが見つかった最初のインデックスを返す。

```lisp
(string/= "lisp" "lissome") ; 3
(string< "lisp" "lisper") ; 4
```

**NOTE:**  
部分文字列を比較した時に返ってくる値は、**全体文字列**に対するインデックス。

```lisp
(string< "foobar" "abaz" :start1 3 :start2 1) ; 5
```

**NOTE:**  
文字列をシーケンスとして扱う事もできる。
