---
title: "Go言語入門(基本構文)"
date:    2019-03-31T14:00:00+09:00
lastmod: 2019-03-31T14:00:00+09:00
draft: false
tags: ["Go", "Golang"]
categories: ["Notes"]
authors:
- otaon
---

# 目的
Go言語の基本構文を残す。

# 参考文献
- [スターティング Go言語](https://www.shoeisha.co.jp/book/detail/9784798142418)

# 基本構文
## パッケージ(`package`)・インポート(`import`)について
下記記事を参照。

 [Go言語入門(環境構築・プログラム作成・パッケージ作成・実行・テスト実行)]({{<ref "/posts/0030_go_tutorial/index.md" >}})

## コメント
C言語と同じコメント形式(`//` or `/* */`)を使用できる。後者は入れ子不可能。

## 文構造
Goでは、各々の文はセミコロン(`;`)によって区切られる。  
ただし、Goは<u>全てのセミコロンが省略できる</u>。  

```go
func main() {
	fmt.Println("Hello, World!")
}
```

上記のコードは、コンパイル時に文末にセミコロンが自動的に挿入され、下記のコードとして扱われる。

```go
func main() {
	fmt.Println("Hello, World!");
}
```

**NOTE**  
基本的に、<u>文末判定は行ごとに行われると考えて良い。</u>したがって、下記のコードはコンパイルエラーとなる。

```go
a := [3]string{
	"foo",
	"bar",
	"baz"	// 行末に;が挿入されてしまう
	}
```

これを防ぐには、下記のように末尾要素の後ろにも`,`をつけて、文末でない事を明示すべき。

```go
a := [3]string{
	"foo",
	"bar",
	"baz",	// 文末と判断されず;は挿入されない
	}
```

## 定義済み識別子
下記の定義済み識別子は、変数名や関数名に使用できるが、混乱のもとになるため避けること。

| 識別子の種類 | 識別子 |
|:--------------:|--------|
| 型 | `bool` `byte` `complex64` `complex128` `error` `float32` `float64` `int` `int8` `int16` `int32` `int64` `rune` `string` `uint` `uint8` `uint16` `uint32` `uint64` `uintptr` |
| 定数 | `true` `false` `iota` |
| ゼロ値 | `nil` |
| 関数 | `append` `cap` `close` `complex` `copy` `delete` `imag` `len` `make` `new` `panic` `print` `println` `real` `recover` |

## 出力関数
### `fmt.Println()`
文字列の最後に改行を付加した文字列を標準出力に出力する。

```go
fmt.Println("Hello, Golang!")	// => "Hello, Golang!"
```

複数の引数を渡した場合、各々の文字列をスペースで区切って1行で表示する。

```go
fmt.Println("Hello" "Golang" "!")	// => "Hello Golang !"
```

### `fmt.Printf()`
書式指定子を含んだフォーマット文字列と、可変長引数を渡すと、生成した文字列を標準出力に出力する。

```go
fmt.Printf("数値=%d\n", 5)	// => "数値=5"
```

```go
fmt.Printf("10進数=%d 2進数=%b 8進数=%o 16進数=%x\n", 17, 17, 17, 17)
// => "10進数=17 2進数=10001 8進数=21 16進数=11"
```

可変長引数の個数に過不足がある場合、それを下記のように文字列中で知らせる。

```go
fmt.Printf("%d年%d月%d日\n", 2015, 12)
// => "2015年12月%!d(MISSING)日"

fmt.Printf("%d年%d月%d日\n", 2015, 12, 25, 17)
// => "2015年12月25日%!(EXTRA int=17)"
```

Goのデバッグで有用な書式指定子として`%v`, `%#v`, `%T`がある。

```go
// %v 様々な型のデータを埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列=Golang 配列=[1 2 3]"

// %#v Goのリテラル表現でデータを埋め込む
fmt.Printf("数値=%#v 文字列=%#v 配列=%#v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列="Golang" 配列=[3]int{1 ,2, 3}"

// %T 型情報を埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=int 文字列=string 配列=[3]int"
```

### `print()`, `println()`
組み込み関数として`print()`と`println()`がある。これらは、与えられた文字列を**標準エラー出力**に出力する。

## 変数定義・変数への代入
### 明示的な変数定義
明示的な変数定義の方法を示す。  
見て分かるとおり、`var 変数名　型名`の順番で定義する。  
また、複数の変数定義をまとめて行えるようになっている。

```go
// 明示的な定義
var a int

// int型の変数x, y, zをまとめて定義する
var x, y, z int

// 異なる型の変数x, y, nameをまとめて定義する
var (
	x, y int
	name string
)
```

### 代入
定義した変数に値を代入する方法は下記の通り。  
代入も、複数個の変数にまとめて代入する構文が用意されている。

```go
// 変数への代入
a = 5

// 複数個の変数に複数個の値をまとめて代入する
x, y = 1, 2

// Error: 異なる個数の代入はコンパイルエラーとなる
x, y, z = 1, 2
```

### 暗黙的な定義(推奨)
演算子`:=`を使用することで、型指定なしで変数が定期可能。  
この場合、右辺に記述した式の型が、左辺の変数の型として推論される。  
可能な限り、この方法での変数定義をすること。

```go
i := 3	// int型の変数iに整数3を代入する
b := true	// bool型の変数bに真偽値trueを代入する
f := 3.14	// float64型の変数fに実数3.14を代入する
s := "abc"	// string型の変数sに文字列"abc"を代入する

func one() int {
	return 1
}
n := one()	// int型の変数nに整数1を代入する
```

**NOTE**  
明示的な定義、暗黙的な定義は、当然ながら同一の変数に対しては**ただ1回のみ**使用できる。  
2回目以降の定義の箇所でコンパイルエラーとなる。

**NOTE**  
`var a = 1`と記述することで、変則的だが`var`を使った暗黙的な定義も可能。  
しかし、簡潔さの観点から`:=`のほうが好ましい。

### 変数のスコープ
Goにおける変数は、定義位置により2種類に分かれる。

ローカル変数
: 関数定義の中に定義された変数。  
同一のパッケージ変数がある場合、そのパッケージ変数をシャドウイングする(C言語と同様)。

パッケージ変数
: 関数定義の外に定義された変数。  
パッケージ変数は、プログラム全体で1つの値が共有される(C言語のグローバル変数と同様)。

### 未参照の変数はコンパイルエラーとなる
Goでは、定義済みであるにも関わらず、何からも参照されていない変数があったらコンパイルエラーとなる。
煩わしい場合もあるが、誤った変数の使用を防ぐために存在する機能と考えるべき。

## Goのプリミティブ型
### 真偽値型

|型名|説明|
|:---|----|
| bool | 真（true）または偽（false） |

### 数値型
#### 符号なし整数
|型名|説明|範囲|
|:---|---|----:|
| `uint8` | 8bit符号なし整数 | 0 ~ 255 |
| `byte` |	uint8のエイリアス|  |
| `uint16` | 16bit符号なし整数 | 0 ~ 65535 |
| `uint32` | 32bit符号なし整数 | 0 ~ 4294967295 |
| `uint64` | 64bit符号なし整数 | 0 ~ 18446744073709551615 |
| `uint` | 32bit or 64bitの符号なし整数<br>**（環境依存）** | 0 ~ 18446744073709551615 <br>*or*<br>0 ~ 4294967295 |
| `uintptr` | ポインタの値 | ポインタの値をそのまま格納するのに十分な大きさの符号なし整数<br>（環境依存） |



#### 符号付き整数
| 型名 | 説明 | 範囲 |
|:--|:--|--:|
| `int8` | 8bit符号付き整数 | -128 ~ 127 |
| `int16` | 16bit符号付き整数 | -32768 ~ 32767 |
| `int32` | 32bit符号付き整数 | -2147483648 ~ 2147483647 |
| `int64` | 64bit符号付き整数 | -9223372036854775808 ~ 9223372036854775807 |
| `int` | 32bit or 64bitの符号付き整数<br>**（環境依存）** | -2147483648 ~ 2147483647 <br>*or*<br>-9223372036854775808 ~ 9223372036854775807|
| `rune` |	int32のエイリアス| -2147483648 ~ 2147483647 |


#### 浮動小数点
| 型名 | 説明 | 範囲 |
|:--|:--|:--|
| `float32` | 32bit浮動小数点 | IEEE-754 32bit浮動小数点数 |
| `float64` | 64bit浮動小数点 | IEEE-754 64bit浮動小数点数 |

#### 複素数
| 型名 | 説明 |
|:--|:--|
| `complex64` | 実数部・虚数部をfloat32で表現する複素数 |
| `complex128` | 実数部・虚数部をfloat64で表現する複素数 |

### 文字列型
| 型名 | 説明 |
|:--|:--|
| `string` | 文字列(ダブルクオートで囲む)|

## 型の扱い
### 整数リテラル
Goの整数リテラルにはC言語と同じく3種類存在する。

- 10進数・・・`[1-9][0-9]*` 例: `123`
- 8進数・・・`0[1-7][0-7]*` 例: `0755`
- 16進数・・・`0[Xx][0-9A-Fa-f]+` 例: `0x0719BEEF`

### その他のリテラル
整数型以外も含めると、リテラルには下記がある。

```go
i := 1	// int型

f64 := 1.0	// float64型
f32 := float32(1.0)	// float32型のリテラルは存在しない。型変換が必要。

zero := 0.0	// float64型
pinf := 1.0 / zero	// +Inf 正の無限大(float64型)
ninf := -1.0 / zero	// -Inf 負の無限大(float64型)
nan := zero / zero	// NaN 非数(float64型)

// その他の浮動小数点型リテラル
0.
72.40
072.40	// 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

c := 1.0 + 3i	// complex128型
c2 := complex(1.0, 3)	// complex128型(組み込み関数を使用)
r := real(c2)	// 1.0(実部)
i := imag(c2)	// 3.0(虚部)

// その他の複素数型リテラル
0i
011i	// 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

rune := '松'	// == 26494 rune型(int32のエイリアス)

// その他のruneリテラル
'\a' 'U+0007'	// ベル
'\b' 'U+0008'	// バックスペース
'\f' 'U+000C'	// フィード
'\n' 'U+000A'	// 改行(LF)
'\r' 'U+000D'	// 改行(CR)
'\t' 'U+0009'	// 水平タブ
'\v' 'U+000b'	// 垂直タブ
'\\' 'U+005c'	// バックスラッシュ
'\'' 'U+0027'	// シングルクォート(ルーンリテラルのみ)
'\"' 'U+0022'	// ダブルクォート(文字列リテラルのみ)

'a'
'本'
'\t'

// 8進数3桁
'\000'
'\007'
'\377'

// 16進数2桁
'\x07'
'\xff'

// 16進数4桁(小さいUnicodeコードポイント)
'\u12e4'

// 16進数8桁(大きいUnicodeコードポイント)
'\U00101234'

"文字列"	// 文字列リテラル


`
abcd
efg
hijk
`	// RAW文字列リテラル(改行や特殊文字を後処理せずそのまま扱う)
```

### 型変換
Goでは、**異なる型の暗黙的な型変換を許容しない**。したがって、下記のコードはコンパイルエラーとなる。

```go
var (
	n1 int
	n2 int64
)
n1 = 1
n2 = n1	// コンパイルエラー
```

明示的な型変換は可能。下記のように、`型名(変換対象)`と記述することで型変換できる。

```go
i := 17				// 型指定子がないとリテラルの型(この場合はint型)の変数iにint型の17を代入
n := uint(17)		// uint型の変数nにuint型の17を代入
b := byte(n)		// byte型に変換
i64 := int64(n)		// int64型に変換
u32 := uint32(n)	// uint32型に変換
```

#### 整数型の型変換時の"ラップアラウンド"
下記の場合は、整数リテラル(int)からbyte型へのナローイング変換をコンパイラが検知して、コンパイルエラーとなる。

```go
b := byte(256)	// コンパイルエラー
```

しかし、いったんint型の変数に値を代入して、それを型変換変換すると、ナローイング変換できてしまう。下記の場合、`b`は`0`となる。

```go
n := 256
b := byte(n)	// b == byte(0)
```

Go言語は、C言語と同様に、オーバーフローした時にその型で扱えない桁のビットを単純に無視する。これにより、ある型において、演算結果を、ある型の`mod`のようなものとして扱うことをラップアラウンドと呼ぶ。

#### 各々の方の最大値・最小値を使ったラップアラウンド対策
Goでは、C言語と同様にオーバーフローを考慮した演算を行う必要がある。  
この際に、`math`パッケージに用意されている<u>各々の方の最大値・最小値</u>を使用することができる。


```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("uint32 max value = %d\n", math.MaxUint32)	// uint32 max value = 4294967295
}
```

各々の型の最大値・最小値は下記の通り。

```Go
MaxInt8 =  1 << (8 - 1) - 1
MinInt8 = -1 << (8 - 1)

MaxInt16 =  1 << (16 - 1) - 1
MinInt16 = -1 << (16 - 1)

MaxInt32 =  1 << (32 - 1) - 1
MinInt32 = -1 << (32 - 1)

MaxInt64 =  1 << (64 - 1) - 1
MinInt64 = -1 << (64 - 1)

MaxUInt8 = 1 << 8 - 1
MaxUInt16 = 1 << 16 - 1
MaxUInt32 = 1 << 32 - 1
MaxUInt64 = 1 << 64 - 1

MaxFloat32 = 2**127 * (2**24 - 1) / 2**23
SmallestNonzeroFloat32 = 1 / 2**(127 - 1 + 23)
MaxFloat64 = 2**1023 * (2**53 - 1) / 2**52
SmallestNonzeroFloat64 = 1 / 2**(1023 - 1 + 52)
```

上記の型の最大値・最小値を使用すれば、オーバーフローに(比較的)楽に対応できる。

```go
func sum(a, b uint32) bool {
	if (math.MaxUint32 - a) < b {
		// オーバーフローする
		return false;
	}

	sum := a + b	// このパスではオーバーフローしないことを保証済み
	return sum
}
```

## 配列型
配列の型名は`[要素数]型名`となる。その後に続けた`{}`によって初期値を指定できる。  
インデックスは、一般的な言語と同じく**0始まり**。  
**初期値を与えなかった場合、各要素は0で初期化される。**

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println("%v", a)	// => "[1, 2, 3, 4, 5]"

a[0]	// 1
a[1]	// 2
a[2]	// 3
a[3]	// 4
a[4]	// 5
a[5]	// エラー:範囲外
a[-1]	// エラー:負数を指定

a := [5]int{1, 2, 3, 4, 5, 6}	// エラー:初期値の個数が要素数を超過
b := [5]int		// == [0, 0, 0, 0, 0]
c := [5]int{}	// == [0, 0, 0, 0, 0]

ia := [3]int{}	// == [0, 0, 0]
ua := [3]uint{}	// == [0, 0, 0]
ba := [3]bool{}	// == [false, false, false]
fa := [3]float64{}	// == [0, 0, 0]
ca := [3]complex128{}	// == [(0+0i), (0+0i), (0+0i)]
ra := [3]rune{}	// == [0, 0, 0]
sa := [3]string{}	// == ["", "", ""]

aa := [0]int{}	// 要素数が0の配列も定義可能(使いどころは無さそうだが)
```

要素数を省略するには`[要素数]`の部分を`[...]`と記述する。

```go
a1 := [...]int{1, 2, 3}			// == [3]int{1, 2, 3}
a2 := [...]int{1, 2, 3, 4, 5}	// === [5]int{1, 2, 3, 4, 5}
a3 := [...]int{}				// == [0]int{}
```

要素へ値を代入するには`array[n] = value`の形で記述する。

```go
a := [...]int{1, 2, 3}	// == [1, 2, 3]
a[0] = 0
a[2] = 100
// a == [0, 2, 100]
```

**NOTE**  
配列を、他の配列に代入することも可能。ただし、要素の型と要素数が一致している必要がある。  

**NOTE**  
配列の代入は、ディープコピーとなる。すなわち、配列の代入後に、片方の配列を書き換えても、もう片方の配列は変化しない。

**NOTE**  
Goでは、配列のサイズを拡張することはできない(例えば`[]int`は可変長配列ではない)。  
そのかわり、Goでは**Slice(スライス)**というデータ構造を可変長配列のように扱うことができる。

## `interface{}`と`nil`
### `interface{}`
`interface{}`は、`{}`も含めて型名。  
`interface{}`は、Goの全ての型と互換性のある型。
すなわち、`int`, `float64`,`string`なども全て`interface{}`と互換性がある。  
近いイメージとしては、C言語における汎用ポインタ`(void*)`や、JavaやC#における`Object`クラスがある。

`interface{}`は他の型と同様に変数定義できる。デフォルト値は`nil`。

```go
var x interface{}
fmt.Println("%#v", x)	// => "<nil>"
```

<u>`nil`とは、Goにおいて**具体的な値を持っていない状態を表す値**で、C言語、Java、C#における`null`のようなもの。</u>

`interface{}`型の変数であれば、次のように、あらゆる型の値を代入できる。

```go
var x interface{}
x = 1
x = 3.14
x = '山'
x = "文字列"
x = [...]uint8{1, 2, 3, 4, 5}
```

一旦`interface{}`型に格納されてしまった値は、元の型情報を失ってしまう。  
そのため、例えば`int`型の値を`interface{}`型の変数に代入すると、`+`演算が出来なくなる。

```go
var x, y interface{}
x, y = 1, 2
z := x + y	// 演算できないためエラーとなる
```
