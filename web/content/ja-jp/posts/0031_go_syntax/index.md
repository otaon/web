---
title: "Go言語入門(基本構文)"
date:    2019-03-31T14:00:00+09:00
lastmod: 2019-03-31T14:00:00+09:00
draft: false
tags: ["Go", "Golang"]
categories: ["Notes"]
authors:
- otaon
---

# 目的
Go言語の基本構文を残す。

# 参考文献
- [スターティング Go言語](https://www.shoeisha.co.jp/book/detail/9784798142418)

# 基本構文
## パッケージ(`package`)・インポート(`import`)について
下記記事を参照。

 [Go言語入門(環境構築・プログラム作成・パッケージ作成・実行・テスト実行)]({{<ref "/posts/0030_go_tutorial/index.md" >}})

## コメント
C言語と同じコメント形式(`//` or `/* */`)を使用できる。後者は入れ子不可能。

## 文構造
Goでは、各々の文はセミコロン(`;`)によって区切られる。  
ただし、Goは<u>全てのセミコロンが省略できる</u>。  

```go
func main() {
	fmt.Println("Hello, World!")
}
```

上記のコードは、コンパイル時に文末にセミコロンが自動的に挿入され、下記のコードとして扱われる。

```go
func main() {
	fmt.Println("Hello, World!");
}
```

**NOTE**  
基本的に、<u>文末判定は行ごとに行われると考えて良い。</u>したがって、下記のコードはコンパイルエラーとなる。

```go
a := [3]string{
	"foo",
	"bar",
	"baz"	// 行末に;が挿入されてしまう
	}
```

これを防ぐには、下記のように末尾要素の後ろにも`,`をつけて、文末でない事を明示すべき。

```go
a := [3]string{
	"foo",
	"bar",
	"baz",	// 文末と判断されず;は挿入されない
	}
```

## 定義済み識別子
下記の定義済み識別子は、変数名や関数名に使用できるが、混乱のもとになるため避けること。

| 識別子の種類 | 識別子 |
|:--------------:|--------|
| 型 | `bool` `byte` `complex64` `complex128` `error` `float32` `float64` `int` `int8` `int16` `int32` `int64` `rune` `string` `uint` `uint8` `uint16` `uint32` `uint64` `uintptr` |
| 定数 | `true` `false` `iota` |
| ゼロ値 | `nil` |
| 関数 | `append` `cap` `close` `complex` `copy` `delete` `imag` `len` `make` `new` `panic` `print` `println` `real` `recover` |

## 出力関数
### `fmt.Println()`
文字列の最後に改行を付加した文字列を標準出力に出力する。

```go
fmt.Println("Hello, Golang!")	// => "Hello, Golang!"
```

複数の引数を渡した場合、各々の文字列をスペースで区切って1行で表示する。

```go
fmt.Println("Hello" "Golang" "!")	// => "Hello Golang !"
```

### `fmt.Printf()`
書式指定子を含んだフォーマット文字列と、可変長引数を渡すと、生成した文字列を標準出力に出力する。

```go
fmt.Printf("数値=%d\n", 5)	// => "数値=5"
```

```go
fmt.Printf("10進数=%d 2進数=%b 8進数=%o 16進数=%x\n", 17, 17, 17, 17)
// => "10進数=17 2進数=10001 8進数=21 16進数=11"
```

可変長引数の個数に過不足がある場合、それを下記のように文字列中で知らせる。

```go
fmt.Printf("%d年%d月%d日\n", 2015, 12)
// => "2015年12月%!d(MISSING)日"

fmt.Printf("%d年%d月%d日\n", 2015, 12, 25, 17)
// => "2015年12月25日%!(EXTRA int=17)"
```

Goのデバッグで有用な書式指定子として`%v`, `%#v`, `%T`がある。

```go
// %v 様々な型のデータを埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列=Golang 配列=[1 2 3]"

// %#v Goのリテラル表現でデータを埋め込む
fmt.Printf("数値=%#v 文字列=%#v 配列=%#v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列="Golang" 配列=[3]int{1 ,2, 3}"

// %T 型情報を埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=int 文字列=string 配列=[3]int"
```

### `print()`, `println()`
組み込み関数として`print()`と`println()`がある。これらは、与えられた文字列を**標準エラー出力**に出力する。

## 変数定義・変数への代入
### 明示的な変数定義
明示的な変数定義の方法を示す。  
見て分かるとおり、`var 変数名　型名`の順番で定義する。  
また、複数の変数定義をまとめて行えるようになっている。

```go
// 明示的な定義
var a int

// int型の変数x, y, zをまとめて定義する
var x, y, z int

// 異なる型の変数x, y, nameをまとめて定義する
var (
	x, y int
	name string
)
```

### 代入
定義した変数に値を代入する方法は下記の通り。  
代入も、複数個の変数にまとめて代入する構文が用意されている。

```go
// 変数への代入
a = 5

// 複数個の変数に複数個の値をまとめて代入する
x, y = 1, 2

// Error: 異なる個数の代入はコンパイルエラーとなる
x, y, z = 1, 2
```

### 暗黙的な定義(推奨)
演算子`:=`を使用することで、型指定なしで変数が定期可能。  
この場合、右辺に記述した式の型が、左辺の変数の型として推論される。  
可能な限り、この方法での変数定義をすること。

```go
i := 3	// int型の変数iに整数3を代入する
b := true	// bool型の変数bに真偽値trueを代入する
f := 3.14	// float64型の変数fに実数3.14を代入する
s := "abc"	// string型の変数sに文字列"abc"を代入する

func one() int {
	return 1
}
n := one()	// int型の変数nに整数1を代入する
```

**NOTE**  
明示的な定義、暗黙的な定義は、当然ながら同一の変数に対しては**ただ1回のみ**使用できる。  
2回目以降の定義の箇所でコンパイルエラーとなる。

**NOTE**  
`var a = 1`と記述することで、変則的だが`var`を使った暗黙的な定義も可能。  
しかし、簡潔さの観点から`:=`のほうが好ましい。

### 変数のスコープ
Goにおける変数は、定義位置により2種類に分かれる。

ローカル変数
: 関数定義の中に定義された変数。  
同一のパッケージ変数がある場合、そのパッケージ変数をシャドウイングする(C言語と同様)。

パッケージ変数
: 関数定義の外に定義された変数。  
パッケージ変数は、プログラム全体で1つの値が共有される(C言語のグローバル変数と同様)。

### 未参照の変数はコンパイルエラーとなる
Goでは、定義済みであるにも関わらず、何からも参照されていない変数があったらコンパイルエラーとなる。
煩わしい場合もあるが、誤った変数の使用を防ぐために存在する機能と考えるべき。

## Goのプリミティブ型
### 真偽値型

|型名|説明|
|:---|----|
| bool | 真（true）または偽（false） |

### 数値型
#### 符号なし整数
|型名|説明|範囲|
|:---|---|----:|
| `uint8` | 8bit符号なし整数 | 0 ~ 255 |
| `byte` |	uint8のエイリアス|  |
| `uint16` | 16bit符号なし整数 | 0 ~ 65535 |
| `uint32` | 32bit符号なし整数 | 0 ~ 4294967295 |
| `uint64` | 64bit符号なし整数 | 0 ~ 18446744073709551615 |
| `uint` | 32bit or 64bitの符号なし整数<br>**（環境依存）** | 0 ~ 18446744073709551615 <br>*or*<br>0 ~ 4294967295 |
| `uintptr` | ポインタの値 | ポインタの値をそのまま格納するのに十分な大きさの符号なし整数<br>（環境依存） |



#### 符号付き整数
| 型名 | 説明 | 範囲 |
|:--|:--|--:|
| `int8` | 8bit符号付き整数 | -128 ~ 127 |
| `int16` | 16bit符号付き整数 | -32768 ~ 32767 |
| `int32` | 32bit符号付き整数 | -2147483648 ~ 2147483647 |
| `int64` | 64bit符号付き整数 | -9223372036854775808 ~ 9223372036854775807 |
| `int` | 32bit or 64bitの符号付き整数<br>**（環境依存）** | -2147483648 ~ 2147483647 <br>*or*<br>-9223372036854775808 ~ 9223372036854775807|
| `rune` |	int32のエイリアス| -2147483648 ~ 2147483647 |


#### 浮動小数点
| 型名 | 説明 | 範囲 |
|:--|:--|:--|
| `float32` | 32bit浮動小数点 | IEEE-754 32bit浮動小数点数 |
| `float64` | 64bit浮動小数点 | IEEE-754 64bit浮動小数点数 |

#### 複素数
| 型名 | 説明 |
|:--|:--|
| `complex64` | 実数部・虚数部をfloat32で表現する複素数 |
| `complex128` | 実数部・虚数部をfloat64で表現する複素数 |

### 文字列型
| 型名 | 説明 |
|:--|:--|
| `string` | 文字列(ダブルクオートで囲む)|

## 型の扱い
### 整数リテラル
Goの整数リテラルにはC言語と同じく3種類存在する。

- 10進数・・・`[1-9][0-9]*` 例: `123`
- 8進数・・・`0[1-7][0-7]*` 例: `0755`
- 16進数・・・`0[Xx][0-9A-Fa-f]+` 例: `0x0719BEEF`

### その他のリテラル
整数型以外も含めると、リテラルには下記がある。

```go
i := 1	// int型

f64 := 1.0	// float64型
f32 := float32(1.0)	// float32型のリテラルは存在しない。型変換が必要。

zero := 0.0	// float64型
pinf := 1.0 / zero	// +Inf 正の無限大(float64型)
ninf := -1.0 / zero	// -Inf 負の無限大(float64型)
nan := zero / zero	// NaN 非数(float64型)

// その他の浮動小数点型リテラル
0.
72.40
072.40	// 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

c := 1.0 + 3i	// complex128型
c2 := complex(1.0, 3)	// complex128型(組み込み関数を使用)
r := real(c2)	// 1.0(実部)
i := imag(c2)	// 3.0(虚部)

// その他の複素数型リテラル
0i
011i	// 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

rune := '松'	// == 26494 rune型(int32のエイリアス)

// その他のruneリテラル
'\a' 'U+0007'	// ベル
'\b' 'U+0008'	// バックスペース
'\f' 'U+000C'	// フィード
'\n' 'U+000A'	// 改行(LF)
'\r' 'U+000D'	// 改行(CR)
'\t' 'U+0009'	// 水平タブ
'\v' 'U+000b'	// 垂直タブ
'\\' 'U+005c'	// バックスラッシュ
'\'' 'U+0027'	// シングルクォート(ルーンリテラルのみ)
'\"' 'U+0022'	// ダブルクォート(文字列リテラルのみ)

'a'
'本'
'\t'

// 8進数3桁
'\000'
'\007'
'\377'

// 16進数2桁
'\x07'
'\xff'

// 16進数4桁(小さいUnicodeコードポイント)
'\u12e4'

// 16進数8桁(大きいUnicodeコードポイント)
'\U00101234'

"文字列"	// 文字列リテラル


`
abcd
efg
hijk
`	// RAW文字列リテラル(改行や特殊文字を後処理せずそのまま扱う)
```

### 型変換
Goでは、**異なる型の暗黙的な型変換を許容しない**。したがって、下記のコードはコンパイルエラーとなる。

```go
var (
	n1 int
	n2 int64
)
n1 = 1
n2 = n1	// コンパイルエラー
```

明示的な型変換は可能。下記のように、`型名(変換対象)`と記述することで型変換できる。

```go
i := 17				// 型指定子がないとリテラルの型(この場合はint型)の変数iにint型の17を代入
n := uint(17)		// uint型の変数nにuint型の17を代入
b := byte(n)		// byte型に変換
i64 := int64(n)		// int64型に変換
u32 := uint32(n)	// uint32型に変換
```

#### 整数型の型変換時の"ラップアラウンド"
下記の場合は、整数リテラル(int)からbyte型へのナローイング変換をコンパイラが検知して、コンパイルエラーとなる。

```go
b := byte(256)	// コンパイルエラー
```

しかし、いったんint型の変数に値を代入して、それを型変換変換すると、ナローイング変換できてしまう。下記の場合、`b`は`0`となる。

```go
n := 256
b := byte(n)	// b == byte(0)
```

Go言語は、C言語と同様に、オーバーフローした時にその型で扱えない桁のビットを単純に無視する。これにより、ある型において、演算結果を、ある型の`mod`のようなものとして扱うことをラップアラウンドと呼ぶ。

#### 各々の方の最大値・最小値を使ったラップアラウンド対策
Goでは、C言語と同様にオーバーフローを考慮した演算を行う必要がある。  
この際に、`math`パッケージに用意されている<u>各々の方の最大値・最小値</u>を使用することができる。


```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("uint32 max value = %d\n", math.MaxUint32)	// uint32 max value = 4294967295
}
```

各々の型の最大値・最小値は下記の通り。

```Go
MaxInt8 =  1 << (8 - 1) - 1
MinInt8 = -1 << (8 - 1)

MaxInt16 =  1 << (16 - 1) - 1
MinInt16 = -1 << (16 - 1)

MaxInt32 =  1 << (32 - 1) - 1
MinInt32 = -1 << (32 - 1)

MaxInt64 =  1 << (64 - 1) - 1
MinInt64 = -1 << (64 - 1)

MaxUInt8 = 1 << 8 - 1
MaxUInt16 = 1 << 16 - 1
MaxUInt32 = 1 << 32 - 1
MaxUInt64 = 1 << 64 - 1

MaxFloat32 = 2**127 * (2**24 - 1) / 2**23
SmallestNonzeroFloat32 = 1 / 2**(127 - 1 + 23)
MaxFloat64 = 2**1023 * (2**53 - 1) / 2**52
SmallestNonzeroFloat64 = 1 / 2**(1023 - 1 + 52)
```

上記の型の最大値・最小値を使用すれば、オーバーフローに(比較的)楽に対応できる。

```go
func sum(a, b uint32) bool {
	if (math.MaxUint32 - a) < b {
		// オーバーフローする
		return false;
	}

	sum := a + b	// このパスではオーバーフローしないことを保証済み
	return sum
}
```

## 配列型
配列の型名は`[要素数]型名`となる。その後に続けた`{}`によって初期値を指定できる。  
インデックスは、一般的な言語と同じく**0始まり**。  
**初期値を与えなかった場合、各要素は0で初期化される。**

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println("%v", a)	// => "[1, 2, 3, 4, 5]"

a[0]	// 1
a[1]	// 2
a[2]	// 3
a[3]	// 4
a[4]	// 5
a[5]	// エラー:範囲外
a[-1]	// エラー:負数を指定

a := [5]int{1, 2, 3, 4, 5, 6}	// エラー:初期値の個数が要素数を超過
b := [5]int		// == [0, 0, 0, 0, 0]
c := [5]int{}	// == [0, 0, 0, 0, 0]

ia := [3]int{}	// == [0, 0, 0]
ua := [3]uint{}	// == [0, 0, 0]
ba := [3]bool{}	// == [false, false, false]
fa := [3]float64{}	// == [0, 0, 0]
ca := [3]complex128{}	// == [(0+0i), (0+0i), (0+0i)]
ra := [3]rune{}	// == [0, 0, 0]
sa := [3]string{}	// == ["", "", ""]

aa := [0]int{}	// 要素数が0の配列も定義可能(使いどころは無さそうだが)
```

要素数を省略するには`[要素数]`の部分を`[...]`と記述する。

```go
a1 := [...]int{1, 2, 3}			// == [3]int{1, 2, 3}
a2 := [...]int{1, 2, 3, 4, 5}	// === [5]int{1, 2, 3, 4, 5}
a3 := [...]int{}				// == [0]int{}
```

要素へ値を代入するには`array[n] = value`の形で記述する。

```go
a := [...]int{1, 2, 3}	// == [1, 2, 3]
a[0] = 0
a[2] = 100
// a == [0, 2, 100]
```

**NOTE**  
配列を、他の配列に代入することも可能。ただし、要素の型と要素数が一致している必要がある。  

**NOTE**  
配列の代入は、ディープコピーとなる。すなわち、配列の代入後に、片方の配列を書き換えても、もう片方の配列は変化しない。

**NOTE**  
Goでは、配列のサイズを拡張することはできない(例えば`[]int`は可変長配列ではない)。  
そのかわり、Goでは**Slice(スライス)**というデータ構造を可変長配列のように扱うことができる。

## `interface{}`型と`nil`
`interface{}`は、`{}`も含めて型名。  
`interface{}`は、Goの全ての型と互換性のある型。
すなわち、`int`, `float64`,`string`なども全て`interface{}`と互換性がある。  
近いイメージとしては、C言語における汎用ポインタ`(void*)`や、JavaやC#における`Object`クラスがある。

`interface{}`は他の型と同様に変数定義できる。デフォルト値は`nil`。

```go
var x interface{}
fmt.Println("%#v", x)	// => "<nil>"
```

<u>`nil`とは、Goにおいて**具体的な値を持っていない状態を表す値**で、C言語、Java、C#における`null`のようなもの。</u>

`interface{}`型の変数であれば、次のように、あらゆる型の値を代入できる。

```go
var x interface{}
x = 1
x = 3.14
x = '山'
x = "文字列"
x = [...]uint8{1, 2, 3, 4, 5}
```

一旦`interface{}`型に格納されてしまった値は、元の型情報を失ってしまう。  
そのため、例えば`int`型の値を`interface{}`型の変数に代入すると、`+`演算が出来なくなる。

```go
var x, y interface{}
x, y = 1, 2
z := x + y	// 演算できないためエラーとなる
```

## 演算子
`Go`では下記の演算子が使用できる。

|種類|&nbsp;&nbsp;演算子|
|----|------|
|算術|&nbsp;&nbsp;+ - * / % & \| ^ ^& << >> |
|比較|&nbsp;&nbsp;== != < <= > >=|
|論理|&nbsp;&nbsp;\|\| &&|
|単行|&nbsp;&nbsp;+ - ! ^ * & <-|
<br/>

|優先度|&nbsp;&nbsp;演算子|
|------|------|
|高    |&nbsp;&nbsp;* / % << >> & &^|
|      |&nbsp;&nbsp;+ - \| ^|
|      |&nbsp;&nbsp;== != < <= > >=|
|      |&nbsp;&nbsp;&&|
|低    |&nbsp;&nbsp;\|\||

### 演算子の意味と対象の型

|演算子|&nbsp;&nbsp;意味|&nbsp;&nbsp;対象の型|
|------|----|--------|
|+(単項)|&nbsp;&nbsp;意味なし(`0 + x`と等価)|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|-(単項)|&nbsp;&nbsp;符号反転|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|^(単項)|&nbsp;&nbsp;ビットの補数|&nbsp;&nbsp;整数、浮動小数点数|
|+(2項)|&nbsp;&nbsp;和|&nbsp;&nbsp;整数、浮動小数点数、複素数、文字列(文字列結合)|
|-(2項)|&nbsp;&nbsp;差|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|*(2項)|&nbsp;&nbsp;積|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|/(2項)|&nbsp;&nbsp;商(商は0の方向へ切り捨て/切り上げされる)|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|%(2項)|&nbsp;&nbsp;剰余|&nbsp;&nbsp;整数|
|&(2項)|&nbsp;&nbsp;論理積(ビット演算)|&nbsp;&nbsp;整数|
|\|(2項)|&nbsp;&nbsp;論理和(ビット演算)|&nbsp;&nbsp;整数|
|^(2項)|&nbsp;&nbsp;排他的論理和(ビット演算)|&nbsp;&nbsp;整数|
|&^(2項)|&nbsp;&nbsp;ビットクリア(`a &^ b == a & (^b)`)|&nbsp;&nbsp;整数|
|<<(2項)|&nbsp;&nbsp;左シフト(ビット演算)|&nbsp;&nbsp;整数|
|>>(2項)|&nbsp;&nbsp;右シフト(ビット演算)|&nbsp;&nbsp;整数|
|==|等しい|比較可能な型|
|!=|等しくない|比較可能な型|
|<|未満|順序が有る型|
|<=|以下|順序が有る型|
|>|超|順序が有る型|
|>=|以上|順序が有る型|
|&&|and(論理値)|論理値|
|\|\||or(論理値)|論理値|
|!|not(論理値)|論理値|
<br/>

比較可能な型
: 論理値、整数値、浮動小数点数、複素数、文字列

順序が有る型
: 整数値、浮動小数点数、文字列

**NOTE**
`a = a [演算子] b`という形の2項演算子は`a [演算子]= b`という短縮形を持つ。

## 関数
 

 ```go
func 関数名([引数名 型名]*) 戻り値の型名* {
	処理
}
 ```

### [引数名 型名]*
同じ型の引数を指定する場合、`x, y int`のように型の指定を一つにまとめることも、`x int, y int`のように変数ごとに型名を指定することもできる。

### 戻り値のない関数
戻り値のない関数は、下記のように戻り値の型名を省略することで定義できる。

```go
func 関数名([引数名 型名]*) {
	処理
}
 ```

### 複数の戻り値を持つ関数
Goでは複数の戻り値を持つ関数を定義できる。

```go
func 関数名([引数名 型名]*) (戻り値の型名1, 戻り値の型名2) {
	処理
	return 戻り値1, 戻り値2
}
```

複数の戻り値を持つ関数の戻り値は下記のように受け取る

```go
a, b := f(x, y)
```

複数の戻り値に不要なものがある場合、下記のように`_`を使うことで破棄できる。

```go
// 2つ目の戻り値を破棄
q, _ := f(x, y)

// 型推論できないためコンパイルエラー
_, _ := f(x, y)

// コンパイルエラーとはならないが、ただの関数呼び出しと等しいため無意味
_, _ = f(x, y)
```

### Goにおけるエラー処理
Goには例外機構がない。  
Goにおける一般的なエラー処理では、下記のイディオムを用いる。  
複数の戻り値を用いて、最後の戻り値でエラー内容を表すことで、関数の呼び出し元に自主的にエラー判定を行わせる。  

```go
result, err := f(x, y)
if (err != nil) {
	// エラー発生時の処理を書く
}
```

この方法は、C言語ライクのエラー判定をやりやすくした程度で原始的だが、単純で良いと思う。  
エラー用の戻り値を読み捨てるような使い方をされる可能性があるが、そもそも`err`は契約的プログラミングでいう事前条件違反を表すものと考えれば、むしろエラーハンドリングの責務を明確にできるのかもしれない。

### 戻り値を表す変数
Goでは戻り値に変数を割り当てることができる。

```go
package main

import (
	"fmt"
)

func f() (a int) {	// 戻り値に変数aを割り当てた
	return
}

func main() {
	fmt.Println(f())	// => 0 (== aのデフォルト値)
}
```

上記の構文は、下記のコードの短縮形と考えられる。

```go
// 短縮形
func f() (a int) {
	return
}

// 短縮していない形
fnc f() int {
	var a int
	return a
}
```

複数の戻り値に対しても変数を割り当てることができる。

```go
// 短縮形
func f() (a, b int) {
	b = 5
	return	// x === 0, y == 5
}

// 短縮していない形
func f() (int, int) {
	var a, b int
	b = 5
	return a, b	// x === 0, y == 5
}
```

### 引数を無視する
戻り値と同じく、引数も破棄することができる。  
インターフェースで定義されているプロトタイプを実装するとき、実装で使用しない場合に、それを明示する場合に使用すると無駄な変数割り当てが発生しない。

```go
func f(_, _ int) int {
	return 1
}

f(2, 3)	// => 1
```

### 無名関数
Goでは、関数を変数に代入できる。  
名前がある関数を代入できるのはもちろんのこと、下記のように関数定義自体をそのまま代入することもできる。

```go
f := func(x, y int) int { return x + y}
```

上記の右辺のように、関数を名前無しで定義して、それ自身を変数に代入できる。  
このとき、右辺を**関数リテラル**と呼ぶ。

関数リテラルの型は、その関数の引数の型と戻り値の型の組となる。  

```go
fmt.Println("%T\n", func(x, y int) int {return x + y})
// => "func(int, int) int"
```

したがって、意味はないが、変数を、この型で定義することもできる。

```go
var f func(int, int) int
f = func(x, y int) int { return x + y}
```

### 高階関数(関数を返す関数)
```go
package main

import (
	"fmt"
)

func F() func() {	// 戻り値の型 func()
	return func() {
		fmt.Println("Hello, World!")
	}
}

func main() {
	function := F()
	function()	// "Hello, World!"

	// F()で帰ってきたfを同時に呼び出す
	F()()	// "Hello, World!"
}
```

### 高階関数(関数を引数に渡す関数)

```go
package main

import (
	"fmt"
)

func F(f func()) {
	f()
}

func main() {
	F(func() { fmt.Println("Hello, World!") })	// "Hello, World!"
}
```

### クロージャ
Goではクロージャも定義できる。

```go
package main

/**
 * "nextに値を渡すとその値を内部に保持し、その前にnextに渡した値を返す"関数を返す
 */
func later() func(string) string {
	var store string
	return func(next string) string {
		s := store
		store = next
		return s
	}
}

func main() {
	f := later()
	f("Golang")	// => ""
	f("is")	// => "Golang"
	f("good")	// => "is"
}
```

#### クロージャでジェネレータを実装する
```go
package main

/**
 * "nextに値を渡すとその値を内部に保持し、その前にnextに渡した値を返す"関数を返す
 */
func integers() func() int {
	index := -1
	return func() int {
		index += 1
		return index
	}
}

func main() {
	f := integers()
	f()	// => 0
	f()	// => 1
	f()	// => 2
	f()	// => 3
	f2 := integers()
	f2()	// => 0
	f2()	// => 1
}
```

## 定数
Goでは`const`を使用して定数を定義できる。

```go
const X = 1	// 定数1(整数)
```

複数の定数をまとめて定義することもできる。

```go
const (
	X = 1
	Y = 2
	Z = 3
)
```

- **NOTE**  
  - 途中から定数に定義する値を省略した場合、前回定義したのと同じ値を定数定義する。  
    ただし、全ての定数定義の値を省略することはできない。
  - 定数の値の定義には任意の式を使用でき、さらに、その中に他の定数を使用できる。

```go
const (
	X = 1
	Y = 2
	Z	// 2
)

// コンパイルエラー
const (
	X
	Y
	Z
)

const (
	A = 1	// 1
	B = A + 1	// 2
	C = B + 1	// 3
	Z = X + Y	// 9 この行の後に定義されている定数も使用可能
	X = 2
	Y = 7
)
```

### 定数の型
Goの定数定義では、下記のいずれかの値を定義できる。

- 論理型
- 整数(**「整数」であり、int等の型ではない**)
- 浮動小数点数(**「浮動小数点数」であり、float64等の型ではない**)
- 複素数
- ルーン
- 文字列

型を指定子ない定数定義では、整数はあくまでも整数であり、intやuintなどの区別はない。  
型ありの定数を定義したい場合は、下記のように型を指定して定数定義する。

```go
const (
	I64 int64 = -1	// 定数I64はint64型
	I32 = int32(-1)	// 定数32はint32型
	F64 float64 = 1.2	// 定数F64はfloat64型
	F32 = float32(1.2)	// 定数F32はfloat32型
)
```

### 各定数の注意
#### 論理値の定数
論理値はbool型と全く同じであるため、使用上の注意は特に無し。

#### 整数値の定数
整数値の定数には最大値/最小値がないため、定数定義するぶんにはいくらでも大きな/小さな数値を定義できる。
しかし、変数への代入の際にコンパイルエラーとなる。  
このように、分かりやすさを優先するため、できる限り定数には型を指定したほうが良い。

```go
const (
	N = 9999999999999999999999999999999999999999999999999999999
)
i := N	// コンパイルエラー
```

**NOTE**  
数値定数同士の演算はコンパイル時に処理されるという性質がある。  
そのため、下記のコードは問題なく動作する。

```go
const (
	// uint64型の最大値より1大きな整数値
	N = 18446744073709551615 + 1
)

n := uint64(N - 1)

// コンパイル時に下記の形に変換されて評価されるため、エラーとならない
n := uint64(18446744073709551615)
```

#### 浮動小数点数の定数
浮動小数点数の型(float64, float32)よりも高い精度の少数を定数定義することは可能。  
ただし、float64またはfloat32のどちらかに変換した型が許容するまで精度が落ちる。

**NOTE**  
変数を介さず、定数のみで演算することで、コンパイル時に精度を落とさず演算できる。

#### 複素数の定数
複素数リテラルを使用して定数定義できる。  
複素数の実部・虚部ともに浮動小数点数と同様の精度を備えている。

#### ルーン、文字列の定数
ルーンリテラル、文字列リテラルを使用して、rune型および文字列型の定数を定義できる。  
文字列型定数の定義ではRAW文字列リテラルも使用できる。

### `iota`によるenumのような定数定義
定数定義ブロック内で`iota`キーワードを使用することで、連番の定数を簡単に定義できる。  
ただし、無駄に複雑な定数定義は混乱を招くので、関連の有る単位で定数ブロックを分けること。

- **NOTE**
  - `iota`は0始まり。次の行の定数では+1される。
  - `iota`は省略可能。
  - 異なる値を定義した場合はその値になるが、`iota`自体は行ごとに必ずインクリメントされている。
  - コードブロックごとに`iota`は0にリセットされる。

```go
const (
	A = iota	// 0
	B			// 1
	C			// 2
)

const (
	D = 1 + iota	// 1
	E = 1 + iota	// 2
	F = 1 + iota	// 3
	FF = iota		// 3
)

const (
	G = 1 + iota	// 1
	H				// 1 + iota == 2
	I				// 1 + iota == 3
)

const (
	J = iota	// 0
	K = 100		// 100
	L			// 100
	M = iota	// 4
	N			// 5
)
```

## スコープ
Goにおいて、定義済み識別子以外の構成要素はパッケージに属する。

### パッケージのスコープ
- **識別子の1文字目が大文字**の定数、変数、関数は、他のパッケージから参照できる。
- **識別子の1文字目が小文字**の定数、変数、関数は、自分のパッケージからしか参照できない。
- **識別子の1文字目が大文字小文字の区別のない文字(日本語など)**の定数、変数、関数は、自分のパッケージからしか参照できない。

```go
package foo

// 定数
const (
	A = 1		// 先頭大文字・・・他のパッケージから参照できる
	abc = "abc"	// 先頭小文字・・・他のパッケージから参照できない
)

// パッケージ変数
var (
	m = 256	// 先頭小文字・・・他のパッケージから参照できない
	N = 512	// 先頭大文字・・・他のパッケージから参照できる
)

// public関数
func DoSomething() {
	// ...
}

// private関数
func doSomething() {
	// ...
}
```

```go
package bar

import (
	"foo"
)

foo.A	// 1
foo.abc	// コンパイルエラー

foo.N	// 512
foo.m	// コンパイルエラー
```

### いろいろな`import`方法
インポートする際に、別名を指定できる。  
下記のコードでは、パッケージ`fmt`を`f`という別名で**上書き**している。  
したがって、下記の`main`パッケージでは、パッケージ`fmt`を`fmt`という名前で参照できない。

```go
package main

import (
	f "fmt"	// パッケージ"fmt"を、名前fとしてインポートする
)

func main() {
	f.Println("Hello, World!")	// パッケージ名をfとして参照できる
}
```

パッケージ名を省略するためには、別名に`.`を指定する。

```go
package main

import (
	"fmt"
	. "math"	// mathパッケージを、パッケージ名無しでインポート
)

func main() {
	fmt.Println(Pi)	// Piをmathパッケージ指定なしで参照できる
}
```

パッケージ名を省略した場合、そのパッケージが持つ識別子と名前衝突の危険がある。

```go
package main

import (
	. "math"	// mathパッケージを、パッケージ名無しでインポート
)

const (
	Pi	// math.Piと名前衝突するためコンパイルエラー
)
```

### `import`宣言のスコープはファイル単位
Goでは１つのパッケージを複数ファイルに分割して定義できる。しかし、`import`宣言は各々のファイル内でのみ有効。

- `main1.go`

```go
package main

import (
	f "fmt"
)

func main() {
	foo()
}
```

- `main2.go`

```go
package main

func foo() {
	fmt.Println("Hello, World!")	// fmtが解決できないためコンパイルエラー
}
```

### 関数のスコープ
Goにおいて、関数はスコープを形成する。すなわち、関数内で定義した変数や定数は、その関数内でのみ有効。  
また、関数の引数名と戻り値名も関数と同名の変数などを関数内部で定義(シャドーイング)することは不可能。

C言語のように`{}`を用いることで、スコープを定義することができる。

```go
func foo(a int) (b string) {
	{
		var a int
		const b = "string"
	}
	return b	// "" 戻り値の初期値
}
```

## 制御構文
### `for`
Goにおけるループ用の制御構文は`for`のみ。

```go
for {
	// ...

	if [条件] {
		break	// 中断
	}

	if [条件] {
		continue	// 次の周回へジャンプ
	}
}

for i := 0; i < 10; i++ {
	// 0から9までの繰り返し
}

for ;; {
	// 無限ループ
}
```

pythonなどにあるような範囲節を用いたループも記述できる。

```go
for [配列のインデックス], [配列の要素] := range [配列型] {
	// ...
}

for i, s := range [3]string{"aaa", "bbb", "ccc"} {
	fmt.Printf("%v:%v\n", i, s)
}
// =>
// 0:aaa
// 1:bbb
// 2:ccc
```

範囲節に指定できる型は下記の通り。

|データ型|型|反復値<br/>(1番目)<br/>== [配列のインデックス]|反復値の型<br/>(1番目)|反復値<br/>(2番目)<br/>== [配列の要素]|反復値の型<br/>(2番目)|
|:---|:---:|:---|:---:|:---|:---:|
|配列型|`[n]E`|インデックス|`int`|配列の要素|`E`|
|配列型のポインタ|`*[n]E`|インデックス|`int`|配列の要素|`E`|
|スライス|`[]E`|インデックス|`int`|の要素|`E`|
|文字列|`string`|インデックス|`int`|ルーン|`rune`|
|マップ|`map[K]V`|マップのキー|`K`|マップの値|`V`|
|チャネル|`chan E`, `<- chan E`|チャネルの値|`E`|無し|-|

- 
- インデックスは0始まり

### `if`
条件文のひとつに`if`がある。

```go
if x == 1 {
	// ...
}

if x == 1 {
	// ...
} else if x == 2 {
	// ...
} else if x == 3 {
	// ...
} else {
	// ...
}

// {}は絶対に省略できない
if x == 1
	// ...	// コンパイルエラー

// 真偽値を返さない条件式は記述できない
if 1 {
	// ...	// コンパイルエラー
}
```

#### 簡易文付き`if`
条件式への使用などのために、条件式の前に単一の文を定義できる。  
簡易文で定義した変数は、`if`の中でのみ使用できる。つまり`if`の外では参照できない。

```go
if [簡易文]; [条件式] {
	// ...
}

if x, y = 1, 2; x < y {
	// ...
}

// ここではx, yを参照できない
```

簡易文付き`if`は、エラー処理をシンプルに記載する際に便利。

```go
if _, err := doSomething(); err != nil {
	// エラー発生時の処理
}
```

### `switch`
#### 式による`switch`
大抵はCにおけるswitchと似ているが、細部の仕様が異なる。

- `if`と同じく簡易文が使える。
- `case`に複数の式をカンマ区切りで指定できる。
- 互換性のある型にはマッチする。
- Goにおける`switch`ではフォールスルー特性がない。  
  すなわち、各caseの処理が完了したら他の`case`に入らず`switch`文から出る。
- `case`に式と値を混在させるとコンパイルエラーとなる。

```go
switch [簡易文;] [式] {
	// ...
}

n := 3
switch n {
case 1, 2:
	fmt.Println("1 or 2")
case 3, 4:
	fmt.Println("3 or 4")
default:
	fmt.Println("other")
}
// =>
// "3 or 4"

n := 3
switch n {
case 1:
	fmt.Println("one")
case 2.0:	// 整数2の場合、ここに入る
	fmt.Println("two")
case 3+0i:	// 整数3と互換の型のため、ここに入る
	fmt.Println("three")
}
// =>
// "three"

// 式を使ったswitch-case文
n := 4
switch n {
case 0 < n && n < 3:
	fmt.Println("0 < n < 3")
case 3 < n && n < 6:
	fmt.Println("3 < n < 6")
}
// =>
// "3 < n < 6"
```


#### **型アサーション**と型による`switch`
型アサーションとは、動的に変数の型をチェックする機能。

1つの戻り値を受け取る場合、型アサーション違反となるとランタイムパニックが発生する。

```go
// 基本的な書式
x.(T)	// 変数xが型Tでなければランタイムパニックを発生させる

var x interface{} = 3

i := x.(int)		// エラー発生せず(i == 3)
f := x.(float64)	// ランタイムパニック発生
```

2つの戻り値を受け取る場合、第2戻り値に型アサーションの結果が真偽値で格納される。

```go
var x interface{} = 3.14

i, isInt := x.(int)	// i == 0, isInt == false
f, isFloat64 := x.(float64)	// f == 3.14, isFloat64 == true
s, isString := x.(string)	// s == "", isString == false


// 実用例
if x == nil {
	fmt.Println("x is nil")
} else if i, isInt := x.(int); isInt {
	fmt.Printf("x is integer : %d\n", i)
} else if s, isString := x.(string); isString {
	fmt.Println(s)
} else {
	fmt.Println("unsupported type")
}
```

上記コードの実用例を`switch`を用いることでさらに簡潔に記述できる。

```go
switch x.(type) {
case bool:
	fmt.Println("x is bool")
case int, uint:
	fmt.Printf("x is integer or unsigned integer")
case string:
	fmt.Println("string")
default:
	fmt.Println("unsupported type")
}
```

簡易文によって、`switch`本体で値を簡単に使用できる。  
このとき、値が明確に型推論可能であれば、`case`内部の値は型情報を与えられる。

```go
// 正しい使用例
switch v := x.(type) {
case bool:
	fmt.Println("x is bool", v)
case int:
	fmt.Printf("x is integer: v^2=", v * v)
case string:
	fmt.Println(v)
default:
	fmt.Printlf("unsupported type: %#v\n", v)
}

// 誤った使用例
switch v := x.(type) {
case int, uint:	// int型かuint型か定まらないためコンパイルエラーとなる
	fmt.Printf("x is integer: v^2=", v * v)
default:
	fmt.Printlf("unsupported type: %#v\n", v)
}
```

### `goto`
`goto`も使用可能。ただし、安全性を保つため下記制約がある。

- ラベルと`goto`の組み合わせは関数内に閉じた範囲で使用できる。
- `goto`によって、`for`文などが構成するブロックの外側から内側にはジャンプできない。
- `goto`によって、**変数定義**を飛び越えられない。

```go
func main() {
	fmt.Println("A")
	goto L
	fmt.Println("B")
L:	// ラベル
	fmt.Prinln("C")
}

// =>
// A
// C
```

### ラベル付き文
`goto`を使わずとも、**ラベル付き文**を用いれば大域脱出が可能。

```go
LOOP:
	for {
		for {
			for {
				fmt.Println("開始")
				break LOOP
			}
			fmt.Println("ここは通らない")
		}
		fmt.Println("ここは通らない")
	}
	fmt.Println("完了")

// =>
// 開始
// 完了
```


### `defer`で関数終了時の処理を登録する
`defer`キーワードを使用することで、関数終了時の処理を予め登録しておける。  
登録しておいた処理は、関数終了時に実行される。

```go
func runDefer() {
	defer fmt.Println("defer")	// runDefer()終了時に呼ばれる処理
	fmt.Println("done")
}
runDefer()

// =>
// done
// defer
```

`defer`を使えば、ファイルのオープン/クローズ処理などの、リソース管理を多少楽に記述できる。  
`defer`は複数回使用できるが、後に登録した処理から先に実行されることに注意。

```go
func foo() {
	file, err := os.Open("path/to/file")
	if err != nil {
		// ファイルのオープンに失敗
		return
	}
	defer file.Close()	// 最後にファイルをクローズするように処理を登録

	// ファイルを使った処理...
}

func foo() {
	defer Println("1")
	defer Println("2")
	defer Println("3")
	
	Println("ABC")
}

// =>
// ABC
// 3
// 2
// 1
```

`defer`で複数の処理を登録したい場合、無名関数を使用すれば良い。  
`defer`は関数呼び出しの形にする必要があるため、無名関数の定義の最後にカッコを付ける必要があることに注意。

```go
defer func() {
	Println("3")
	Println("2")
	Println("1")
	Println("0!")
}()	// 関数呼び出しの形にする必要がある
```

### `panic`と`recover`によるランタイムパニック処理
#### `panic`によってランタイムパニックを発生させる
`panic`はランタイムパニック(C言語のセグメンテーション違反のようなもの)を発生させる関数。

```go
// panicの書式
func panic(v interface{})

// panicの使用例
func main() {
	// panic発生時にもdeferは必ず実行される
	defer fmt.Println("END!!!!")

	panic("runtime error!")
	fmt.Println("Hello, World!")
}

// =>
// END!!!!
// panic: runtime error!
// ....エラー詳細....
// ..................
```

#### `recover`によってランタイムパニックによる中断を回復する
`defer`の中で`recover`関数を登録しておくことで、ランタイムパニックから復帰することができる。

```go
/// recoverの書式
func recover() interface{}
// 戻り値...nil:ランタイムパニック未発生, nil以外:ランタイムパニック発生
```

下記コードは、`panic`と`recover`を組み合わせた使用例。

```go
func testRecover(src interface{}) {
	// エラーハンドリング
	defer func() {
		if x:= recover(); x != nil {
			// 発生したpanicの種類によって処理分岐
			switch v := x.(type) {
			case int:
				fmt.Printf("panic: int=%v\n", v)
			case string:
				fmt.Printf("panic: string=%v\n", v)
			default:
				fmt.Printf("panic: unknown error")
			}
		}
	}

	panic(src)
	return
}

func main() {
	testRecover(128)
	testRecover("foo")
	testRecover([...]int{1, 2, 3})
}

// =>
// panic: int=128
// panic: string=foo
// panic: unknown error
```

**NOTE**  
Goにおいては、この手の例外処理は積極的に使用しないほうが良い。  
むしろ`panic`を起こさないように注意したコーディング(防御的プログラミング的なもの?)を心がけることが良しとされているらしい。

### `go`文による並行処理
`go`文は、**ゴルーチン(goroutine)**を生成して、並行処理されるようにランタイムに追加するための機能。

ゴルーチン
: Goが持つ、スレッドよりも小さい、軽量な処理単位。

`go`文では、`defer`文と同様に、関数呼び出し形式の式を受け取る。  
`go [関数呼び出し]`と記述すると、ゴルーチンを新規に生成して`[関数呼び出し]`を実行する。

```go
func sub() {
	for {	// 無限ループ
		fmt.Println("sub loop")
	}
}

func main() {
	go sub()
	for {	// 無限ループ
		fmt.Println("main loop")
	}
}
```

`runtime`パッケージを使用することで、Goのランタイム自身についての情報を参照したり、動作をコントロールできる。

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
	fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
	fmt.Printf("Version: %d\n", runtime.Version())
}
// =>
// NumCPU: 2
// NUmGoroutine: 1
// Version: go1.6
```

- `NumCPU`...CPUのコアの数
- `NumGoroutine`...Goランタイム上で動作しているゴルーチンの個数

### `init`関数
Goのパッケージにおいて、パッケージの初期化を目的にした特殊な関数`init`を、開発者自身で定義できる。  
`init`は、引数と戻り値を持ってはいけない。

`init`関数は、`main`関数の実行前に実行される。すなわち、`init`関数は、プログラムのメインルーチン実行前に、初期化したい何らかの処理を実行するために使用できる。

```go
package main

package (
	"fmt"
)
func init() {
	fmt.Println("init()")
}

func main() {
	fmt.Println("main()")
}

// =>
// init()
// main()
```

`init()`は複数個定義できる。定義した`init()`は、上から順番に実行される。ただし、明確な目的がない限り、`init`関数を分けない方が良い。

```go
package main

package (
	"fmt"
)

var S = ""

func init() {
	S += "A"
}

func init() {
	S += "B"
}

func init() {
	S += "C"
}

func main() {
	fmt.Println("S")
}

// =>
// ABC
```

## 参照型
Goには、参照型と呼ばれる下記の３つの型がある。

- `slice` スライス
- `map` マップ
- `channel` チャネル

### `make`関数の使用方法
参照型の生成には、組み込み関数`make`を使用する。

|呼び出し形式|&nbsp;&nbsp;型`T`|&nbsp;&nbsp;意味|
|---|---|---|
|`make(T, n)`|&nbsp;&nbsp;スライス|&nbsp;&nbsp;要素数と容量が`n`である`T`型のスライスを生成|
|`make(T, n, m)`|&nbsp;&nbsp;スライス|&nbsp;&nbsp;要素数が`n`で容量が`m`である`T`型のスライスを生成|
|`make(T)`|&nbsp;&nbsp;マップ|&nbsp;&nbsp;`T`型のマップを生成|
|`make(T, n)`|&nbsp;&nbsp;マップ|&nbsp;&nbsp;`T`型のマップを、要素数`n`をヒントにして生成|
|`make(T)`|&nbsp;&nbsp;チャネル|&nbsp;&nbsp;バッファ無しの`T`型のチャネルを生成|
|`make(T, n)`|&nbsp;&nbsp;チャネル|&nbsp;&nbsp;バッファサイズ`n`の`T`型のチャネルを生成|

### スライス(slice)
スライスは可変長配列を表現する型。  
スライスには、配列とは異なり、**要素数**と**容量**という概念がある。

要素数(length)
: スライスの生成時に、値を格納するために確保される領域。  
組み込み関数`len()`で取得できる。

容量(capacity)
: スライスの生成時に、後でスライスを拡張する際に使用するための領域。  
組み込み関数`cap()`で取得できる。

```go
// スライス生成の書式
make(型名, 要素数, 容量*)
```

```go
// int型を格納するスライス
var s []int

// 要素数と容量が10であるint型のスライスを生成する
s := make([]int, 10)
fmt.Println(s)
// =>
// [0 0 0 0 0 0 0 0 0 0]

// スライスの使い方
s = make([]float64, 3)
fmt.Println(a)	// => "[0, 0, 0]"
a[0] = 3.14
fmt.Println(a)	// => "[3.14, 0, 0]"
a[1] = 6.28
fmt.Println(a)	// => "[3.14, 6.28, 0]"
fmt.Println(a[0])	// => "3.14"
fmt.Println(a[4])	// 要素数を超えた要素にアクセスしたためランタイムパニック発生

// 要素数8, 容量8のスライス
s = make([]int, 8)
// スライスの要素数を調べる
len(s)	// == 8

// 要素数5, 容量5のスライス
s = make([]int, 5)
// スライスの要素数を調べる
len(s)	// == 5
// スライスの容量を調べる
cap(s)	// == 5

// 要素数5, 容量10のスライス
s = make([]int, 5, 10)
// スライスの要素数を調べる
len(s)	// == 5
// スライスの容量を調べる
cap(s)	// == 10
```

例えば、要素数5, 容量10のスライスは下記のようになる。  
`[n]`によるインデックスで参照・代入できる範囲は0～4までだが、スライスの容量としては10個分のメモリ領域を確保している。

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|

上記のスライスに要素を追加していくと、容量いっぱいまではそのまま残りの空き領域を使う。  
そして、容量がいっぱいになってしまった状態で、更に要素を追加すると、**容量10よりも大きなメモリ領域を確保して、元のスライスのデータを丸ごとコピーする**。  
データのコピーは計算コストが高いため、容量が推測できる場合はなるべくその推測値を設定してスライス生成したほうが良い。

#### リテラルでスライスを生成する
配列やスライスを元にして、新しいスライスを生成するために、**簡易スライス式(simple slice expressions)**という機能がある。

```go
// 要素数5の配列
a := [5]int{1, 2, 3, 4, 5}

// 配列aの要素0から要素1(2-1)までの要素を元にスライスを生成する
s := a[0:2]	// 変数sは[]int型

fmt.Println(s)	// => "[0, 1]"
```

簡易スライス式には下記の記述パターンがある。

|`a := [5]int{1, 2, 3, 4, 5}`|&nbsp;&nbsp;意味|&nbsp;&nbsp;結果|
|----|----|----|
|`a[0:2]`|&nbsp;&nbsp;要素0～1のスライス|&nbsp;&nbsp;`[0, 1]`|
|`a[2:]`|&nbsp;&nbsp;要素2～`len(a)-1`のスライス|&nbsp;&nbsp;`[3, 4, 5]`|
|`a[:4]`|&nbsp;&nbsp;要素0～3のスライス|&nbsp;&nbsp;`[1, 2, 3, 4]`|
|`a[:]`|&nbsp;&nbsp;要素0～`len(a)-1`のスライス|&nbsp;&nbsp;`[1, 2, 3, 4, 5]`|

見て分かるとおり、簡易スライス式の書式は下記の通り。  
簡易スライス式を使って生成したスライスは、生成元の配列の参照していない範囲が容量になる。

```go
配列[開始インデックス:末尾の次のインデックス]
// => 開始インデックス～末尾インデックスのスライス
```

`var a [10]int`のとき、`a[2:4]`は下記のような範囲となる。

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|||&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|&nbsp;&nbsp;-|
|**容量**|||&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|||||


文字列にも簡易スライス式を適用できる。ただしマルチバイト文字列の場合は注意が必要。

```go
s := "ABCDE"[1:3]	// => s == "BC"

// 文字列はバイト列として処理する必要があるため、
// "あ"を3バイト分でカウントする
s = "あいうえお"[3:9]	// => "いう"
```

#### 組み込み関数`append`で要素を追加する
`append`を使うことで、スライスの末尾に要素を追加した新たなスライスを生成できる。  
`append`の戻り値を変数に代入しないとコンパイルエラーとなることに注意。  
また、`append`の2番目以降の引数は可変長引数で、スライスの要素の型に合致する値を任意個指定できる。

```go
// 要素数3のスライス
s := []int{1, 2, 3}

// 4をスライスの末尾に追加
s = append(s, 4)	// s == [1, 2, 3, 4]

// 5, 6, 7をスライスの末尾に追加
s = append(s, 5, 6, 7)	// s == [1, 2, 3, 4, 5, 6, 7]
```

スライスの末尾に、別のスライスの要素を追加することもできる。  
`append()`に渡している第2引数が`s1...`という形式になっていることに注意。

```go
s0 := []int{1, 2, 3}
s1 := []int{4, 5, 6}
s2 := append(s0, s1...)	// s2 == [1, 2, 3, 4, 5, 6]

var b []byte
b = append(b, "あいうえお"...)
b = append(b, "かきくけこ"...)
b = append(b, "さしすせそ"...)
// b == [227 129 130 227 129 132 ...]
```

#### `append`とスライスの容量
要素数0、容量0のスライスを初期値として、`append`で要素を追加しつつ、要素数と容量を確認してみる。  
Goランタイムは、要素数の大きさによって拡張サイズを調整していることが分かる。

```go
// 要素数0,容量0のint型のスライス
s := make([]int, 0, 0)				// 要素数0, 容量0
s = append(s, 1)					// 要素数1, 容量1
s = append(s, []int{2, 3, 4}...)	// 要素数4, 容量4
s = append(s, 5)					// 要素数5, 容量8
s = append(s, 6, 7, 8, 9)			// 要素数9, 容量16
// 要素数が少なめの場合、容量の拡張は倍々で行われる

s1 := make([]int, 1024, 1024)	// 要素数1024, 容量1024
s = append(s, 0)				// 要素数1025, 容量1312
```

#### `copy`によるスライスの一括複製
組み込み関数`copy`を用いて、スライスにスライスの値を一括コピーできる。  
`copy`の使用方法には下記の2種類がある。


- 1番目の引数に指定したスライスを**コピー先**として、2番めの引数に指定したスライスの内容を、コピー先のスライスの先頭から上書きするようにコピーする。  
各々のスライスの要素数は異なっていても良い。

```go
// []T型のスライスsrcを、[]T型のスライスdstにコピーする
copy(dst, src []T) int	// copyの戻り値 == コピーが実行された要素数

s1 := []int{1, 2, 3, 4, 5}
s2 := []int{10, 11}
n := copy(s1, s2)	// n == 2, s1 == [10, 11, 3, 4, 5]
// copyの戻り値 == コピーが実行された要素数

s1 := []int{1, 2, 3, 4, 5}
s2 := []int{10, 11, 12, 13, 14, 15, 16}
n := copy(s1, s2)	// n == 5, s1 == [10, 11, 12, 13, 14]
```

- `[]byte`型のスライスを**コピー先**として、文字列型のデータをコピーする。  
この場合も`append()`と同様に、コピーする単位はバイト単位であり、文字単位ではない。

```go
// string型のスライスsrcを、[]byte型のdstにコピーする
copy(dst []byte, src string) int	// copyの戻り値 == コピーが実行された要素数

b := make([]byte, 9)
n := copy(b, "あいうえお")
fmt.Println(n, b)	// n == 9, b == []byte("あいう")
```

#### 完全スライス式
２つのパラメータを指定する簡易スライス式の他に、３つのパラメータを指定する**完全スライス式(full slice expression)**という記法がある。

完全スライス式では、整数3つを`:`で区切る。  
各々のパラメータは、`0 <= low <= high <= max <= cap(a)`という関係を満たす必要がある。  
簡易スライス式との違いは、`max`の指定によってスライスの容量を指定できるかどうか。

```go
a[low : high : max]
```

##### 配列 `var a [10]int`

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;0|
|**容量=10**|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|

##### 簡易スライス式 `a[2:4]`

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|
|**容量= 8**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|

##### 完全スライス式 `a[2:4:6]`

|**[n]**|&nbsp;&nbsp;[0]|&nbsp;&nbsp;[1]|&nbsp;&nbsp;[2]|&nbsp;&nbsp;[3]|&nbsp;&nbsp;[4]|&nbsp;&nbsp;[5]|&nbsp;&nbsp;[6]|&nbsp;&nbsp;[7]|&nbsp;&nbsp;[8]|&nbsp;&nbsp;[9]|
|---|---|---|---|---|---|---|---|---|---|---|
|**int**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;0|&nbsp;&nbsp;0|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|
|**容量= 4**|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;\*|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|&nbsp;&nbsp;|


#### スライスを`for`文で使う
範囲節による`for`では、スライスを範囲として使用できる。

```go
s := []string{"Apple", "Banana", "Cherry"}

for i, v := range s {
	fmt.Println("[%d] => %s\n", i, v)
}
// =>
// [0] => Apple
// [1] => Banana
// [2] => Cherry
```

範囲節ではない`for`ループ内でスライスの要素数を変化させると、想定外の動作になる可能性がある。  
下記のコードでは、要素数が増え続けるため、`for`の条件式が常に真となってしまう。

```go
s := []string{"Apple", "Banana", "Cherry"}

for i := 0; i < len(s); i++ {
	fmt.Printf("[%d] => %s\n", i, s[i])
	s = append(s, "Melon")
}
// =>
// [0] => Apple
// [1] => Banana
// [2] => Cherry
// [3] => Melon
// [4] => Melon
// [5] => Melon
// ...無限ループ...
```

範囲節の`for`ループでは、ループ開始時の要素数をもとにループ回数を決定している。  
したがって、ループ内でスライスの要素数を増やしても、ループ回数に影響はない。

```go
s := []string{"Apple", "Banana", "Cherry"}

for i, v := range s {
	fmt.Printf("[%d] => %s\n", i, v)
	s = append(s, "Melon")
}
fmt.Println(s)
// =>
// [0] => Apple
// [1] => Banana
// [2] => Cherry
// ["Apple", "Banana", "Cherry", "Melon", "Melon", "Melon"]
```

#### スライスと可変長引数
`fmt.Printf`のような関数は、任意個数の引数を指定できる。  
このような関数の可変長引数を自分で定義するために、Goではスライスを使用する。

関数`fmt.Printf`は次のように定義される。  
1番目の引数にフォーマット引数を取り、2番目以降の引数は`interface{}`型のスライスである変数`a`にまとめられる。

```go
func Printf(format string, a ...interface{}) (n int, err error)
```

関数定義に可変長引数を指定することで、次のように任意個数のint型の値を引数に取る`sum`のような関数が定義できる。

```go
func sum(s ...int) int {
	n := 0
	for _, v := range s {
		n += v
	}
	return n
}

func main() {
	sum(1, 2, 3)		// 16
	sum(1, 2, 3, 4, 5)	// 15
	sum()				// 0
}
```

`s ...int`という引数の定義が、可変長引数のすべての値を`[]int`型のスライスにまとめる意味となる。  
注目すべきは、**任意個数とは0個も含まれる**点。この関数`sum`では要素数0個のスライスでもエラーとならない実装となっているため、0も含まれる。

**NOTE**  
関数における可変長引数は、**引数の末尾に1つのみ定義できる**。

```go
// エラーとなるパターン
func doSomething(a ...string, b bool)	// コンパイルエラー
func doSomething(a ...int, b float64)	// コンパイルエラー
```

#### スライスを可変長引数に代入して関数呼び出しする
前段で定義した関数`sum`に、スライスを使って可変長引数の代わりに渡すことができる。  
引数のスライスの後ろに`...`を付加すると、スライスの要素を可変長引数として展開する。

```go
s := []int{1, 2, 3}
sum(s...)	// 6
```

#### 参照型としてのスライス
そもそも**参照型**とは何か。一言で言うと、C言語などでも存在する、関数に渡すと**参照渡し**となる型のこと。  
スライス、マップ、チャネルは参照型であるため、関数の引数に渡してそれを関数内で変更すると、副作用が発生する。

##### 参照型の特性について確認する
**配列**  
まず、配列型を使った関数`pow`を考える。  
`pow`は、`[3]int`型を引数にとり、配列の各要素を2乗した値に更新したい。しかし、配列を渡した場合は参照渡しとならない。

```go
func pow(a [3]int) {
	for i, v := range a {
		a[i] = v * v
	}
	return
}

func main() {
	// 要素数3の配列
	a := [3]int{1, 2, 3}
	pow(a)
	fmt.Println(a)	// => "[1, 2, 3]"
}
```

**スライス**  
次に、スライスを使った関数`pow`を考える。  
この場合、スライスは参照型だから、期待通り、引数に渡したスライスの各要素が、2乗された値に更新される。

```go
func pow(a []int) {
	for i, v := range a {
		a[i] = v * v
	}
	return
}

func main() {
	// 要素数3のスライス
	a := []int{1, 2, 3}
	pow(a)
	fmt.Println(a)	// => "[1, 4, 9]"
}
```

##### `nil`の値を取りうるかどうか
基本型と値型の違いとして、`nil`を値として取り得るかどうかがある。

- 初期化をせずに**配列型**の変数を定義した場合、そのタイミングで`[3]int`に対応したメモリ領域が確保され、さらに要素の型の初期値によって要素が埋められる。
- 初期化をせずに**スライス型**の変数を定義した場合、スライスは`nil`が初期値となる。(いわゆるnull参照)

```go
var (
	a [3]int
	s []int
)
fmt.Println(a)	// => "[0, 0, 0]"
fmt.Println(s == nil)	// => "true"
```

##### スライス作成元の配列
配列を元にスライスを作成したとき、そのスライスは、作成元の配列を参照している。  
したがって、配列の値を変更したらスライスの値も変化したように見え、その逆も然り。

```go
a := [5]int{1, 2, 3, 4, 5}
s := a[0:2]	// s == [1, 2]
len(s)		// 2
cap(s)		// 5
a[1] = 0	// s == [1, 0]
```

では、`append()`関数などによってスライスの容量が拡張されたときはどうなるのか?  
その場合、スライスは作成元の配列とは全く異なるメモリ領域を確保し、配列の値をそこにコピーし、そのメモリ領域が新しいスライスとなる。
すなわち、下記コードのとおり、スライスが作成元のメモリ領域を参照しているとは限らない場合がある。

```go
// s0とs1が同じ配列データを共有するかは不定
s1 := append(s0, x)
```

### マップ(map)
マップは、いわゆる**連想配列**。  
関数型と参照型以外の、「任意の型のキーと任意の型の要素のペアを保持できる特殊な型」といえる。  
Goのマップを表す型は、`map[キーの型]要素の型`という書式で定義する。

```go
// 「int型のキーとstring型の値」を保持するマップ
var m map[int]string
```

マップも、スライスと同様に、関数`make`を使って生成する。  
マップは、一意に定まるキーと任意の要素の組み合わせで構成される。したがって、キーの値が重複する代入では、要素の値は上書きされる。

```go
m := make(map[int]string)

m[1] = "US"
m[81] = "UK"
m[81] = "Japan"
m[86] = "China"

fmt.Println(m)
// =>
// map[1:US 81:Japan 86:China]
```

**NOTE**  
キーを浮動小数点数にする場合は注意が必要。  
というのも、例えば`float64`型などの精度の上限によって値が丸められて同じ数値になってしまった場合、同じキーとして扱われてしまう。

#### マップのリテラル
マップにも、キーと要素のペアをまとめて生成するためのリテラル「`キーの値: 要素の値`」が有る。

```go
// マップリテラルで各要素を生成している
m := map[int]string {1: "Taro", 2: "Hanako", 3: "Jiro"}
fmt.Println(m)
// =>
// map[3:Jiro 1:Taro 2:Hanako]

// 下記のように改行も可能(末尾のカンマは必須)
m = map[int]string {
	1: "Taro",
	2: "Hanako",
	3: "Jiro",	// カンマは必須
}

// スライスをもたせることも可能
m = map[int][]int {
	1: []int{1},
	2: []int{1, 2},
	3: []int{1, 2, 3},	// カンマは必須
}
// => map[1:[1], 2:[1, 2], 3:[1, 2, 3]]

// []int{}型は下記のように書くことも可能
m = map[int][]int {
	1: {1},
	2: {1, 2},
	3: {1, 2, 3},	// カンマは必須
}

// マップを入れ子にすることも可能
m = map[int]map[float64]string {
	1: {3.14: "円周率"},
}
```

#### マップの要素を参照する
マップの要素を参照するには、配列と同じように`[キーの値]`とする。  

```go
m := map[int]{1: "A", 2: "B", 3: "C"}
s := m[1]	// "A"
s := m[9]	// ""
```

**指定したキーの値に対応する要素がないときは、型のデフォルト値が返される。**  
したがって、全く無関係のキーを誤って指定しても、それを検知しにくいことに注意すべき。  
もしくは、マップへの要素を参照した際は、その第2戻り値を確認することで、要素の有無が分かる。  

- 第2戻り値が`true`・・・要素が存在する
- 第2戻り値が`false`・・・要素が存在しない

**NOTE**  
このときの第2戻り値の名前は、特別な理由がなければ`ok`とすべき。(慣習的なもの)

```go
m := map[int]string{1: "A", 2: "B", 3: "C"}

s, ok := m[1]	// s == "A", ok == true
s, ok := m[9]	// s == "",  ok == false
_, ok := m[3]	// ok == true

if _, ok := m[1]; ok {
	// m[1]の要素が存在するときの処理
}
```

**NOTE**  
マップの要素型がスライス型の場合、要素の存在チェックを下記のように行ってはいけない。  
必ず第2戻り値を使うこと。

```go
m := map[int][]int {
	1: {1},
	2: {1, 2},
	3: {1, 2, 3},
}

s := m[1]
// **問題がある書き方**
// 下記の区別がつかない
// - m[1]に対応する要素が無くてnilの場合と、
// - m[1]に対応するスライスはあるが、その中のスライスが値を持っておらずnilの場合
if s != nil {
	// 中略
}
```

#### `for`の範囲節にマップを使う
マップも、スライスと同様に、`for`の範囲節に使用して、繰り返し処理できる。

**NOTE**  
マップを範囲節に指定した場合、キーが処理される順序は保証されないことに注意すべき。  
実行環境によっても異なる可能性があることに注意。

```go
m := map[int]string {
	1: "Apple",
	2: "Banana",
	3: "Cherry",
}

for k, v := range m {
	fmt.Printf("%d => %s\n", k, v)
}
// =>
// 1 => Apple
// 2 => Banana
// 3 => Cherry
```

#### まっぷの要素数を`len()`で取得する
マップの要素数は、スライスと同様に`len()`で取得できる。

```go
m := map[int]{1: "A", 2: "B", 3: "C"}
len(m)	// 3
m[4] = "D"
m[5] = "E"
len(m)	// 5
```

**NOTE**  
当然ながら、マップに`cap()`は使用できない。なぜなら、マップにスライスの容量に該当する概念はないため。  
内部的に確保しているメモリ領域は必ず有るだろうが、それをユーザに見せることはないため。

#### `delete()`でマップの要素を削除する
マップの要素は、組み込み関数`delete()`を使って削除できる。  
書式は「`delete(マップ, キーの値)`」。  
`delete()`で指定したキーの値に該当する要素がない場合、`delete()`は何もしない。

```go
m := map[int]{1: "A", 2: "B", 3: "C"}

delete(m, 2)	// マップmのキー2の要素を削除する

fmt.Println(m)

// =>
// map[1:A 3:C]
```


#### `make()`によるマップ生成時に要素数を指定する
組み込み関数`make()`を使ってマップを生成する場合、2番めの引数に**要素数に対応した初期スペース**を整数で指定できる。  
これが指定されると、これをヒントにGoランタイムが最適なメモリ領域を確保する。  
要素数が膨大なマップの場合はパフォーマンスに影響するが、小さい場合は指定しなくて良い。

```go
// map[int]string型のマップを初期スペース100で初期化
m := make(map[int]string, 100)
```

### チャネル(channel)
チャネルとは、**ゴルーチン間でのデータの受け渡しを行うためのGo特有のデータ構造**で、キューのようなデータ構造。  
したがって、ゴルーチンを使用する場合にのみ、チャネルを使用することになる。

ゴルーチン
: 前述の通り`go`文を用いて生成できる、Go特有の、スレッドよりも軽量な処理単位のこと。

#### チャネルの型名
チャネルの型は、「`chan データ型`」と記述する。  
型名の内側にスペースが入るため、見た目に違和感がある。


```go
// int型のチャネルch
var ch chan int
```

##### チャネルのサブタイプ
チャネルにはサブタイプがある。  
サブチャネルには双方向、受信専用、送信専用がある。

```go
// 送受信用(双方向)チャネル
var ch1 chan int

// 受信専用チャネル
var ch2 <-chan int

// 送信専用チャネル
var ch3 chan<- int
```

チャネルのサブタイプにおいて、異なるもの同士の代入が可能な場合がある。  
送受信用(双方向)チャネルの変数は、受信用または送信用の変数に代入できるが、反対向きの代入はできない。

```go
// 異なるサブタイプ同士の代入が可能
var (
	ch_in_out chan int
	ch_in <-chan int
	ch_out chan<- int
)

ch_in = ch_in_out
ch_out = ch_in_out
```

##### チャネルの生成と送受信
チャネルも、スライスやマップと同様に、組み込み関数`make`を使って生成する。  
`make`へ2番めの引数を渡すと、チャネルのバッファサイズを指定できる。指定されてない場合、チャネルのバッファサイズは0になる。

```go
// バッファサイズ0のチャネル
ch := make(chan int)

/// バッファサイズ8のチャネル
ch := make(chan int, 8)
```

チャネルは、キューの性質を備えるデータ構造。チャネルのバッファとは、このキューを格納する領域で、バッファサイズとはこのキューのサイズを意味する。  
キューはFIFO(先入れ先出し)であり、キューに挿入された順番にデータを取得できる。Goにおけるチャネルも、FIFOの性質が有る。

{{<figure src="go-channel.svg" alt="Goのチャネル" align="aligncenter" width="500" caption="Goのチャネル">}}

チャネルが保持するデータに対する操作は、「送信」か「受信」の2パターンのみ。  
送受信共に、演算子`<-`を使用する。

送信
: チャネルに対して、データを送る。

受信
: 他のゴルーチンがチャネルへデータを送信するのを待つ。そして、チャネルに入ったデータを受け取る。

```go
// バッファサイズ10のチャネル
ch := make(chan int, 10)

// チャネルchに整数5を送信
ch <- 5
// チャネルから整数値を受信
i := <-ch
```

`ch <- 5`はチャネルに整数5を送信する処理で、`i := <-ch`はチャネルからデータを受信する処理。

##### チャネルとゴルーチン
チャネルは、複数のゴルーチン間で安全にデータを共有するための仕組み。  
これを実際に使った例を下記コードに示す。(ただしこれは不完全)

```go
func main() {
	ch := make(chan int)
	// チャネルから受信から内容を出力
	fmt.Prinln(<-ch)
}
```

上記を実行するとランタイムエラー`fatal error: ass goroutines are asleep - deadloak!`が発生する。  
すなわち、「上記コードの`ch`にデータを送信するゴルーチンが動いておらず、`ch`が永遠に待ち続けてしまう」ことがデッドロックとして検知される。

下記コードでは、関数`main`からゴルーチンを生成して、チャネルを共有しつつ処理を行う。  
`go`の使用方法は「`go`文による並行処理」を参照。

```go
package main

import (
	"fmt"
)

func reveiver(ch <-chan int) {
	for {
		// チャネルからデータを受信してiに代入する
		i := <-ch
		fmt.Println(i)
	}
}
func main() {
	// バッファサイズ0のチャネルを作成する
	ch := make(chan int)

	// チャネルch受信して表示するゴルーチンを生成する
	go reveiver(ch)

	i := 0
	for i < 1000 {
		// チャネルに整数値iを送る
		ch <- i
		i++
	}
}
// =>
// 0
// 1
// 2
// 3
// 4
// 5
// ...
```

上記コードの処理を説明する。

1. 関数`main`は、`go`文でゴルーチンを生成し、関数`receiver`への引数を使ってチャネル`ch`を共有する。
1. 関数`main`側のゴルーチン(`main`関数自体)では、0始まりの整数値をインクリメントさせつつチャネルに送信する。
1. 関数`receiver`側のゴルーチンは、データを受信して、それを標準出力に出力し続ける。  
   関数定義の引数の型指定で、引数で受け取るチャネルの型を`<-chan int`型に限定する。

{{<mermaid align="center">}}
sequenceDiagram;
	participant main as main-goroutine
	participant ch as channel
	participant receiver as receiver-goroutine

	activate main
	main ->> ch: ch := make(chan int)
	main -x+ receiver: go receiver(ch)
	main ->> main: i := 0
	loop 無限ループ
		main ->> ch: ch <- i
		main ->> main: i++
	end

	loop 無限ループ
		receiver ->> ch: i := <-ch
		receiver ->> receiver: Prinln(i)
    end

	deactivate receiver
	deactivate main
{{</mermaid>}}

バッファサイズを設定したチャネルを使用した場合、ゴルーチンが停止するかどうかはチャネルのバッファサイズによる。  
下記のコードで分かるとおり、バッファサイズに収まる限りデータは正常に格納されてゴルーチンは停止しない。  
しかし、バッファに空きがないチャネルへの送信が発生した場合、デッドロック発生する。

```go
ch := make(chan rune, 3)

c <- 'a'	// 'a'
c <- 'b'	// 'a', 'b'
c <- 'c'	// 'a', 'b', 'c'
c <- 'd'	// サイズ超過によりデッドロック発生と判断される
```

ゴルーチンがチャネル操作によって停止する条件は下記の2通り。

- バッファサイズが0またはバッファ内が空のチャネルから**受信**する
- バッファサイズが0またはバッファ内が満杯のチャネルへ**送信**する

##### チャネルにおける`len`と`cap`
###### `len`関数
チャネルに対する組み込み関数`len`は、**チャネルのバッファ内に貯められているデータの個数**を返す。

```go
ch := make(chan string, 3)

ch <- "Apple"
len(ch)	// == 1
ch <- "Banana"
ch <- "Cherry"
len(ch)	// == 3
```

`len`チャネルのバッファ内の状態を動的に取得できるとしても、下記のコードはアトミックでないため、記述してはいけない。
すなわち、`if len(ch) > 0`が成り立って`if`節の中に入ったとしても、その直後に他のゴルーチンがチャネル`ch`からデータを受信してしまうと、`i := ch`の時点では`len(ch) > 0`が成り立たなくなっている可能性がある。

```go
if len(ch) > 0 {
	i := ch	//	この瞬間len(ch) > 0 は保証されない
}
```

###### `cap`関数
チャネルに対する組み込み関数`cap`は、チャネルのバッファサイズ。  
ただし、一度生成したチャネルのバッファサイズは変動しないため、取得したい場面は限られる。

```go
ch := make(chan string)
cap(ch)	// == 0

ch := make(chan string, 3)
cap(ch)	// == 3
```

##### `close`関数でチャネルをクローズする
チャネルは**クローズ(closed**という状態を持っている。`make`で生成したチャネルはオープンされた状態から始まるが、これを明示的にクローズ状態に変更するには組み込み関数`close`を使用する。

指定したチャネルをクローズする書式は「`close(チャネル)`」。

- **NOTE**  
  - クローズされたチャネルに対してデータの**送信**を行うと、ランタイムパニックが発生する。
  - クローズされたチャネルに対してデータの**受信**を行うと、バッファにデータがまだ溜まっていたら問題なく受信でき、既にチャネルが空ならチャネルの初期値を受信できる。

チャネルのクローズ判定は、第2戻り値によって行う。  

- 第2戻り値の意味
  - `false`:チャネルのバッファ内が空 and クローズされた状態
  - `true`:チャネルのバッファ内にデータがある or クローズされていない状態

```go
ch := make(chan int)
close(ch)
i, ok := <-ch	// i == 0, ok ==false


ch := make(chan int, 3)

ch <- 1
ch <- 2
ch <- 3

close(ch)

var (
	i int
	ok bool
)
i, ok = <-ch	// i == 1, ok == true
i, ok = <-ch	// i == 2, ok == true
i, ok = <-ch	// i == 3, ok == true
i, ok = <-ch	// i == 0, ok == false
```

##### ゴルーチンと`close`の実例
ゴルーチンを使用する際に、`close`を使用すると下記コードのような挙動となる。仕組みは上述のとおり。

```go
package main

import (
	"fmt"
	"time"
)


// receiveは、チャネルchから整数値を受信して表示する
func receive(name string, ch <- chan int) {
	for {	// 無限ループ
		i, ok := <-ch
		if ok == false {
			// 受信できなくなったため終了
			break
		}
		fmt.Println(name, i)
	}
}

func main() {
	ch := make(chan int, 20)

	// ゴルーチンを3つ生成
	go receive("1st goroutine", ch)
	go receive("2nd goroutine", ch)
	go receive("3rd goroutine", ch)

	// チャネルに整数値0~99を送信する
	for i := 0; i < 100; i++ {
		ch <- i
	}

	// チャネルをクローズする
	close(ch)

	// ゴルーチンの完了を3秒待つ(簡略的な処理)
	time.Sleep(3 * time.Second)
}

// =>
// 3rd goroutine 0
// 3rd goroutine 3
// 3rd goroutine 4
// 3rd goroutine 5
// 3rd goroutine 6
// 3rd goroutine 7
// 3rd goroutine 8
// ...中略...
// 3rd goroutine 93
// 3rd goroutine 94
// 3rd goroutine 95
// 1st goroutine 79
// 1st goroutine 97
// 1st goroutine 98
// 1st goroutine 99
// 3rd goroutine 96
// 2nd goroutine 88
```

##### チャネルを`for`と組み合わせる
範囲節の`for`において、チャネルを使用できる。下記コードのようにすると、チャネルからデータを延々と受信し続けることができる。  
`a := range ch`の形式で、チャネルから受信したデータが変数`a`に代入される。  
しかし、この方法には、チャネルがクローズされたかどうかを検出するタイミングが得られないという欠点がある。

```go
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3

for i := range ch {
	fmt.Println(i)
}

// =>
// 1
// 2
// 3
// fatal error: all goroutines are asleep - deadlock!
// 以下略
```

##### 制御構文`select`で複数のチャネルをコントロールする
下記のように、チャネル`ch1`、`ch2`と、チャネルが内包するデータ`e1`、`e2`について考える。  
チャネル`ch1`からデータが受信できない場合、この処理の流れを実行しているゴルーチン(`main`)は処理を停止する。
したがって、チャネル`ch2`の受信処理には、いつまで立ってもたどり着けない可能性がある。

```go
e1 := <-ch1	// 受信街でゴルーチンが停止
e2 := <-ch2
```

上記コードのように、1つの処理の流れの中で複数のチャネルを処理しようとする場合、チャネルの状態に応じてゴルーチンが停止する問題をどうにかして回避する必要がある。  
そこで、`select`文を使用する。これを使うと、複数チャネルの送受信処理を、ゴルーチンを停止させずに扱える。

```go
select {
case e1 := <-ch1
	// ch1からの受信が成功した場合の処理
case e2 := <-ch2
	// ch2からの受信が成功した場合の処理
default:
	// 上記条件のいずれも成立しなかった場合の処理
}
```

`select`文の全ての`case`節は、必ずチャネルへの処理を記述する必要がある。チャネルへの処理には、下記の種類がある。

```go
// ch1から受信
case e1 := <-ch1:

// ch2から受信(2変数で)
case e2, ok := <-ch2:

// ch3へe3を送信
case ch3 <- e3:

// ch5から受信したデータをch4へ送信
case ch4 <- (<-5):
```

`select`文は、`switch`文とは異なり、各`case`節を**ランダム**に選択して処理する。
(ただし`default`はすべての`case`が成立しない場合にのみ遷移する。)  
これは、最初の`case`ばかり処理されてそれ以降の`case`が処理されない問題を回避するための仕様。  
下記コードを実際に実行してみると、実行のたびにランダムに`case`が選択されている事が分かる。

```go
ch1 := make(chan int, 1)
ch2 := make(chan int, 1)
ch3 := make(chan int, 1)

ch1 <- 1
ch2 <- 2

// 複数のcaseが成立する場合はランダムに選択される
select {
case <-ch1:
	fmt.Println("ch1から受信")
case <-ch2:
	fmt.Println("ch2から受信")
case ch3 <- 3:
	fmt.Println("3をch3へ送信")
default:
	fmt.Println("ここへは到達しない")
}

// =>
// $ go run test.go
// ch2から受信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// ch2から受信
// $ go run test.go
// ch2から受信
// $ go run test.go
// ch1から受信
// $ go run test.go
// 3をch3へ送信
// $ go run test.go
// 3をch3へ送信
```

複数のチャネルと複数のゴルーチンに`select`文を組み合わせたプログラムを下記に示す。  
このプログラムは、下記を実行している。

1. 整数値1～99をch1に送信する
1. ch1からデータを受信し、それを2倍したらch2に送信する
1. ch2からデータを受信し、それを-1したらch3に送信する
1. ch3からデータを受信し、それを表示する

```go
ch1 := make(chan int)
ch2 := make(chan int)
ch3 := make(chan int)

// ch1から受信した整数を2倍してch2へ送信する
go func() {
	for {
		i := <-ch1
		ch2 <- (i * 2)
	}
}()

// ch2から受信した整数を-1してch3へ送信する
go func() {
	for {
		i := <-ch2
		ch3 <- (i - 1)
	}
}()

n := 1
LOOP:
for {
	select {
	// 整数をインクリメントさせつつch1へ送信する
	case ch1 <- n:
		n++
	// ch3から受信した値を表示する
	case i := <-ch3:
		fmt.Println("received", i)
	// 上記caseの送受信が失敗したら実行
	default:
		// nが100以上になったらループを抜ける
		if n > 100 {
			break LOOP
		}
	}
}

// =>
// received 1
// received 3
// received 5
// received 7
// received 9
// received 11
// received 13
// received 15
// ...以下略...
```

# 構造体とインターフェース
## ポインタ
Goにも、C言語でいう**ポインタ**がある。

### ポインタを定義する
ポインタ型は、`*int`のようにポインタを使って参照・走査する方の前に「`*`」をつけることで定義できる。  
`*int`は`int`型のポインタ型、`*[3]float64`は`[3]float64`型のポインタ型になる。  
また、定義のみ行ったポインタ型の変数の初期値は`nil`となり、参照型と同じように振る舞う。

```go
var p *int
fmt.Println(p == nil)	// => "true"
```

「ポインタのポインタ」は、C言語と同様に「`*`」を重ねて書くことで定義できる。

```go
var pp **int
var ppp ***int
```

参照型に対しても、そのポインタ型を定義できる。

```go
var (
	s *[]string
	m *map[int]rune
	ch *chan int
)
```

### アドレス演算子とデリファレンス
アドレス演算子`&`を使って、任意の型からそのポインタ型を生成できる。

```go
var i int
p := &i
fmt.Printf("%T\n", p)	// "*int"
pp := &p
fmt.Printf("%T\n", pp)	// "**int"
```

変数に演算子`*`を使って、C言語と同様に、デリファレンスできる。

```go
var i int
p := &i
i = 5
fmt.Println(*p)	// => "5"
*p = 10
fmt.Println(i)	// => "10"
```

配列型のリテラルと`&`を組み合わせて、例えば`[3]int`型の配列を指し示すポインタを定義することが可能。

```go
func pow(p *[3]int) {
	for i := 0; i < 3; i++ {
		// 各要素を累乗する
		(*p)[i] = (*p)[i] * (*p)[i]
	}
}

func main() {
	// 変数pは*[3]int型
	p := &int{1, 2, 3}
	pow(p)
	fmt.Println(p)	// => "&[1, 2, 3]"
}
```

### 配列のポインタ型はデリファレンス(`*`)不要の場合がある
C言語では、配列のポインタ型変数から配列の各要素にアクセスするには、`(*p)[i]`のようにデリファレンスを明示的に行う必要がある。  
しかし、Goにおいては、配列のポインタ型のデリファレンスについて簡潔に書くための特別な方法がある。
すなわち、**配列に対するデリファレンスを省略できる**。

```go
p := &[3]{1, 2, 3}
// C言語ライクな記述方法
fmt.Println((*p)[0])	// => "1"

// Goにおける特別な記述方法(配列には*が不要)
fmt.Println(p[0])	// => "1"

// *を省略した記述方法
a := [3]string{"Apple", "Banana", "Cherry"}
p := &a
fmt.Println(a[1])	// "Banana"
fmt.Println(p[1])	// "Banana"
p[2] = "Grape"
fmt.Println(a[2])	// "Grape"
fmt.Println(p[2])	// "Grape"

// len()やcap()に対しても*を省略できる
p := &[3]int{1, 2, 3}
fmt.Println(len(p))	// => "3"
fmt.Println(cap(p))	// => "3"
fmt.Println(p[0:2])	// => "[1, 2]"

// 範囲説によるforにおけるrageにおいても*を省略できる
p := &[3]string{"Apple", "Banana", "Cherry"}
for i, v := range p {
	fmt.Println(i, v)
}
// =>
// 0 Apple
// 1 Banana
// 2 Cherry
```

### アドレスを確認する
C言語と同様に、`Printf`で`%p`フォーマット指定子を使用して、ポインタのアドレスを確認できる。

```go
i := 5
ip := &i
fmt.Printf("type=%T, address=%p\n", ip, ip)
// =>
// type=*int, address=0xc82000a380
```

### 文字列(`string`)型のポインタに対する特殊な扱い
Goにおいては、`string`型のポインタをとるのは特に問題無い。  
しかし、**文字列の部分参照(例:`s[0]`)をポインタ参照するとコンパイルエラーが発生する**。  
これは、文字列が不変（イミュータブル）であることが原因。つまり、文字列を構成する`byte`型のポインタを定義できてしまうと、その参照先の文字列の本体を破壊してしまい、イミュータブルでなくなってしまう。  

```go
s := "ABC"
s[0]	// 文字列のインデックス参照(byte型)

&s		// 文字列型のポインタ(問題無い)
&s[0]	// コンパイルエラー // connot take the address of s[0]
```

GoとC言語の文字列には大きな違いが有るため、これを覚えておかないと文字列操作を誤る可能性が高い。
具体的には下記の違いがある。

1. Goの文字列はイミュータブルのため、文字列の変換を多く実施すると、途中の文字列を全て生成するため、効率が落ちる。
1. `string`型の値を変数へ再代入したり、関数の引数に渡した場合でも、文字列の実体が別のメモリ領域にコピーされない。

**NOTE**  
Goでは、文字列を効率的に操作するために`bytes`パッケージを使用する。

```go
func printString(s string) {
	fmt.Println(s)
}

func main() {
	s := "Hello, World!"
	printString(s)	// 文字列の実体のコピー処理は発生しない
}
```

```go
// 非常に効率の悪い処理の例
s := ""
for _, v := range []string{"A", "B", "C"} {
	s += v
}
s	// == "ABC"
```

## 構造体
Goにおける構造体は、C言語と同様に、データと手続きを一体化するためのデータ構造のこと。  
Goでは、構造体を、Javaなどにおけるクラスやオブジェクトのような目的で使用することになる。  
ちなみに、後述する「インターフェース」もGoの構造体に柔軟性を与えるために使用される。

### `type`で型定義する
構造体では、予約語`type`を使用して、任意の既存の型に対してエイリアス(別名)を定義する。そこで、まずは`type`による型定義の使用方法について説明する。
書式は「`type 定義する型 既存の型`」となる。

```go
type MyInt int

// MyInt型の変数n1を定義(初期値5)
var n1 MyInt = 5

// 変数n2に、int型のリテラル7をMyInt型に型変換して代入
n2 := MyInt(7)

fmt.Println(n1)	// => 5
fmt.Println(n2)	// => 7

// typeによる様々なエイリアスの例
// type(...)の形で、まとめて型名を定義できる
type (
	IntPair [2]int
	Strings []string
	AreaMap map[string][2]float64
	IntsChannel chan []int
)

pair := IntPair{1, 2}	// [2]int{1, 2}
strs := Strings{"Apple", "Banana", "Cherry"}	// []string
amap := AreaMap{"Tokyo", {35.6789, 123.456}}	// map[string][2]float64
ich := map(IntsChannel)	// chan []int

// 関数型にエイリアスを定義する事もできる
// 型名で明確な意味付けをする
type Callback func(i int) int

func Sum(ints []int, callback Callback) int {
	var sum int
	// 引数intsの各要素を足す => 15
	for _, i := range ints {
		sum += i
	}
	// int型の引数を取ってint型の戻り値返すコールバック関数をコール
	// callback(15) => 15 * 2 => 30
	return callback(sum)
}

func main() {
	n := Sum(
		[]int{1, 2, 3, 4, 5},
		func(i int) int {
			return i * 2
		},
	)
	// n == 30
}
```

#### エイリアス型の互換性
型の互換性については注意が必要。  
例えば、下記の通りに定義した型`T0`と型`T1`はいずれも`int`型へのエイリアス。  
このとき、型`T0`と型`T1`には互換性がない。つまり、同じ`int`型のエイリアスだが、全く別の型として認識される。

```go
type T0 int
type T1 int

t0 := T0(5)		// t0 == 5
i0 := T1(t0)	// i0 == 5

t1 := T1(8)		// t1 == 8
i2 := int(t1)	// i1 == 8

t0 = t1	// コンパイルエラー
```

### 構造体の定義
構造体を使用する前には、前述の通り`type`と組み合わせて新しい型を定義することになる。  
構造体は「`struct { フィールドの定義 }`」によって囲われた範囲で定義する。  
構造体定義と型定義の順番は、必ず「`struct`で定義された構造体に対して、`type`を使って新しい型名を与える」である必要がある。

`struct`の中には、任意の型を持つ「フィールド(field)」を任意の数だけ並べることができる。  
次の例に示す`Point`型では、`int`型の変数`X`と変数`Y`をフィールドに持つ。

```go
type Point struct {
	X int
	Y int
}

// 異なる定義方法
type Point struct {
	X, Y int
}
```

構造体のフィールドにアクセスするには、C言語と同様に`.`を用いる。

```go
var pt Point
pt.X	// 0
pt.Y	// 0

// 構造体のフィールドへ値を代入する
pt.X = 10
pt.Y = 8

// 構造体のフィールドを参照する
pt.X	// 10
pt.Y	// 8
```

### 複合リテラル
構造体型に書くフィールドの初期値を指定子つつ構造体を生成するための方法として「複合リテラル」が用意されている。
`{}`で囲んだ中に各フィールドの初期値を列挙して、それを構造体の変数に代入できる。初期値を並べる順番は、フィールドが定義された順序と同じ。

```go
pt := Point {1, 2}
pt.X	// 1
pt.Y	// 2
```

構造体を各フィールドの初期値を上記のように指定して生成する書き方は、フィールドの定義順序を意識せざるを得ないため、使い勝手が悪い。  
そこで、他言語のラベル付き引数のように「`フィールド: 値`」と記述することで、順序を気にせず初期値を与えることができる。  
また、任意の一部のフィールドのみ初期化することも可能となる。この場合、未初期化状態のフィールドは、その型の初期値が入る。

```go
pt := Point{X: 1, Y: 2}
pt.X	// 1
pt.Y	// 2

pt = Point{Y: 28}
pt.X	// 0
pt.Y	// 28
```




## インターフェース

