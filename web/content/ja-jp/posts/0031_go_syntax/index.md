---
title: "Go言語入門(基本構文)"
date:    2019-03-31T14:00:00+09:00
lastmod: 2019-03-31T14:00:00+09:00
draft: false
tags: ["Go", "Golang"]
categories: ["Notes"]
authors:
- otaon
---

# 目的
Go言語の基本構文を残す。

# 参考文献
- [スターティング Go言語](https://www.shoeisha.co.jp/book/detail/9784798142418)

# 基本構文
## パッケージ(`package`)・インポート(`import`)について
下記記事を参照。

 [Go言語入門(環境構築・プログラム作成・パッケージ作成・実行・テスト実行)]({{<ref "/posts/0030_go_tutorial/index.md" >}})

## コメント
C言語と同じコメント形式(`//` or `/* */`)を使用できる。後者は入れ子不可能。

## 文構造
Goでは、各々の文はセミコロン(`;`)によって区切られる。  
ただし、Goは<u>全てのセミコロンが省略できる</u>。  

```go
func main() {
	fmt.Println("Hello, World!")
}
```

上記のコードは、コンパイル時に文末にセミコロンが自動的に挿入され、下記のコードとして扱われる。

```go
func main() {
	fmt.Println("Hello, World!");
}
```

**NOTE**  
基本的に、<u>文末判定は行ごとに行われると考えて良い。</u>したがって、下記のコードはコンパイルエラーとなる。

```go
a := [3]string{
	"foo",
	"bar",
	"baz"	// 行末に;が挿入されてしまう
	}
```

これを防ぐには、下記のように末尾要素の後ろにも`,`をつけて、文末でない事を明示すべき。

```go
a := [3]string{
	"foo",
	"bar",
	"baz",	// 文末と判断されず;は挿入されない
	}
```

## 定義済み識別子
下記の定義済み識別子は、変数名や関数名に使用できるが、混乱のもとになるため避けること。

| 識別子の種類 | 識別子 |
|:--------------:|--------|
| 型 | `bool` `byte` `complex64` `complex128` `error` `float32` `float64` `int` `int8` `int16` `int32` `int64` `rune` `string` `uint` `uint8` `uint16` `uint32` `uint64` `uintptr` |
| 定数 | `true` `false` `iota` |
| ゼロ値 | `nil` |
| 関数 | `append` `cap` `close` `complex` `copy` `delete` `imag` `len` `make` `new` `panic` `print` `println` `real` `recover` |

## 出力関数
### `fmt.Println()`
文字列の最後に改行を付加した文字列を標準出力に出力する。

```go
fmt.Println("Hello, Golang!")	// => "Hello, Golang!"
```

複数の引数を渡した場合、各々の文字列をスペースで区切って1行で表示する。

```go
fmt.Println("Hello" "Golang" "!")	// => "Hello Golang !"
```

### `fmt.Printf()`
書式指定子を含んだフォーマット文字列と、可変長引数を渡すと、生成した文字列を標準出力に出力する。

```go
fmt.Printf("数値=%d\n", 5)	// => "数値=5"
```

```go
fmt.Printf("10進数=%d 2進数=%b 8進数=%o 16進数=%x\n", 17, 17, 17, 17)
// => "10進数=17 2進数=10001 8進数=21 16進数=11"
```

可変長引数の個数に過不足がある場合、それを下記のように文字列中で知らせる。

```go
fmt.Printf("%d年%d月%d日\n", 2015, 12)
// => "2015年12月%!d(MISSING)日"

fmt.Printf("%d年%d月%d日\n", 2015, 12, 25, 17)
// => "2015年12月25日%!(EXTRA int=17)"
```

Goのデバッグで有用な書式指定子として`%v`, `%#v`, `%T`がある。

```go
// %v 様々な型のデータを埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列=Golang 配列=[1 2 3]"

// %#v Goのリテラル表現でデータを埋め込む
fmt.Printf("数値=%#v 文字列=%#v 配列=%#v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列="Golang" 配列=[3]int{1 ,2, 3}"

// %T 型情報を埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=int 文字列=string 配列=[3]int"
```

### `print()`, `println()`
組み込み関数として`print()`と`println()`がある。これらは、与えられた文字列を**標準エラー出力**に出力する。

## 変数定義・変数への代入
### 明示的な変数定義
明示的な変数定義の方法を示す。  
見て分かるとおり、`var 変数名　型名`の順番で定義する。  
また、複数の変数定義をまとめて行えるようになっている。

```go
// 明示的な定義
var a int

// int型の変数x, y, zをまとめて定義する
var x, y, z int

// 異なる型の変数x, y, nameをまとめて定義する
var (
	x, y int
	name string
)
```

### 代入
定義した変数に値を代入する方法は下記の通り。  
代入も、複数個の変数にまとめて代入する構文が用意されている。

```go
// 変数への代入
a = 5

// 複数個の変数に複数個の値をまとめて代入する
x, y = 1, 2

// Error: 異なる個数の代入はコンパイルエラーとなる
x, y, z = 1, 2
```

### 暗黙的な定義(推奨)
演算子`:=`を使用することで、型指定なしで変数が定期可能。  
この場合、右辺に記述した式の型が、左辺の変数の型として推論される。  
可能な限り、この方法での変数定義をすること。

```go
i := 3	// int型の変数iに整数3を代入する
b := true	// bool型の変数bに真偽値trueを代入する
f := 3.14	// float64型の変数fに実数3.14を代入する
s := "abc"	// string型の変数sに文字列"abc"を代入する

func one() int {
	return 1
}
n := one()	// int型の変数nに整数1を代入する
```

**NOTE**  
明示的な定義、暗黙的な定義は、当然ながら同一の変数に対しては**ただ1回のみ**使用できる。  
2回目以降の定義の箇所でコンパイルエラーとなる。

**NOTE**  
`var a = 1`と記述することで、変則的だが`var`を使った暗黙的な定義も可能。  
しかし、簡潔さの観点から`:=`のほうが好ましい。

### 変数のスコープ
Goにおける変数は、定義位置により2種類に分かれる。

ローカル変数
: 関数定義の中に定義された変数。  
同一のパッケージ変数がある場合、そのパッケージ変数をシャドウイングする(C言語と同様)。

パッケージ変数
: 関数定義の外に定義された変数。  
パッケージ変数は、プログラム全体で1つの値が共有される(C言語のグローバル変数と同様)。

### 未参照の変数はコンパイルエラーとなる
Goでは、定義済みであるにも関わらず、何からも参照されていない変数があったらコンパイルエラーとなる。
煩わしい場合もあるが、誤った変数の使用を防ぐために存在する機能と考えるべき。

## Goのプリミティブ型
### 真偽値型

|型名|説明|
|:---|----|
| bool | 真（true）または偽（false） |

### 数値型
#### 符号なし整数
|型名|説明|範囲|
|:---|---|----:|
| `uint8` | 8bit符号なし整数 | 0 ~ 255 |
| `byte` |	uint8のエイリアス|  |
| `uint16` | 16bit符号なし整数 | 0 ~ 65535 |
| `uint32` | 32bit符号なし整数 | 0 ~ 4294967295 |
| `uint64` | 64bit符号なし整数 | 0 ~ 18446744073709551615 |
| `uint` | 32bit or 64bitの符号なし整数<br>**（環境依存）** | 0 ~ 18446744073709551615 <br>*or*<br>0 ~ 4294967295 |
| `uintptr` | ポインタの値 | ポインタの値をそのまま格納するのに十分な大きさの符号なし整数<br>（環境依存） |



#### 符号付き整数
| 型名 | 説明 | 範囲 |
|:--|:--|--:|
| `int8` | 8bit符号付き整数 | -128 ~ 127 |
| `int16` | 16bit符号付き整数 | -32768 ~ 32767 |
| `int32` | 32bit符号付き整数 | -2147483648 ~ 2147483647 |
| `int64` | 64bit符号付き整数 | -9223372036854775808 ~ 9223372036854775807 |
| `int` | 32bit or 64bitの符号付き整数<br>**（環境依存）** | -2147483648 ~ 2147483647 <br>*or*<br>-9223372036854775808 ~ 9223372036854775807|
| `rune` |	int32のエイリアス| -2147483648 ~ 2147483647 |


#### 浮動小数点
| 型名 | 説明 | 範囲 |
|:--|:--|:--|
| `float32` | 32bit浮動小数点 | IEEE-754 32bit浮動小数点数 |
| `float64` | 64bit浮動小数点 | IEEE-754 64bit浮動小数点数 |

#### 複素数
| 型名 | 説明 |
|:--|:--|
| `complex64` | 実数部・虚数部をfloat32で表現する複素数 |
| `complex128` | 実数部・虚数部をfloat64で表現する複素数 |

### 文字列型
| 型名 | 説明 |
|:--|:--|
| `string` | 文字列(ダブルクオートで囲む)|

## 型の扱い
### 整数リテラル
Goの整数リテラルにはC言語と同じく3種類存在する。

- 10進数・・・`[1-9][0-9]*` 例: `123`
- 8進数・・・`0[1-7][0-7]*` 例: `0755`
- 16進数・・・`0[Xx][0-9A-Fa-f]+` 例: `0x0719BEEF`

### その他のリテラル
整数型以外も含めると、リテラルには下記がある。

```go
i := 1	// int型

f64 := 1.0	// float64型
f32 := float32(1.0)	// float32型のリテラルは存在しない。型変換が必要。

zero := 0.0	// float64型
pinf := 1.0 / zero	// +Inf 正の無限大(float64型)
ninf := -1.0 / zero	// -Inf 負の無限大(float64型)
nan := zero / zero	// NaN 非数(float64型)

// その他の浮動小数点型リテラル
0.
72.40
072.40	// 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

c := 1.0 + 3i	// complex128型
c2 := complex(1.0, 3)	// complex128型(組み込み関数を使用)
r := real(c2)	// 1.0(実部)
i := imag(c2)	// 3.0(虚部)

// その他の複素数型リテラル
0i
011i	// 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

rune := '松'	// == 26494 rune型(int32のエイリアス)

// その他のruneリテラル
'\a' 'U+0007'	// ベル
'\b' 'U+0008'	// バックスペース
'\f' 'U+000C'	// フィード
'\n' 'U+000A'	// 改行(LF)
'\r' 'U+000D'	// 改行(CR)
'\t' 'U+0009'	// 水平タブ
'\v' 'U+000b'	// 垂直タブ
'\\' 'U+005c'	// バックスラッシュ
'\'' 'U+0027'	// シングルクォート(ルーンリテラルのみ)
'\"' 'U+0022'	// ダブルクォート(文字列リテラルのみ)

'a'
'本'
'\t'

// 8進数3桁
'\000'
'\007'
'\377'

// 16進数2桁
'\x07'
'\xff'

// 16進数4桁(小さいUnicodeコードポイント)
'\u12e4'

// 16進数8桁(大きいUnicodeコードポイント)
'\U00101234'

"文字列"	// 文字列リテラル


`
abcd
efg
hijk
`	// RAW文字列リテラル(改行や特殊文字を後処理せずそのまま扱う)
```

### 型変換
Goでは、**異なる型の暗黙的な型変換を許容しない**。したがって、下記のコードはコンパイルエラーとなる。

```go
var (
	n1 int
	n2 int64
)
n1 = 1
n2 = n1	// コンパイルエラー
```

明示的な型変換は可能。下記のように、`型名(変換対象)`と記述することで型変換できる。

```go
i := 17				// 型指定子がないとリテラルの型(この場合はint型)の変数iにint型の17を代入
n := uint(17)		// uint型の変数nにuint型の17を代入
b := byte(n)		// byte型に変換
i64 := int64(n)		// int64型に変換
u32 := uint32(n)	// uint32型に変換
```

#### 整数型の型変換時の"ラップアラウンド"
下記の場合は、整数リテラル(int)からbyte型へのナローイング変換をコンパイラが検知して、コンパイルエラーとなる。

```go
b := byte(256)	// コンパイルエラー
```

しかし、いったんint型の変数に値を代入して、それを型変換変換すると、ナローイング変換できてしまう。下記の場合、`b`は`0`となる。

```go
n := 256
b := byte(n)	// b == byte(0)
```

Go言語は、C言語と同様に、オーバーフローした時にその型で扱えない桁のビットを単純に無視する。これにより、ある型において、演算結果を、ある型の`mod`のようなものとして扱うことをラップアラウンドと呼ぶ。

#### 各々の方の最大値・最小値を使ったラップアラウンド対策
Goでは、C言語と同様にオーバーフローを考慮した演算を行う必要がある。  
この際に、`math`パッケージに用意されている<u>各々の方の最大値・最小値</u>を使用することができる。


```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("uint32 max value = %d\n", math.MaxUint32)	// uint32 max value = 4294967295
}
```

各々の型の最大値・最小値は下記の通り。

```Go
MaxInt8 =  1 << (8 - 1) - 1
MinInt8 = -1 << (8 - 1)

MaxInt16 =  1 << (16 - 1) - 1
MinInt16 = -1 << (16 - 1)

MaxInt32 =  1 << (32 - 1) - 1
MinInt32 = -1 << (32 - 1)

MaxInt64 =  1 << (64 - 1) - 1
MinInt64 = -1 << (64 - 1)

MaxUInt8 = 1 << 8 - 1
MaxUInt16 = 1 << 16 - 1
MaxUInt32 = 1 << 32 - 1
MaxUInt64 = 1 << 64 - 1

MaxFloat32 = 2**127 * (2**24 - 1) / 2**23
SmallestNonzeroFloat32 = 1 / 2**(127 - 1 + 23)
MaxFloat64 = 2**1023 * (2**53 - 1) / 2**52
SmallestNonzeroFloat64 = 1 / 2**(1023 - 1 + 52)
```

上記の型の最大値・最小値を使用すれば、オーバーフローに(比較的)楽に対応できる。

```go
func sum(a, b uint32) bool {
	if (math.MaxUint32 - a) < b {
		// オーバーフローする
		return false;
	}

	sum := a + b	// このパスではオーバーフローしないことを保証済み
	return sum
}
```

## 配列型
配列の型名は`[要素数]型名`となる。その後に続けた`{}`によって初期値を指定できる。  
インデックスは、一般的な言語と同じく**0始まり**。  
**初期値を与えなかった場合、各要素は0で初期化される。**

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println("%v", a)	// => "[1, 2, 3, 4, 5]"

a[0]	// 1
a[1]	// 2
a[2]	// 3
a[3]	// 4
a[4]	// 5
a[5]	// エラー:範囲外
a[-1]	// エラー:負数を指定

a := [5]int{1, 2, 3, 4, 5, 6}	// エラー:初期値の個数が要素数を超過
b := [5]int		// == [0, 0, 0, 0, 0]
c := [5]int{}	// == [0, 0, 0, 0, 0]

ia := [3]int{}	// == [0, 0, 0]
ua := [3]uint{}	// == [0, 0, 0]
ba := [3]bool{}	// == [false, false, false]
fa := [3]float64{}	// == [0, 0, 0]
ca := [3]complex128{}	// == [(0+0i), (0+0i), (0+0i)]
ra := [3]rune{}	// == [0, 0, 0]
sa := [3]string{}	// == ["", "", ""]

aa := [0]int{}	// 要素数が0の配列も定義可能(使いどころは無さそうだが)
```

要素数を省略するには`[要素数]`の部分を`[...]`と記述する。

```go
a1 := [...]int{1, 2, 3}			// == [3]int{1, 2, 3}
a2 := [...]int{1, 2, 3, 4, 5}	// === [5]int{1, 2, 3, 4, 5}
a3 := [...]int{}				// == [0]int{}
```

要素へ値を代入するには`array[n] = value`の形で記述する。

```go
a := [...]int{1, 2, 3}	// == [1, 2, 3]
a[0] = 0
a[2] = 100
// a == [0, 2, 100]
```

**NOTE**  
配列を、他の配列に代入することも可能。ただし、要素の型と要素数が一致している必要がある。  

**NOTE**  
配列の代入は、ディープコピーとなる。すなわち、配列の代入後に、片方の配列を書き換えても、もう片方の配列は変化しない。

**NOTE**  
Goでは、配列のサイズを拡張することはできない(例えば`[]int`は可変長配列ではない)。  
そのかわり、Goでは**Slice(スライス)**というデータ構造を可変長配列のように扱うことができる。

## `interface{}`型と`nil`
`interface{}`は、`{}`も含めて型名。  
`interface{}`は、Goの全ての型と互換性のある型。
すなわち、`int`, `float64`,`string`なども全て`interface{}`と互換性がある。  
近いイメージとしては、C言語における汎用ポインタ`(void*)`や、JavaやC#における`Object`クラスがある。

`interface{}`は他の型と同様に変数定義できる。デフォルト値は`nil`。

```go
var x interface{}
fmt.Println("%#v", x)	// => "<nil>"
```

<u>`nil`とは、Goにおいて**具体的な値を持っていない状態を表す値**で、C言語、Java、C#における`null`のようなもの。</u>

`interface{}`型の変数であれば、次のように、あらゆる型の値を代入できる。

```go
var x interface{}
x = 1
x = 3.14
x = '山'
x = "文字列"
x = [...]uint8{1, 2, 3, 4, 5}
```

一旦`interface{}`型に格納されてしまった値は、元の型情報を失ってしまう。  
そのため、例えば`int`型の値を`interface{}`型の変数に代入すると、`+`演算が出来なくなる。

```go
var x, y interface{}
x, y = 1, 2
z := x + y	// 演算できないためエラーとなる
```

## 演算子
`Go`では下記の演算子が使用できる。

|種類|&nbsp;&nbsp;演算子|
|----|------|
|算術|&nbsp;&nbsp;+ - * / % & \| ^ ^& << >> |
|比較|&nbsp;&nbsp;== != < <= > >=|
|論理|&nbsp;&nbsp;\|\| &&|
|単行|&nbsp;&nbsp;+ - ! ^ * & <-|
<br/>

|優先度|&nbsp;&nbsp;演算子|
|------|------|
|高    |&nbsp;&nbsp;* / % << >> & &^|
|      |&nbsp;&nbsp;+ - \| ^|
|      |&nbsp;&nbsp;== != < <= > >=|
|      |&nbsp;&nbsp;&&|
|低    |&nbsp;&nbsp;\|\||

### 演算子の意味と対象の型

|演算子|&nbsp;&nbsp;意味|&nbsp;&nbsp;対象の型|
|------|----|--------|
|+(単項)|&nbsp;&nbsp;意味なし(`0 + x`と等価)|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|-(単項)|&nbsp;&nbsp;符号反転|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|^(単項)|&nbsp;&nbsp;ビットの補数|&nbsp;&nbsp;整数、浮動小数点数|
|+(2項)|&nbsp;&nbsp;和|&nbsp;&nbsp;整数、浮動小数点数、複素数、文字列(文字列結合)|
|-(2項)|&nbsp;&nbsp;差|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|*(2項)|&nbsp;&nbsp;積|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|/(2項)|&nbsp;&nbsp;商(商は0の方向へ切り捨て/切り上げされる)|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|%(2項)|&nbsp;&nbsp;剰余|&nbsp;&nbsp;整数|
|&(2項)|&nbsp;&nbsp;論理積(ビット演算)|&nbsp;&nbsp;整数|
|\|(2項)|&nbsp;&nbsp;論理和(ビット演算)|&nbsp;&nbsp;整数|
|^(2項)|&nbsp;&nbsp;排他的論理和(ビット演算)|&nbsp;&nbsp;整数|
|&^(2項)|&nbsp;&nbsp;ビットクリア(`a &^ b == a & (^b)`)|&nbsp;&nbsp;整数|
|<<(2項)|&nbsp;&nbsp;左シフト(ビット演算)|&nbsp;&nbsp;整数|
|>>(2項)|&nbsp;&nbsp;右シフト(ビット演算)|&nbsp;&nbsp;整数|
|==|等しい|比較可能な型|
|!=|等しくない|比較可能な型|
|<|未満|順序が有る型|
|<=|以下|順序が有る型|
|>|超|順序が有る型|
|>=|以上|順序が有る型|
|&&|and(論理値)|論理値|
|\|\||or(論理値)|論理値|
|!|not(論理値)|論理値|
<br/>

比較可能な型
: 論理値、整数値、浮動小数点数、複素数、文字列

順序が有る型
: 整数値、浮動小数点数、文字列

**NOTE**
`a = a [演算子] b`という形の2項演算子は`a [演算子]= b`という短縮形を持つ。

## 関数
 

 ```go
func 関数名([引数名 型名]*) 戻り値の型名* {
	処理
}
 ```

### [引数名 型名]*
同じ型の引数を指定する場合、`x, y int`のように型の指定を一つにまとめることも、`x int, y int`のように変数ごとに型名を指定することもできる。

### 戻り値のない関数
戻り値のない関数は、下記のように戻り値の型名を省略することで定義できる。

```go
func 関数名([引数名 型名]*) {
	処理
}
 ```

### 複数の戻り値を持つ関数
Goでは複数の戻り値を持つ関数を定義できる。

```go
func 関数名([引数名 型名]*) (戻り値の型名1, 戻り値の型名2) {
	処理
	return 戻り値1, 戻り値2
}
```

複数の戻り値を持つ関数の戻り値は下記のように受け取る

```go
a, b := f(x, y)
```

複数の戻り値に不要なものがある場合、下記のように`_`を使うことで破棄できる。

```go
// 2つ目の戻り値を破棄
q, _ := f(x, y)

// 型推論できないためコンパイルエラー
_, _ := f(x, y)

// コンパイルエラーとはならないが、ただの関数呼び出しと等しいため無意味
_, _ = f(x, y)
```

### Goにおけるエラー処理
Goには例外機構がない。  
Goにおける一般的なエラー処理では、下記のイディオムを用いる。  
複数の戻り値を用いて、最後の戻り値でエラー内容を表すことで、関数の呼び出し元に自主的にエラー判定を行わせる。  

```go
result, err := f(x, y)
if (err != nil) {
	// エラー発生時の処理を書く
}
```

この方法は、C言語ライクのエラー判定をやりやすくした程度で原始的だが、単純で良いと思う。  
エラー用の戻り値を読み捨てるような使い方をされる可能性があるが、そもそも`err`は契約的プログラミングでいう事前条件違反を表すものと考えれば、むしろエラーハンドリングの責務を明確にできるのかもしれない。

### 戻り値を表す変数
Goでは戻り値に変数を割り当てることができる。

```go
package main

import (
	"fmt"
)

func f() (a int) {	// 戻り値に変数aを割り当てた
	return
}

func main() {
	fmt.Println(f())	// => 0 (== aのデフォルト値)
}
```

上記の構文は、下記のコードの短縮形と考えられる。

```go
// 短縮形
func f() (a int) {
	return
}

// 短縮していない形
fnc f() int {
	var a int
	return a
}
```

複数の戻り値に対しても変数を割り当てることができる。

```go
// 短縮形
func f() (a, b int) {
	b = 5
	return	// x === 0, y == 5
}

// 短縮していない形
func f() (int, int) {
	var a, b int
	b = 5
	return a, b	// x === 0, y == 5
}
```

### 引数を無視する
戻り値と同じく、引数も破棄することができる。  
インターフェースで定義されているプロトタイプを実装するとき、実装で使用しない場合に、それを明示する場合に使用すると無駄な変数割り当てが発生しない。

```go
func f(_, _ int) int {
	return 1
}

f(2, 3)	// => 1
```

### 無名関数
Goでは、関数を変数に代入できる。  
名前がある関数を代入できるのはもちろんのこと、下記のように関数定義自体をそのまま代入することもできる。

```go
f := func(x, y int) int { return x + y}
```

上記の右辺のように、関数を名前無しで定義して、それ自身を変数に代入できる。  
このとき、右辺を**関数リテラル**と呼ぶ。

関数リテラルの型は、その関数の引数の型と戻り値の型の組となる。  

```go
fmt.Println("%T\n", func(x, y int) int {return x + y})
// => "func(int, int) int"
```

したがって、意味はないが、変数を、この型で定義することもできる。

```go
var f func(int, int) int
f = func(x, y int) int { return x + y}
```

### 高階関数(関数を返す関数)
```go
package main

import (
	"fmt"
)

func F() func() {	// 戻り値の型 func()
	return func() {
		fmt.Println("Hello, World!")
	}
}

func main() {
	function := F()
	function()	// "Hello, World!"

	// F()で帰ってきたfを同時に呼び出す
	F()()	// "Hello, World!"
}
```

### 高階関数(関数を引数に渡す関数)

```go
package main

import (
	"fmt"
)

func F(f func()) {
	f()
}

func main() {
	F(func() { fmt.Println("Hello, World!") })	// "Hello, World!"
}
```

### クロージャ
Goではクロージャも定義できる。

```go
package main

/**
 * "nextに値を渡すとその値を内部に保持し、その前にnextに渡した値を返す"関数を返す
 */
func later() func(string) string {
	var store string
	return func(next string) string {
		s := store
		store = next
		return s
	}
}

func main() {
	f := later()
	f("Golang")	// => ""
	f("is")	// => "Golang"
	f("good")	// => "is"
}
```

#### クロージャでジェネレータを実装する
```go
package main

/**
 * "nextに値を渡すとその値を内部に保持し、その前にnextに渡した値を返す"関数を返す
 */
func integers() func() int {
	index := -1
	return func() int {
		index += 1
		return index
	}
}

func main() {
	f := integers()
	f()	// => 0
	f()	// => 1
	f()	// => 2
	f()	// => 3
	f2 := integers()
	f2()	// => 0
	f2()	// => 1
}
```

## 定数
Goでは`const`を使用して定数を定義できる。

```go
const X = 1	// 定数1(整数)
```

複数の定数をまとめて定義することもできる。

```go
const (
	X = 1
	Y = 2
	Z = 3
)
```

- **NOTE**  
  - 途中から定数に定義する値を省略した場合、前回定義したのと同じ値を定数定義する。  
    ただし、全ての定数定義の値を省略することはできない。
  - 定数の値の定義には任意の式を使用でき、さらに、その中に他の定数を使用できる。

```go
const (
	X = 1
	Y = 2
	Z	// 2
)

// コンパイルエラー
const (
	X
	Y
	Z
)

const (
	A = 1	// 1
	B = A + 1	// 2
	C = B + 1	// 3
	Z = X + Y	// 9 この行の後に定義されている定数も使用可能
	X = 2
	Y = 7
)
```

### 定数の型
Goの定数定義では、下記のいずれかの値を定義できる。

- 論理型
- 整数(**「整数」であり、int等の型ではない**)
- 浮動小数点数(**「浮動小数点数」であり、float64等の型ではない**)
- 複素数
- ルーン
- 文字列

型を指定子ない定数定義では、整数はあくまでも整数であり、intやuintなどの区別はない。  
型ありの定数を定義したい場合は、下記のように型を指定して定数定義する。

```go
const (
	I64 int64 = -1	// 定数I64はint64型
	I32 = int32(-1)	// 定数32はint32型
	F64 float64 = 1.2	// 定数F64はfloat64型
	F32 = float32(1.2)	// 定数F32はfloat32型
)
```

### 各定数の注意
#### 論理値の定数
論理値はbool型と全く同じであるため、使用上の注意は特に無し。

#### 整数値の定数
整数値の定数には最大値/最小値がないため、定数定義するぶんにはいくらでも大きな/小さな数値を定義できる。
しかし、変数への代入の際にコンパイルエラーとなる。  
このように、分かりやすさを優先するため、できる限り定数には型を指定したほうが良い。

```go
const (
	N = 9999999999999999999999999999999999999999999999999999999
)
i := N	// コンパイルエラー
```

**NOTE**  
数値定数同士の演算はコンパイル時に処理されるという性質がある。  
そのため、下記のコードは問題なく動作する。

```go
const (
	// uint64型の最大値より1大きな整数値
	N = 18446744073709551615 + 1
)

n := uint64(N - 1)

// コンパイル時に下記の形に変換されて評価されるため、エラーとならない
n := uint64(18446744073709551615)
```

#### 浮動小数点数の定数
浮動小数点数の型(float64, float32)よりも高い精度の少数を定数定義することは可能。  
ただし、float64またはfloat32のどちらかに変換した型が許容するまで精度が落ちる。

**NOTE**  
変数を介さず、定数のみで演算することで、コンパイル時に精度を落とさず演算できる。

#### 複素数の定数
複素数リテラルを使用して定数定義できる。  
複素数の実部・虚部ともに浮動小数点数と同様の精度を備えている。

#### ルーン、文字列の定数
ルーンリテラル、文字列リテラルを使用して、rune型および文字列型の定数を定義できる。  
文字列型定数の定義ではRAW文字列リテラルも使用できる。

### `iota`によるenumのような定数定義
定数定義ブロック内で`iota`キーワードを使用することで、連番の定数を簡単に定義できる。  
ただし、無駄に複雑な定数定義は混乱を招くので、関連の有る単位で定数ブロックを分けること。

- **NOTE**
  - `iota`は0始まり。次の行の定数では+1される。
  - `iota`は省略可能。
  - 異なる値を定義した場合はその値になるが、`iota`自体は行ごとに必ずインクリメントされている。
  - コードブロックごとに`iota`は0にリセットされる。

```go
const (
	A = iota	// 0
	B			// 1
	C			// 2
)

const (
	D = 1 + iota	// 1
	E = 1 + iota	// 2
	F = 1 + iota	// 3
	FF = iota		// 3
)

const (
	G = 1 + iota	// 1
	H				// 1 + iota == 2
	I				// 1 + iota == 3
)

const (
	J = iota	// 0
	K = 100		// 100
	L			// 100
	M = iota	// 4
	N			// 5
)
```

## スコープ
Goにおいて、定義済み識別子以外の構成要素はパッケージに属する。

### パッケージのスコープ
- **識別子の1文字目が大文字**の定数、変数、関数は、他のパッケージから参照できる。
- **識別子の1文字目が小文字**の定数、変数、関数は、自分のパッケージからしか参照できない。
- **識別子の1文字目が大文字小文字の区別のない文字(日本語など)**の定数、変数、関数は、自分のパッケージからしか参照できない。

```go
package foo

// 定数
const (
	A = 1		// 先頭大文字・・・他のパッケージから参照できる
	abc = "abc"	// 先頭小文字・・・他のパッケージから参照できない
)

// パッケージ変数
var (
	m = 256	// 先頭小文字・・・他のパッケージから参照できない
	N = 512	// 先頭大文字・・・他のパッケージから参照できる
)

// public関数
func DoSomething() {
	// ...
}

// private関数
func doSomething() {
	// ...
}
```

```go
package bar

import (
	"foo"
)

foo.A	// 1
foo.abc	// コンパイルエラー

foo.N	// 512
foo.m	// コンパイルエラー
```

### いろいろな`import`方法
インポートする際に、別名を指定できる。  
下記のコードでは、パッケージ`fmt`を`f`という別名で**上書き**している。  
したがって、下記の`main`パッケージでは、パッケージ`fmt`を`fmt`という名前で参照できない。

```go
package main

import (
	f "fmt"	// パッケージ"fmt"を、名前fとしてインポートする
)

func main() {
	f.Println("Hello, World!")	// パッケージ名をfとして参照できる
}
```

パッケージ名を省略するためには、別名に`.`を指定する。

```go
package main

import (
	"fmt"
	. "math"	// mathパッケージを、パッケージ名無しでインポート
)

func main() {
	fmt.Println(Pi)	// Piをmathパッケージ指定なしで参照できる
}
```

パッケージ名を省略した場合、そのパッケージが持つ識別子と名前衝突の危険がある。

```go
package main

import (
	. "math"	// mathパッケージを、パッケージ名無しでインポート
)

const (
	Pi	// math.Piと名前衝突するためコンパイルエラー
)
```

### `import`宣言のスコープはファイル単位
Goでは１つのパッケージを複数ファイルに分割して定義できる。しかし、`import`宣言は各々のファイル内でのみ有効。

- `main1.go`

```go
package main

import (
	f "fmt"
)

func main() {
	foo()
}
```

- `main2.go`

```go
package main

func foo() {
	fmt.Println("Hello, World!")	// fmtが解決できないためコンパイルエラー
}
```

### 関数のスコープ
Goにおいて、関数はスコープを形成する。すなわち、関数内で定義した変数や定数は、その関数内でのみ有効。  
また、関数の引数名と戻り値名も関数と同名の変数などを関数内部で定義(シャドーイング)することは不可能。

C言語のように`{}`を用いることで、スコープを定義することができる。

```go
func foo(a int) (b string) {
	{
		var a int
		const b = "string"
	}
	return b	// "" 戻り値の初期値
}
```

## 制御構文
### `for`
Goにおけるループ用の制御構文は`for`のみ。

```go
for {
	// ...

	if [条件] {
		break	// 中断
	}

	if [条件] {
		continue	// 次の周回へジャンプ
	}
}

for i := 0; i < 10; i++ {
	// 0から9までの繰り返し
}

for ;; {
	// 無限ループ
}
```

pythonなどにあるような範囲節を用いたループも記述できる。

```go
for [配列のインデックス], [配列の要素] := range [配列型] {
	// ...
}

for i, s := range [3]string{"aaa", "bbb", "ccc"} {
	fmt.Printf("%v:%v\n", i, s)
}
// =>
// 0:aaa
// 1:bbb
// 2:ccc
```

範囲節に指定できる型は下記の通り。

|データ型|型|反復値<br/>(1番目)<br/>== [配列のインデックス]|反復値の型<br/>(1番目)|反復値<br/>(2番目)<br/>== [配列の要素]|反復値の型<br/>(2番目)|
|:---|:---:|:---|:---:|:---|:---:|
|配列型|`[n]E`|インデックス|`int`|配列の要素|`E`|
|配列型のポインタ|`*[n]E`|インデックス|`int`|配列の要素|`E`|
|スライス|`[]E`|インデックス|`int`|の要素|`E`|
|文字列|`string`|インデックス|`int`|ルーン|`rune`|
|マップ|`map[K]V`|マップのキー|`K`|マップの値|`V`|
|チャネル|`chan E`, `<- chan E`|チャネルの値|`E`|無し|-|

- 
- インデックスは0始まり

### `if`
条件文のひとつに`if`がある。

```go
if x == 1 {
	// ...
}

if x == 1 {
	// ...
} else if x == 2 {
	// ...
} else if x == 3 {
	// ...
} else {
	// ...
}

// {}は絶対に省略できない
if x == 1
	// ...	// コンパイルエラー

// 真偽値を返さない条件式は記述できない
if 1 {
	// ...	// コンパイルエラー
}
```

#### 簡易文付き`if`
条件式への使用などのために、条件式の前に単一の文を定義できる。  
簡易文で定義した変数は、`if`の中でのみ使用できる。つまり`if`の外では参照できない。

```go
if [簡易文]; [条件式] {
	// ...
}

if x, y = 1, 2; x < y {
	// ...
}

// ここではx, yを参照できない
```

簡易文付き`if`は、エラー処理をシンプルに記載する際に便利。

```go
if _, err := doSomething(); err != nil {
	// エラー発生時の処理
}
```

### `switch`
#### 式による`switch`
大抵はCにおけるswitchと似ているが、細部の仕様が異なる。

- `if`と同じく簡易文が使える。
- `case`に複数の式をカンマ区切りで指定できる。
- 互換性のある型にはマッチする。
- Goにおける`switch`ではフォールスルー特性がない。  
  すなわち、各caseの処理が完了したら他の`case`に入らず`switch`文から出る。
- `case`に式と値を混在させるとコンパイルエラーとなる。

```go
switch [簡易文;] [式] {
	// ...
}

n := 3
switch n {
case 1, 2:
	fmt.Println("1 or 2")
case 3, 4:
	fmt.Println("3 or 4")
default:
	fmt.Println("other")
}
// =>
// "3 or 4"

n := 3
switch n {
case 1:
	fmt.Println("one")
case 2.0:	// 整数2の場合、ここに入る
	fmt.Println("two")
case 3+0i:	// 整数3と互換の型のため、ここに入る
	fmt.Println("three")
}
// =>
// "three"

// 式を使ったswitch-case文
n := 4
switch n {
case 0 < n && n < 3:
	fmt.Println("0 < n < 3")
case 3 < n && n < 6:
	fmt.Println("3 < n < 6")
}
// =>
// "3 < n < 6"
```


#### **型アサーション**と型による`switch`
型アサーションとは、動的に変数の型をチェックする機能。

1つの戻り値を受け取る場合、型アサーション違反となるとランタイムパニックが発生する。

```go
// 基本的な書式
x.(T)	// 変数xが型Tでなければランタイムパニックを発生させる

var x interface{} = 3

i := x.(int)		// エラー発生せず(i == 3)
f := x.(float64)	// ランタイムパニック発生
```

2つの戻り値を受け取る場合、第2戻り値に型アサーションの結果が真偽値で格納される。

```go
var x interface{} = 3.14

i, isInt := x.(int)	// i == 0, isInt == false
f, isFloat64 := x.(float64)	// f == 3.14, isFloat64 == true
s, isString := x.(string)	// s == "", isString == false


// 実用例
if x == nil {
	fmt.Println("x is nil")
} else if i, isInt := x.(int); isInt {
	fmt.Printf("x is integer : %d\n", i)
} else if s, isString := x.(string); isString {
	fmt.Println(s)
} else {
	fmt.Println("unsupported type")
}
```

上記コードの実用例を`switch`を用いることでさらに簡潔に記述できる。

```go
switch x.(type) {
case bool:
	fmt.Println("x is bool")
case int, uint:
	fmt.Printf("x is integer or unsigned integer")
case string:
	fmt.Println("string")
default:
	fmt.Println("unsupported type")
}
```

簡易文によって、`switch`本体で値を簡単に使用できる。  
このとき、値が明確に型推論可能であれば、`case`内部の値は型情報を与えられる。

```go
// 正しい使用例
switch v := x.(type) {
case bool:
	fmt.Println("x is bool", v)
case int:
	fmt.Printf("x is integer: v^2=", v * v)
case string:
	fmt.Println(v)
default:
	fmt.Printlf("unsupported type: %#v\n", v)
}

// 誤った使用例
switch v := x.(type) {
case int, uint:	// int型かuint型か定まらないためコンパイルエラーとなる
	fmt.Printf("x is integer: v^2=", v * v)
default:
	fmt.Printlf("unsupported type: %#v\n", v)
}
```

### `goto`
`goto`も使用可能。ただし、安全性を保つため下記制約がある。

- ラベルと`goto`の組み合わせは関数内に閉じた範囲で使用できる。
- `goto`によって、`for`文などが構成するブロックの外側から内側にはジャンプできない。
- `goto`によって、**変数定義**を飛び越えられない。

```go
func main() {
	fmt.Println("A")
	goto L
	fmt.Println("B")
L:	// ラベル
	fmt.Prinln("C")
}

// =>
// A
// C
```

### ラベル付き文
`goto`を使わずとも、**ラベル付き文**を用いれば大域脱出が可能。

```go
LOOP:
	for {
		for {
			for {
				fmt.Println("開始")
				break LOOP
			}
			fmt.Println("ここは通らない")
		}
		fmt.Println("ここは通らない")
	}
	fmt.Println("完了")

// =>
// 開始
// 完了
```


### `defer`で関数終了時の処理を登録する
`defer`キーワードを使用することで、関数終了時の処理を予め登録しておける。  
登録しておいた処理は、関数終了時に実行される。

```go
func runDefer() {
	defer fmt.Println("defer")	// runDefer()終了時に呼ばれる処理
	fmt.Println("done")
}
runDefer()

// =>
// done
// defer
```

`defer`を使えば、ファイルのオープン/クローズ処理などの、リソース管理を多少楽に記述できる。  
`defer`は複数回使用できるが、後に登録した処理から先に実行されることに注意。

```go
func foo() {
	file, err := os.Open("path/to/file")
	if err != nil {
		// ファイルのオープンに失敗
		return
	}
	defer file.Close()	// 最後にファイルをクローズするように処理を登録

	// ファイルを使った処理...
}

func foo() {
	defer Println("1")
	defer Println("2")
	defer Println("3")
	
	Println("ABC")
}

// =>
// ABC
// 3
// 2
// 1
```

`defer`で複数の処理を登録したい場合、無名関数を使用すれば良い。  
`defer`は関数呼び出しの形にする必要があるため、無名関数の定義の最後にカッコを付ける必要があることに注意。

```go
defer func() {
	Println("3")
	Println("2")
	Println("1")
	Println("0!")
}()	// 関数呼び出しの形にする必要がある
```

### `panic`と`recover`によるランタイムパニック処理
#### `panic`によってランタイムパニックを発生させる
`panic`はランタイムパニック(C言語のセグメンテーション違反のようなもの)を発生させる関数。

```go
// panicの書式
func panic(v interface{})

// panicの使用例
func main() {
	// panic発生時にもdeferは必ず実行される
	defer fmt.Println("END!!!!")

	panic("runtime error!")
	fmt.Println("Hello, World!")
}

// =>
// END!!!!
// panic: runtime error!
// ....エラー詳細....
// ..................
```

#### `recover`によってランタイムパニックによる中断を回復する
`defer`の中で`recover`関数を登録しておくことで、ランタイムパニックから復帰することができる。

```go
/// recoverの書式
func recover() interface{}
// 戻り値...nil:ランタイムパニック未発生, nil以外:ランタイムパニック発生
```

下記コードは、`panic`と`recover`を組み合わせた使用例。

```go
func testRecover(src interface{}) {
	// エラーハンドリング
	defer func() {
		if x:= recover(); x != nil {
			// 発生したpanicの種類によって処理分岐
			switch v := x.(type) {
			case int:
				fmt.Printf("panic: int=%v\n", v)
			case string:
				fmt.Printf("panic: string=%v\n", v)
			default:
				fmt.Printf("panic: unknown error")
			}
		}
	}

	panic(src)
	return
}

func main() {
	testRecover(128)
	testRecover("foo")
	testRecover([...]int{1, 2, 3})
}

// =>
// panic: int=128
// panic: string=foo
// panic: unknown error
```

**NOTE**  
Goにおいては、この手の例外処理は積極的に使用しないほうが良い。  
むしろ`panic`を起こさないように注意したコーディング(防御的プログラミング的なもの?)を心がけることが良しとされているらしい。

### `go`文による並行処理
`go`文は、**ゴルーチン(goroutine)**を生成して、並行処理されるようにランタイムに追加するための機能。

ゴルーチン
: Goが持つ、スレッドよりも小さい、軽量な処理単位。

`go`文では、`defer`文と同様に、関数呼び出し形式の式を受け取る。  
`go [関数呼び出し]`と記述すると、ゴルーチンを新規に生成して`[関数呼び出し]`を実行する。

```go
func sub() {
	for {	// 無限ループ
		fmt.Println("sub loop")
	}
}

func main() {
	go sub()
	for {	// 無限ループ
		fmt.Println("main loop")
	}
}
```

`runtime`パッケージを使用することで、Goのランタイム地震についての情報を参照したり、動作をコントロールできる。

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
	fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
	fmt.Printf("Version: %d\n", runtime.Version())
}
// =>
// NumCPU: 2
// NUmGoroutine: 1
// Version: go1.6
```

- `NumCPU`...CPUのコアの数
- `NumGoroutine`...Goランタイム上で動作しているゴルーチンの個数

### `init`関数
Goのパッケージにおいて、パッケージの初期化を目的にした特殊な関数`init`を、開発者自身で定義できる。  
`init`は、引数と戻り値を持ってはいけない。

`init`関数は、`main`関数の実行前に実行される。すなわち、`init`関数は、プログラムのメインルーチン実行前に、初期化したい何らかの処理を実行するために使用できる。

```go
package main

package (
	"fmt"
)
func init() {
	fmt.Println("init()")
}

func main() {
	fmt.Println("main()")
}

// =>
// init()
// main()
```

`init()`は複数個定義できる。定義した`init()`は、上から順番に実行される。ただし、明確な目的がない限り、`init`関数を分けない方が良い。

```go
package main

package (
	"fmt"
)

var S = ""

func init() {
	S += "A"
}

func init() {
	S += "B"
}

func init() {
	S += "C"
}

func main() {
	fmt.Println("S")
}

// =>
// ABC
```
