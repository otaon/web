---
title: "Go言語入門(基本構文)"
date:    2019-03-31T14:00:00+09:00
lastmod: 2019-03-31T14:00:00+09:00
draft: false
tags: ["Go", "Golang"]
categories: ["Notes"]
authors:
- otaon
---

# 目的
Go言語の基本構文を残す。

# 参考文献
- [スターティング Go言語](https://www.shoeisha.co.jp/book/detail/9784798142418)

# 基本構文
## パッケージ(`package`)・インポート(`import`)について
下記記事を参照。

 [Go言語入門(環境構築・プログラム作成・パッケージ作成・実行・テスト実行)]({{<ref "/posts/0030_go_tutorial/index.md" >}})

## コメント
C言語と同じコメント形式(`//` or `/* */`)を使用できる。後者は入れ子不可能。

## 文構造
Goでは、各々の文はセミコロン(`;`)によって区切られる。  
ただし、Goは<u>全てのセミコロンが省略できる</u>。  

```go
func main() {
	fmt.Println("Hello, World!")
}
```

上記のコードは、コンパイル時に文末にセミコロンが自動的に挿入され、下記のコードとして扱われる。

```go
func main() {
	fmt.Println("Hello, World!");
}
```

**NOTE**  
基本的に、<u>文末判定は行ごとに行われると考えて良い。</u>したがって、下記のコードはコンパイルエラーとなる。

```go
a := [3]string{
	"foo",
	"bar",
	"baz"	// 行末に;が挿入されてしまう
	}
```

これを防ぐには、下記のように末尾要素の後ろにも`,`をつけて、文末でない事を明示すべき。

```go
a := [3]string{
	"foo",
	"bar",
	"baz",	// 文末と判断されず;は挿入されない
	}
```

## 定義済み識別子
下記の定義済み識別子は、変数名や関数名に使用できるが、混乱のもとになるため避けること。

| 識別子の種類 | 識別子 |
|:--------------:|--------|
| 型 | `bool` `byte` `complex64` `complex128` `error` `float32` `float64` `int` `int8` `int16` `int32` `int64` `rune` `string` `uint` `uint8` `uint16` `uint32` `uint64` `uintptr` |
| 定数 | `true` `false` `iota` |
| ゼロ値 | `nil` |
| 関数 | `append` `cap` `close` `complex` `copy` `delete` `imag` `len` `make` `new` `panic` `print` `println` `real` `recover` |

## 出力関数
### `fmt.Println()`
文字列の最後に改行を付加した文字列を標準出力に出力する。

```go
fmt.Println("Hello, Golang!")	// => "Hello, Golang!"
```

複数の引数を渡した場合、各々の文字列をスペースで区切って1行で表示する。

```go
fmt.Println("Hello" "Golang" "!")	// => "Hello Golang !"
```

### `fmt.Printf()`
書式指定子を含んだフォーマット文字列と、可変長引数を渡すと、生成した文字列を標準出力に出力する。

```go
fmt.Printf("数値=%d\n", 5)	// => "数値=5"
```

```go
fmt.Printf("10進数=%d 2進数=%b 8進数=%o 16進数=%x\n", 17, 17, 17, 17)
// => "10進数=17 2進数=10001 8進数=21 16進数=11"
```

可変長引数の個数に過不足がある場合、それを下記のように文字列中で知らせる。

```go
fmt.Printf("%d年%d月%d日\n", 2015, 12)
// => "2015年12月%!d(MISSING)日"

fmt.Printf("%d年%d月%d日\n", 2015, 12, 25, 17)
// => "2015年12月25日%!(EXTRA int=17)"
```

Goのデバッグで有用な書式指定子として`%v`, `%#v`, `%T`がある。

```go
// %v 様々な型のデータを埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列=Golang 配列=[1 2 3]"

// %#v Goのリテラル表現でデータを埋め込む
fmt.Printf("数値=%#v 文字列=%#v 配列=%#v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=5 文字列="Golang" 配列=[3]int{1 ,2, 3}"

// %T 型情報を埋め込む
fmt.Printf("数値=%v 文字列=%v 配列=%v\n", 5, "Golang", [...]int{1, 2, 3})
// => "数値=int 文字列=string 配列=[3]int"
```

### `print()`, `println()`
組み込み関数として`print()`と`println()`がある。これらは、与えられた文字列を**標準エラー出力**に出力する。

## 変数定義・変数への代入
### 明示的な変数定義
明示的な変数定義の方法を示す。  
見て分かるとおり、`var 変数名　型名`の順番で定義する。  
また、複数の変数定義をまとめて行えるようになっている。

```go
// 明示的な定義
var a int

// int型の変数x, y, zをまとめて定義する
var x, y, z int

// 異なる型の変数x, y, nameをまとめて定義する
var (
	x, y int
	name string
)
```

### 代入
定義した変数に値を代入する方法は下記の通り。  
代入も、複数個の変数にまとめて代入する構文が用意されている。

```go
// 変数への代入
a = 5

// 複数個の変数に複数個の値をまとめて代入する
x, y = 1, 2

// Error: 異なる個数の代入はコンパイルエラーとなる
x, y, z = 1, 2
```

### 暗黙的な定義(推奨)
演算子`:=`を使用することで、型指定なしで変数が定期可能。  
この場合、右辺に記述した式の型が、左辺の変数の型として推論される。  
可能な限り、この方法での変数定義をすること。

```go
i := 3	// int型の変数iに整数3を代入する
b := true	// bool型の変数bに真偽値trueを代入する
f := 3.14	// float64型の変数fに実数3.14を代入する
s := "abc"	// string型の変数sに文字列"abc"を代入する

func one() int {
	return 1
}
n := one()	// int型の変数nに整数1を代入する
```

**NOTE**  
明示的な定義、暗黙的な定義は、当然ながら同一の変数に対しては**ただ1回のみ**使用できる。  
2回目以降の定義の箇所でコンパイルエラーとなる。

**NOTE**  
`var a = 1`と記述することで、変則的だが`var`を使った暗黙的な定義も可能。  
しかし、簡潔さの観点から`:=`のほうが好ましい。

### 変数のスコープ
Goにおける変数は、定義位置により2種類に分かれる。

ローカル変数
: 関数定義の中に定義された変数。  
同一のパッケージ変数がある場合、そのパッケージ変数をシャドウイングする(C言語と同様)。

パッケージ変数
: 関数定義の外に定義された変数。  
パッケージ変数は、プログラム全体で1つの値が共有される(C言語のグローバル変数と同様)。

### 未参照の変数はコンパイルエラーとなる
Goでは、定義済みであるにも関わらず、何からも参照されていない変数があったらコンパイルエラーとなる。
煩わしい場合もあるが、誤った変数の使用を防ぐために存在する機能と考えるべき。

## Goのプリミティブ型
### 真偽値型

|型名|説明|
|:---|----|
| bool | 真（true）または偽（false） |

### 数値型
#### 符号なし整数
|型名|説明|範囲|
|:---|---|----:|
| `uint8` | 8bit符号なし整数 | 0 ~ 255 |
| `byte` |	uint8のエイリアス|  |
| `uint16` | 16bit符号なし整数 | 0 ~ 65535 |
| `uint32` | 32bit符号なし整数 | 0 ~ 4294967295 |
| `uint64` | 64bit符号なし整数 | 0 ~ 18446744073709551615 |
| `uint` | 32bit or 64bitの符号なし整数<br>**（環境依存）** | 0 ~ 18446744073709551615 <br>*or*<br>0 ~ 4294967295 |
| `uintptr` | ポインタの値 | ポインタの値をそのまま格納するのに十分な大きさの符号なし整数<br>（環境依存） |



#### 符号付き整数
| 型名 | 説明 | 範囲 |
|:--|:--|--:|
| `int8` | 8bit符号付き整数 | -128 ~ 127 |
| `int16` | 16bit符号付き整数 | -32768 ~ 32767 |
| `int32` | 32bit符号付き整数 | -2147483648 ~ 2147483647 |
| `int64` | 64bit符号付き整数 | -9223372036854775808 ~ 9223372036854775807 |
| `int` | 32bit or 64bitの符号付き整数<br>**（環境依存）** | -2147483648 ~ 2147483647 <br>*or*<br>-9223372036854775808 ~ 9223372036854775807|
| `rune` |	int32のエイリアス| -2147483648 ~ 2147483647 |


#### 浮動小数点
| 型名 | 説明 | 範囲 |
|:--|:--|:--|
| `float32` | 32bit浮動小数点 | IEEE-754 32bit浮動小数点数 |
| `float64` | 64bit浮動小数点 | IEEE-754 64bit浮動小数点数 |

#### 複素数
| 型名 | 説明 |
|:--|:--|
| `complex64` | 実数部・虚数部をfloat32で表現する複素数 |
| `complex128` | 実数部・虚数部をfloat64で表現する複素数 |

### 文字列型
| 型名 | 説明 |
|:--|:--|
| `string` | 文字列(ダブルクオートで囲む)|

## 型の扱い
### 整数リテラル
Goの整数リテラルにはC言語と同じく3種類存在する。

- 10進数・・・`[1-9][0-9]*` 例: `123`
- 8進数・・・`0[1-7][0-7]*` 例: `0755`
- 16進数・・・`0[Xx][0-9A-Fa-f]+` 例: `0x0719BEEF`

### その他のリテラル
整数型以外も含めると、リテラルには下記がある。

```go
i := 1	// int型

f64 := 1.0	// float64型
f32 := float32(1.0)	// float32型のリテラルは存在しない。型変換が必要。

zero := 0.0	// float64型
pinf := 1.0 / zero	// +Inf 正の無限大(float64型)
ninf := -1.0 / zero	// -Inf 負の無限大(float64型)
nan := zero / zero	// NaN 非数(float64型)

// その他の浮動小数点型リテラル
0.
72.40
072.40	// 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

c := 1.0 + 3i	// complex128型
c2 := complex(1.0, 3)	// complex128型(組み込み関数を使用)
r := real(c2)	// 1.0(実部)
i := imag(c2)	// 3.0(虚部)

// その他の複素数型リテラル
0i
011i	// 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

rune := '松'	// == 26494 rune型(int32のエイリアス)

// その他のruneリテラル
'\a' 'U+0007'	// ベル
'\b' 'U+0008'	// バックスペース
'\f' 'U+000C'	// フィード
'\n' 'U+000A'	// 改行(LF)
'\r' 'U+000D'	// 改行(CR)
'\t' 'U+0009'	// 水平タブ
'\v' 'U+000b'	// 垂直タブ
'\\' 'U+005c'	// バックスラッシュ
'\'' 'U+0027'	// シングルクォート(ルーンリテラルのみ)
'\"' 'U+0022'	// ダブルクォート(文字列リテラルのみ)

'a'
'本'
'\t'

// 8進数3桁
'\000'
'\007'
'\377'

// 16進数2桁
'\x07'
'\xff'

// 16進数4桁(小さいUnicodeコードポイント)
'\u12e4'

// 16進数8桁(大きいUnicodeコードポイント)
'\U00101234'

"文字列"	// 文字列リテラル


`
abcd
efg
hijk
`	// RAW文字列リテラル(改行や特殊文字を後処理せずそのまま扱う)
```

### 型変換
Goでは、**異なる型の暗黙的な型変換を許容しない**。したがって、下記のコードはコンパイルエラーとなる。

```go
var (
	n1 int
	n2 int64
)
n1 = 1
n2 = n1	// コンパイルエラー
```

明示的な型変換は可能。下記のように、`型名(変換対象)`と記述することで型変換できる。

```go
i := 17				// 型指定子がないとリテラルの型(この場合はint型)の変数iにint型の17を代入
n := uint(17)		// uint型の変数nにuint型の17を代入
b := byte(n)		// byte型に変換
i64 := int64(n)		// int64型に変換
u32 := uint32(n)	// uint32型に変換
```

#### 整数型の型変換時の"ラップアラウンド"
下記の場合は、整数リテラル(int)からbyte型へのナローイング変換をコンパイラが検知して、コンパイルエラーとなる。

```go
b := byte(256)	// コンパイルエラー
```

しかし、いったんint型の変数に値を代入して、それを型変換変換すると、ナローイング変換できてしまう。下記の場合、`b`は`0`となる。

```go
n := 256
b := byte(n)	// b == byte(0)
```

Go言語は、C言語と同様に、オーバーフローした時にその型で扱えない桁のビットを単純に無視する。これにより、ある型において、演算結果を、ある型の`mod`のようなものとして扱うことをラップアラウンドと呼ぶ。

#### 各々の方の最大値・最小値を使ったラップアラウンド対策
Goでは、C言語と同様にオーバーフローを考慮した演算を行う必要がある。  
この際に、`math`パッケージに用意されている<u>各々の方の最大値・最小値</u>を使用することができる。


```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("uint32 max value = %d\n", math.MaxUint32)	// uint32 max value = 4294967295
}
```

各々の型の最大値・最小値は下記の通り。

```Go
MaxInt8 =  1 << (8 - 1) - 1
MinInt8 = -1 << (8 - 1)

MaxInt16 =  1 << (16 - 1) - 1
MinInt16 = -1 << (16 - 1)

MaxInt32 =  1 << (32 - 1) - 1
MinInt32 = -1 << (32 - 1)

MaxInt64 =  1 << (64 - 1) - 1
MinInt64 = -1 << (64 - 1)

MaxUInt8 = 1 << 8 - 1
MaxUInt16 = 1 << 16 - 1
MaxUInt32 = 1 << 32 - 1
MaxUInt64 = 1 << 64 - 1

MaxFloat32 = 2**127 * (2**24 - 1) / 2**23
SmallestNonzeroFloat32 = 1 / 2**(127 - 1 + 23)
MaxFloat64 = 2**1023 * (2**53 - 1) / 2**52
SmallestNonzeroFloat64 = 1 / 2**(1023 - 1 + 52)
```

上記の型の最大値・最小値を使用すれば、オーバーフローに(比較的)楽に対応できる。

```go
func sum(a, b uint32) bool {
	if (math.MaxUint32 - a) < b {
		// オーバーフローする
		return false;
	}

	sum := a + b	// このパスではオーバーフローしないことを保証済み
	return sum
}
```

## 配列型
配列の型名は`[要素数]型名`となる。その後に続けた`{}`によって初期値を指定できる。  
インデックスは、一般的な言語と同じく**0始まり**。  
**初期値を与えなかった場合、各要素は0で初期化される。**

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println("%v", a)	// => "[1, 2, 3, 4, 5]"

a[0]	// 1
a[1]	// 2
a[2]	// 3
a[3]	// 4
a[4]	// 5
a[5]	// エラー:範囲外
a[-1]	// エラー:負数を指定

a := [5]int{1, 2, 3, 4, 5, 6}	// エラー:初期値の個数が要素数を超過
b := [5]int		// == [0, 0, 0, 0, 0]
c := [5]int{}	// == [0, 0, 0, 0, 0]

ia := [3]int{}	// == [0, 0, 0]
ua := [3]uint{}	// == [0, 0, 0]
ba := [3]bool{}	// == [false, false, false]
fa := [3]float64{}	// == [0, 0, 0]
ca := [3]complex128{}	// == [(0+0i), (0+0i), (0+0i)]
ra := [3]rune{}	// == [0, 0, 0]
sa := [3]string{}	// == ["", "", ""]

aa := [0]int{}	// 要素数が0の配列も定義可能(使いどころは無さそうだが)
```

要素数を省略するには`[要素数]`の部分を`[...]`と記述する。

```go
a1 := [...]int{1, 2, 3}			// == [3]int{1, 2, 3}
a2 := [...]int{1, 2, 3, 4, 5}	// === [5]int{1, 2, 3, 4, 5}
a3 := [...]int{}				// == [0]int{}
```

要素へ値を代入するには`array[n] = value`の形で記述する。

```go
a := [...]int{1, 2, 3}	// == [1, 2, 3]
a[0] = 0
a[2] = 100
// a == [0, 2, 100]
```

**NOTE**  
配列を、他の配列に代入することも可能。ただし、要素の型と要素数が一致している必要がある。  

**NOTE**  
配列の代入は、ディープコピーとなる。すなわち、配列の代入後に、片方の配列を書き換えても、もう片方の配列は変化しない。

**NOTE**  
Goでは、配列のサイズを拡張することはできない(例えば`[]int`は可変長配列ではない)。  
そのかわり、Goでは**Slice(スライス)**というデータ構造を可変長配列のように扱うことができる。

## `interface{}`型と`nil`
`interface{}`は、`{}`も含めて型名。  
`interface{}`は、Goの全ての型と互換性のある型。
すなわち、`int`, `float64`,`string`なども全て`interface{}`と互換性がある。  
近いイメージとしては、C言語における汎用ポインタ`(void*)`や、JavaやC#における`Object`クラスがある。

`interface{}`は他の型と同様に変数定義できる。デフォルト値は`nil`。

```go
var x interface{}
fmt.Println("%#v", x)	// => "<nil>"
```

<u>`nil`とは、Goにおいて**具体的な値を持っていない状態を表す値**で、C言語、Java、C#における`null`のようなもの。</u>

`interface{}`型の変数であれば、次のように、あらゆる型の値を代入できる。

```go
var x interface{}
x = 1
x = 3.14
x = '山'
x = "文字列"
x = [...]uint8{1, 2, 3, 4, 5}
```

一旦`interface{}`型に格納されてしまった値は、元の型情報を失ってしまう。  
そのため、例えば`int`型の値を`interface{}`型の変数に代入すると、`+`演算が出来なくなる。

```go
var x, y interface{}
x, y = 1, 2
z := x + y	// 演算できないためエラーとなる
```

## 演算子
`Go`では下記の演算子が使用できる。

|種類|&nbsp;&nbsp;演算子|
|----|------|
|算術|&nbsp;&nbsp;+ - * / % & \| ^ ^& << >> |
|比較|&nbsp;&nbsp;== != < <= > >=|
|論理|&nbsp;&nbsp;\|\| &&|
|単行|&nbsp;&nbsp;+ - ! ^ * & <-|
<br/>

|優先度|&nbsp;&nbsp;演算子|
|------|------|
|高    |&nbsp;&nbsp;* / % << >> & &^|
|      |&nbsp;&nbsp;+ - \| ^|
|      |&nbsp;&nbsp;== != < <= > >=|
|      |&nbsp;&nbsp;&&|
|低    |&nbsp;&nbsp;\|\||

### 演算子の意味と対象の型

|演算子|&nbsp;&nbsp;意味|&nbsp;&nbsp;対象の型|
|------|----|--------|
|+(単項)|&nbsp;&nbsp;意味なし(`0 + x`と等価)|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|-(単項)|&nbsp;&nbsp;符号反転|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|^(単項)|&nbsp;&nbsp;ビットの補数|&nbsp;&nbsp;整数、浮動小数点数|
|+(2項)|&nbsp;&nbsp;和|&nbsp;&nbsp;整数、浮動小数点数、複素数、文字列(文字列結合)|
|-(2項)|&nbsp;&nbsp;差|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|*(2項)|&nbsp;&nbsp;積|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|/(2項)|&nbsp;&nbsp;商(商は0の方向へ切り捨て/切り上げされる)|&nbsp;&nbsp;整数、浮動小数点数、複素数|
|%(2項)|&nbsp;&nbsp;剰余|&nbsp;&nbsp;整数|
|&(2項)|&nbsp;&nbsp;論理積(ビット演算)|&nbsp;&nbsp;整数|
|\|(2項)|&nbsp;&nbsp;論理和(ビット演算)|&nbsp;&nbsp;整数|
|^(2項)|&nbsp;&nbsp;排他的論理和(ビット演算)|&nbsp;&nbsp;整数|
|&^(2項)|&nbsp;&nbsp;ビットクリア(`a &^ b == a & (^b)`)|&nbsp;&nbsp;整数|
|<<(2項)|&nbsp;&nbsp;左シフト(ビット演算)|&nbsp;&nbsp;整数|
|>>(2項)|&nbsp;&nbsp;右シフト(ビット演算)|&nbsp;&nbsp;整数|
|==|等しい|比較可能な型|
|!=|等しくない|比較可能な型|
|<|未満|順序が有る型|
|<=|以下|順序が有る型|
|>|超|順序が有る型|
|>=|以上|順序が有る型|
|&&|and(論理値)|論理値|
|\|\||or(論理値)|論理値|
|!|not(論理値)|論理値|
<br/>

比較可能な型
: 論理値、整数値、浮動小数点数、複素数、文字列

順序が有る型
: 整数値、浮動小数点数、文字列

**NOTE**
`a = a [演算子] b`という形の2項演算子は`a [演算子]= b`という短縮形を持つ。

## 関数
 

 ```go
func 関数名([引数名 型名]*) 戻り値の型名* {
	処理
}
 ```

### [引数名 型名]*
同じ型の引数を指定する場合、`x, y int`のように型の指定を一つにまとめることも、`x int, y int`のように変数ごとに型名を指定することもできる。

### 戻り値のない関数
戻り値のない関数は、下記のように戻り値の型名を省略することで定義できる。

```go
func 関数名([引数名 型名]*) {
	処理
}
 ```

### 複数の戻り値を持つ関数
Goでは複数の戻り値を持つ関数を定義できる。

```go
func 関数名([引数名 型名]*) (戻り値の型名1, 戻り値の型名2) {
	処理
	return 戻り値1, 戻り値2
}
```

複数の戻り値を持つ関数の戻り値は下記のように受け取る

```go
a, b := f(x, y)
```

複数の戻り値に不要なものがある場合、下記のように`_`を使うことで破棄できる。

```go
// 2つ目の戻り値を破棄
q, _ := f(x, y)

// 型推論できないためコンパイルエラー
_, _ := f(x, y)

// コンパイルエラーとはならないが、ただの関数呼び出しと等しいため無意味
_, _ = f(x, y)
```

### Goにおけるエラー処理
Goには例外機構がない。  
Goにおける一般的なエラー処理では、下記のイディオムを用いる。  
複数の戻り値を用いて、最後の戻り値でエラー内容を表すことで、関数の呼び出し元に自主的にエラー判定を行わせる。  

```go
result, err := f(x, y)
if (err != nil) {
	// エラー発生時の処理を書く
}
```

この方法は、C言語ライクのエラー判定をやりやすくした程度で原始的だが、単純で良いと思う。  
エラー用の戻り値を読み捨てるような使い方をされる可能性があるが、そもそも`err`は契約的プログラミングでいう事前条件違反を表すものと考えれば、むしろエラーハンドリングの責務を明確にできるのかもしれない。

### 戻り値を表す変数
Goでは戻り値に変数を割り当てることができる。

```go
package main

import (
	"fmt"
)

func f() (a int) {	// 戻り値に変数aを割り当てた
	return
}

func main() {
	fmt.Println(f())	// => 0 (== aのデフォルト値)
}
```

上記の構文は、下記のコードの短縮形と考えられる。

```go
// 短縮形
func f() (a int) {
	return
}

// 短縮していない形
fnc f() int {
	var a int
	return a
}
```

複数の戻り値に対しても変数を割り当てることができる。

```go
// 短縮形
func f() (a, b int) {
	b = 5
	return	// x === 0, y == 5
}

// 短縮していない形
func f() (int, int) {
	var a, b int
	b = 5
	return a, b	// x === 0, y == 5
}
```

### 引数を無視する
戻り値と同じく、引数も破棄することができる。  
インターフェースで定義されているプロトタイプを実装するとき、実装で使用しない場合に、それを明示する場合に使用すると無駄な変数割り当てが発生しない。

```go
func f(_, _ int) int {
	return 1
}

f(2, 3)	// => 1
```

### 無名関数
Goでは、関数を変数に代入できる。  
名前がある関数を代入できるのはもちろんのこと、下記のように関数定義自体をそのまま代入することもできる。

```go
f := func(x, y int) int { return x + y}
```

上記の右辺のように、関数を名前無しで定義して、それ自身を変数に代入できる。  
このとき、右辺を**関数リテラル**と呼ぶ。

関数リテラルの型は、その関数の引数の型と戻り値の型の組となる。  

```go
fmt.Println("%T\n", func(x, y int) int {return x + y})
// => "func(int, int) int"
```

したがって、意味はないが、変数を、この型で定義することもできる。

```go
var f func(int, int) int
f = func(x, y int) int { return x + y}
```

### 高階関数(関数を返す関数)
```go
package main

import (
	"fmt"
)

func F() func() {	// 戻り値の型 func()
	return func() {
		fmt.Println("Hello, World!")
	}
}

func main() {
	function := F()
	function()	// "Hello, World!"

	// F()で帰ってきたfを同時に呼び出す
	F()()	// "Hello, World!"
}
```

### 高階関数(関数を引数に渡す関数)

```go
package main

import (
	"fmt"
)

func F(f func()) {
	f()
}

func main() {
	F(func() { fmt.Println("Hello, World!") })	// "Hello, World!"
}
```

### クロージャ
Goではクロージャも定義できる。

```go
package main

/**
 * "nextに値を渡すとその値を内部に保持し、その前にnextに渡した値を返す"関数を返す
 */
func later() func(string) string {
	var store string
	return func(next string) string {
		s := store
		store = next
		return s
	}
}

func main() {
	f := later()
	f("Golang")	// => ""
	f("is")	// => "Golang"
	f("good")	// => "is"
}
```

#### クロージャでジェネレータを実装する
```go
package main

/**
 * "nextに値を渡すとその値を内部に保持し、その前にnextに渡した値を返す"関数を返す
 */
func integers() func() int {
	index := -1
	return func() int {
		index += 1
		return index
	}
}

func main() {
	f := integers()
	f()	// => 0
	f()	// => 1
	f()	// => 2
	f()	// => 3
	f2 := integers()
	f2()	// => 0
	f2()	// => 1
}
```

## 定数
Goでは`const`を使用して定数を定義できる。

```go
const X = 1	// 定数1(整数)
```

複数の定数をまとめて定義することもできる。

```go
const (
	X = 1
	Y = 2
	Z = 3
)
```

- **NOTE**  
  - 途中から定数に定義する値を省略した場合、前回定義したのと同じ値を定数定義する。  
    ただし、全ての定数定義の値を省略することはできない。
  - 定数の値の定義には任意の式を使用でき、さらに、その中に他の定数を使用できる。

```go
const (
	X = 1
	Y = 2
	Z	// 2
)

// コンパイルエラー
const (
	X
	Y
	Z
)

const (
	A = 1	// 1
	B = A + 1	// 2
	C = B + 1	// 3
	Z = X + Y	// 9 この行の後に定義されている定数も使用可能
	X = 2
	Y = 7
)
```

### 定数の型
Goの定数定義では、下記のいずれかの値を定義できる。

- 論理型
- 整数(**「整数」であり、int等の型ではない**)
- 浮動小数点数(**「浮動小数点数」であり、float64等の型ではない**)
- 複素数
- ルーン
- 文字列

型を指定子ない定数定義では、整数はあくまでも整数であり、intやuintなどの区別はない。  
型ありの定数を定義したい場合は、下記のように型を指定して定数定義する。

```go
const (
	I64 int64 = -1	// 定数I64はint64型
	I32 = int32(-1)	// 定数32はint32型
	F64 float64 = 1.2	// 定数F64はfloat64型
	F32 = float32(1.2)	// 定数F32はfloat32型
)
```

### 各定数の注意
#### 論理値の定数
論理値はbool型と全く同じであるため、使用上の注意は特に無し。

#### 整数値の定数
整数値の定数には最大値/最小値がないため、定数定義するぶんにはいくらでも大きな/小さな数値を定義できる。
しかし、変数への代入の際にコンパイルエラーとなる。  
このように、分かりやすさを優先するため、できる限り定数には型を指定したほうが良い。

```go
const (
	N = 9999999999999999999999999999999999999999999999999999999
)
i := N	// コンパイルエラー
```

**NOTE**  
数値定数同士の演算はコンパイル時に処理されるという性質がある。  
そのため、下記のコードは問題なく動作する。

```go
const (
	// uint64型の最大値より1大きな整数値
	N = 18446744073709551615 + 1
)

n := uint64(N - 1)

// コンパイル時に下記の形に変換されて評価されるため、エラーとならない
n := uint64(18446744073709551615)
```

#### 浮動小数点数の定数
浮動小数点数の型(float64, float32)よりも高い精度の少数を定数定義することは可能。  
ただし、float64またはfloat32のどちらかに変換した型が許容するまで精度が落ちる。

**NOTE**  
変数を介さず、定数のみで演算することで、コンパイル時に精度を落とさず演算できる。

#### 複素数の定数
複素数リテラルを使用して定数定義できる。  
複素数の実部・虚部ともに浮動小数点数と同様の精度を備えている。

#### ルーン、文字列の定数
ルーンリテラル、文字列リテラルを使用して、rune型および文字列型の定数を定義できる。  
文字列型定数の定義ではRAW文字列リテラルも使用できる。

### `iota`によるenumのような定数定義
定数定義ブロック内で`iota`キーワードを使用することで、連番の定数を簡単に定義できる。  
ただし、無駄に複雑な定数定義は混乱を招くので、関連の有る単位で定数ブロックを分けること。

- **NOTE**
  - `iota`は0始まり。次の行の定数では+1される。
  - `iota`は省略可能。
  - 異なる値を定義した場合はその値になるが、`iota`自体は行ごとに必ずインクリメントされている。
  - コードブロックごとに`iota`は0にリセットされる。

```go
const (
	A = iota	// 0
	B			// 1
	C			// 2
)

const (
	D = 1 + iota	// 1
	E = 1 + iota	// 2
	F = 1 + iota	// 3
	FF = iota		// 3
)

const (
	G = 1 + iota	// 1
	H				// 1 + iota == 2
	I				// 1 + iota == 3
)

const (
	J = iota	// 0
	K = 100		// 100
	L			// 100
	M = iota	// 4
	N			// 5
)
```

## スコープ
