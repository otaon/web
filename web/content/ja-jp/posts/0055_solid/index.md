---
title: "オブジェクト指向原則集(SOLID、他)"
date:    2019-05-05T00:00:00+09:00
lastmod: 2019-05-05T00:00:00+09:00
draft: false
toc: true
tags: ["programming", "オブジェクト指向", "OOP", "SOLID", "SRP", "OCP", "LSP", "ISP", "DIP"]
categories: ["programming"]
authors:
- otaon
---

# 目的
プログラミングや設計において守るべき、クラスに関する原則である「SOLID原則」についての学習記録を残す。

# 参考文献
- SOLIDについて
  - [POSTD - 開発者が知っておくべきSOLIDの原則](https://postd.cc/solid-principles-every-developer-should-know/)
    - 原文 [Bits and Pieces - SOLID Principles every Developer Should Know](https://blog.bitsrc.io/solid-principles-every-developer-should-know-b3bfa96bb688)
  - [Qiita - オブジェクト指向の法則集](https://qiita.com/kenjihiranabe/items/9eddc70e279861992274)
  - [Wikipedia - 開放/閉鎖原則](https://ja.wikipedia.org/wiki/%E9%96%8B%E6%94%BE/%E9%96%89%E9%8E%96%E5%8E%9F%E5%89%87)
  - [Wikipedia - リスコフの置換原則](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87)
  - [Wikipedia - 依存性逆転の原則](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E9%80%86%E8%BB%A2%E3%81%AE%E5%8E%9F%E5%89%87)
  - [SlideShare - 20160526 依存関係逆転の原則](https://www.slideshare.net/ShintaroKurosawa/20160526-62511723)
  - [The Interface Segregation Principle (ISP)　インターフェース分離原則](http://etc9.hatenablog.com/entry/20090925/1253883259)
- Graphvizについて(本稿の図作成に使用)
  - [いろは二〇八 - Graphvizの基本 - 02](https://iroha208.com/categories/graphviz/02/)
  - [Qiita - Graphvizとdot言語でグラフを描く方法のまとめ](https://qiita.com/rubytomato@github/items/51779135bc4b77c8c20d)
  - [Graphviz - Node, Edge and Graph Attributes](https://www.graphviz.org/doc/info/attrs.html)
- その他
  - 本稿の各引用箇所に記載

# クラスに関する原則「SOLID原則」について
SOLID原則とは、プログラミングや設計において守るべき主要な原則5つをまとめたもの。

|&nbsp;頭文字|&nbsp;略称|&nbsp;英名|&nbsp;和名|
|---|---|---|---|
| &nbsp;**S** | &nbsp;SRP | &nbsp;Single Responsibility Principle     | &nbsp;単一責任の原則 |
| &nbsp;**O** | &nbsp;OCP | &nbsp;The Open-Closed Principle           | &nbsp;開放／閉鎖原則 |
| &nbsp;**L** | &nbsp;LSP | &nbsp;The Liskov Substitution Principle   | &nbsp;リスコフの置換原則 |
| &nbsp;**I** | &nbsp;ISP | &nbsp;The Interface Segregation Principle | &nbsp;インターフェース分離原則 |
| &nbsp;**D** | &nbsp;DIP | &nbsp;The Dependency Inversion Principle  | &nbsp;依存性逆転の原理 |

## **S** : Single Responsibility Principle (SRP) : 単一責任の原則

## **O** : The Open-Closed Principle (OCP) : 開放／閉鎖原則
OCPは、プログラムや設計の拡張・修正に対する下記の原則のこと。

- 拡張に対して開いているべき (開放原則(open))
  - 機能拡張はコード修正によってではなく、コードの追加によって実現せよ
  - これが守られている⇒既存コード(共通ライブラリ等)を変更せずに機能拡張できる
  - これが守られていない⇒既存コード(共通ライブラリ等)を変更する必要がある
- 修正に対して閉じているべき (閉鎖原則(closed))
  - コードに修正が必要になった時、不要に影響範囲が漏れ出ることを避けよ
  - これが守られている⇒修正コードのみテストすれば良い(共通ライブラリ等はテストせずに済む)
  - これが守られていない⇒修正コード(修正の入った共通ライブラリ等もテストする必要がある)

上記の原則を満たすコードは、機能拡張の際に既存のコードに影響しないと考えて良い。(トートロジーじみているが。)  

開放/閉鎖原則の詳細については「[オブジェクト指向原則集(SOLID、他):開放／閉鎖原則について]({{<relref "posts/0056_solid_OCP/index.md" >}})」を参照。

## **L** : The Liskov Substitution Principle (LSP) : リスコフの置換原則
> `T` 型のオブジェクト`x`に関して真となる属性を`q(x)`とする。  
> このとき`S`が`T` の派生型であれば、`S`型のオブジェクト`y` について`q(y)`が真となる。

`S`が`T`の派生型であれば、プログラム内で`T`型のオブジェクトが使われている箇所は全て`S`型のオブジェクトで置換可能であるべき。

リスコフの置換原則を契約プログラミングに適用すると、契約と継承の相互作用に次のような制約をもたらす

- 派生型は、事前条件を強めることはできない。つまり、上位の型よりも強い事前条件を持つ派生型を作ることはできない。
  - サブクラスは、スーパークラスが呼び出せる状況なら必ず呼び出せること。
- 派生型は、事後条件を弱めることはできない。つまり、上位の型よりも弱い事後条件を持つ派生型を作ることはできない。
  - サブクラスは、スーパークラスが達成することは必ず達成すること。

リスコフの置換原則の詳細については「[オブジェクト指向原則集(SOLID、他):リスコフの置換原則について]({{<relref "posts/0057_solid_LSP/index.md" >}})」を参照。

## **I** : The Interface Segregation Principle (ISP) : インターフェース分離の原則
インターフェース分離の原則は、下記の通り。

- クライアントは自分が使うインタフェースだけを依存すべきである
- 単一のインタフェースより複数のインタフェースを使うべきである
- インタフェースをクライアントごとに分離すべきである

あるいは、下記のように言い表せる。

> 顧客に特化した細粒度のインタフェースを作れ。  
> 顧客は自分たちが使わないインターフェースに依存することを強いられるべきではない。

つまり、一つのインターフェースに、不必要に多くのメソッドを定義するのは得策ではない。

### インターフェース分離の原則に違反したコード
下記のようにインターフェースを定義してしまうと、ユーザーが`Circle`クラスのみを欲していたとしても、下記のように、`DrawSquare()`、`DrawRectangle()`を定義しなければならない。

```cs
interface IShape
{
    void DrawCircle();
    void DrawSquare();
    void DrawRectangle();
}

class Circle : IShape {
	public void DrawCircle()
	{
		// ...
	}
	public void DrawSquare()
	{
		// ...
	}
	public void DrawRectangle()
	{
		// ...
	}
}
```

### インターフェース分離の原則に適合したコード
下記のように、インターフェースをユーザの用途に合わせて適切に分離して定義していれば、ユーザのクラスに余計なメソッドを定義せずに済む。

```cs
interface ICircle
{
	void DrawCircle();
}

interface ISquare
{
	void DrawSquare();
}

interface IRectangle
{
	void DrawRectangle();
}

class Circle : ICircle
{
	public void DrawCircle()
	{
		// ...
	}
}
```

## **D** : The Dependency Inversion Principle (DIP) : 依存性逆転の原理
この原則は、下記のことを表す。

- 上位レベルのモジュールは、下位レベルのモジュールに依存すべきではない
- 上位レベルのモジュール、下位レベルのモジュール、ともに抽象（abstractions)に依存すべき
- 抽象は、詳細に依存してはならない
- 詳細は、抽象に依存すべき

依存性逆転の原理の詳細については「[オブジェクト指向原則集(SOLID、他):依存性逆転の原理について]({{<relref "posts/0058_solid_DIP/index.md" >}})」を参照。

----
# パッケージに関する原則
パッケージとは、複数のクラスをひとまとめにした単位。  
このパッケージの構成に関しても、原則が存在する。

最近では、2018年にO'REILLYから、[Principles of Package Design: Creating Reusable Software Components](https://www.oreilly.com/library/view/principles-of-package/9781484241196/)という電子書籍が出ており、これにも掲載されているらしい(未確認だが)。

|&nbsp;種別|&nbsp;略称|&nbsp;英名|&nbsp;和名|
|---|---|---|---|
| &nbsp;パッケージ凝集 | &nbsp;REP | &nbsp;The Reuse/Release Equivalence Principle | &nbsp;再利用開放等価原則 |
| &nbsp;〃             | &nbsp;CRP | &nbsp;The Common Reuse Principle              | &nbsp;共通再利用原則 |
| &nbsp;〃             | &nbsp;CCP | &nbsp;The Common Closure Principle            | &nbsp;共通閉鎖原則 |
| &nbsp;パッケージ結合 | &nbsp;ADP | &nbsp;The Acyclic Dependencies Principle      | &nbsp;非環式依存原則 |
| &nbsp;〃             | &nbsp;SDP | &nbsp;The Stable Dependencies Principle       | &nbsp;安定依存原則 |
| &nbsp;〃             | &nbsp;SAP | &nbsp;The Stable Abstractions Principle       | &nbsp;安定抽象概念原則 |

## パッケージ凝集に関する原則
あるパッケージの責務分割に関する原則。  
この原則に則ると、パッケージを高凝集にできる。

- [Wikipedia - 凝集度](https://ja.wikipedia.org/wiki/%E5%87%9D%E9%9B%86%E5%BA%A6)

### The Reuse/Release Equivalence Principle (REP) : 再利用開放等価原則
パッケージのリリースと再利用の関係に関する原則。

[A Memorandum - The Reuse/Release Equivalence Principle (REP)　再利用開放等価原則](http://etc9.hatenablog.com/entry/20090926/1253974827)

> 個々のクラスを集めたパッケージに関する原則です。この REP は、パッケージを再利用可能にするためのシステムについて述べたものです。一般に、クラス単体は再利用可能ではありません。あるクラスは他のクラスに依存している場合がほとんどです。再利用可能にするには、クラス群をリリースする単位としてパッケージ化し、バージョン管理を行うようにすべきだ、ということです。そういうシステムがない限り再利用はうまくいかないということでしょう。
> 
> 再利用の単位（パッケージ）がリリースの単位より小さくなってはいけない。パッケージに含まれる個々のクラス単位で再利用するのではなく、パッケージごと再利用できるようにすべきである。つまり、リリースはパッケージの単位で行う必要がある。また、パッケージを分割する際には、それを再利用する側の視点に立って個々のパッケージを構築すべきである。

リリースは、最小でもパッケージ単位で行うべきということ。
パッケージ単位でリリースすれば、リリース毎のバージョン整合が取れている限りはシステムが整合する。
反対に、例えばクラス毎でリリースしてしまうと、各クラスのバージョン違いが発生してシステムが破綻する恐れがある。  
ただし、バージョン設計が正しくなされていることが前提。

### The Common Reuse Principle (CRP) : 共通再利用原則
パッケージが再利用できるように、パッケージを切る単位(=パッケージにどのクラスを入れるか)を考える際に則るべき原則。  
ユーザが使用するクラス/使用しないクラスという観点で述べられている。

[A Memorandum - The Common Reuse Principle (CRP)　共通再利用原則](http://etc9.hatenablog.com/entry/20091017/1255749130)

> パッケージに入れるクラスは何にするかという判定基準を再利用の観点から表したものです。あるパッケージをバージョンアップする場合、利用している側のソフトウェアにとって関係のないクラスが修正されたにも関わらず更新しなければならない、というのはおかしな話です。パッケージをリリースしたあとの配布の問題を考えてもこうなっていることが理想です。Interface Segregation Principle のパッケージ版といえます。
> 
> パッケージを利用する側の視点に立ってパッケージを構築すること。クライアントから利用されないクラスは、同一パッケージに含めてはならない。パッケージにクライアントが利用しないクラスが含まれていれば、クライアントには本来関係のないそれらのクラスの修正に伴ってパッケージが再リリースされることになる。これは先の「再利用・リリース等値の原則」に違反することにもなる。

パッケージは、ユーザが使用するクラスと使用しないクラスが混在しないようにすべきということ。
さもなくば、ユーザが使用しないクラスのバージョンアップがあった場合にもパッケージが更新され、ユーザにバージョンアップを強いることになる。

### The Common Closure Principle (CCP) : 共通閉鎖原則
パッケージが再利用できるように、パッケージを切る単位(=パッケージにどのクラスを入れるか)を考える際に則るべき原則。  


[A Memorandum - The Common Closure Principle (CCP)　共通閉鎖原則](http://etc9.hatenablog.com/entry/20090927/1254035143)

> クラスをどのようなパッケージとしてまとめるか？ という判定基準をメンテナンス性の観点から表したものです。ソフトウェアを修正しなければならない場合、その修正があるパッケージの中で閉じているにこしたことはありません。そのため将来起こるであろう変更を想定した場合、同時に修正することになるクラスは同じパッケージとして管理するべきです。
> 
> この原則は、クラスに関する設計原則である「単一責任の原則」をパッケージに当てはめたものになります。クラスの変更理由が1つでなければいけないように、パッケージの変更理由も複数存在してはならないということになります。変更理由が複数のパッケージにまたがってしまえば保守性が低下します。つまり、パッケージは変更理由が同じクラス群で構成されるべきということです。こうすることでリリースの単位とパッケージの単位を同じにすることができるようになります。

あるパッケージ内のクラスは、同種の変更理由に対して共に閉じている必要がある。  
つまり、とある1つの理由で変更されるパッケージは、ただ1であるべき。  
さもなくば、何かの理由でソフトウェアの変更が発生した際、変更箇所が複数のパッケージにまたがってしまい保守性が低下する。

## パッケージ結合に関する原則
あるパッケージの結合度に関する原則。  
この原則に則ると、パッケージ同士を疎結合にできる。

- [Wikipedia - 結合度](https://ja.wikipedia.org/wiki/%E7%B5%90%E5%90%88%E5%BA%A6)

### The Acyclic Dependencies Principle (ADP) : 非環式依存原則
パッケージの依存関係に関する原則。

[A Memorandum - The Common Closure Principle (CCP)　非環式依存原則](http://etc9.hatenablog.com/entry/20091018/1255926653)

> パッケージ間に依存の循環があれば、1つのパッケージ内のクラスに対する修正の影響が、関連するすべてのパッケージに及ぶ。パッケージをビルドする順番に制約があるような場合がよい例である。これではせっかくパッケージとして分割されていても、実際は分割されていないのと同じである。
> 
> パッケージ間の循環を断つ手段として次の2つの方法が存在する。
> 
> 　1つ目の方法は、クラスに関する設計原則である「依存関係逆転の原則」を適用する方法。例えばパッケージMyGuiPartsのクラスXがパッケージMyApplicationのクラスYに依存しているような場合には、パッケージMyGuiParts内にクラスXが利用する抽象インターフェイスを配置し、その派生クラスとしてYクラスをパッケージMyApplication内に配置する。こうすることでパッケージMyGuiPartsとパッケージMyApplicationの依存関係が逆転して循環が断たれる。
> 
> もう1つの方法は新たなパッケージを追加する方法である。新たに追加したパッケージに依存元が参照しているクラスを移動させることで循環が断たれる。

パッケージの依存関係は、有向非巡回グラフとなっている必要がある。  
つまり、依存関係が循環してはいけない。  
さもなくば、循環関係にあるパッケージ1つをバージョンアップしたい場合、そのパッケージと循環関係ある全パッケージを同時にバージョンアップする必要がある。

### The Stable Dependencies Principle (SDP) : 安定依存原則
パッケージの依存関係に関する原則。  
依存関係にあるパッケージ同士の安定性という観点で述べられている。

[A Memorandum - The Common Closure Principle (CCP)　安定依存原則](http://etc9.hatenablog.com/entry/20091019/1255961020)

> 安定しているパッケージは修正が難しく、不安定なパッケージは修正が容易です。SDP では、パッケージの依存関係はより安定しているパッケージへと向かうべきだ、と言っています。言い変えると、パッケージは、自分よりも不安定なパッケージに依存してはならないとなります。変更が少ない安定したパッケージでも、依存先のパッケージが不安定であればその影響が及んで結局は不安定になってしまう。つまり、末端（依存されるクラスのない）のパッケージから依存関係を上にたどっていくに従って、パッケージの安定度が増すようにすべきである、ということになります。
> 
> さらに突き詰めていくと、システム中のパッケージすべてが安定している必要はないということが言えます。先の「閉鎖性共通の原則」に従って構成されたパッケージは、変更理由が同じクラス群がまとめられており、いい換えると、変更することを意識して作られた不安定なパッケージということになります。システムに柔軟性を持たせようとすれば、このような不安定なパッケージと安定したパッケージを混在させる必要が出てきます。ただし、安定依存の原則に従うためには「依存関係逆転の原則」を使用してパッケージ間の依存関係を調整する必要があります。

パッケージは、変更する可能性が高いパッケージに依存すべきではない。
そして、変更する可能性が高いパッケージは、不安定なパッケージになっている。  
したがって、パッケージの依存関係は、**不安定なパッケージ --依存-> 安定なパッケージ**となっている必要がある。  
ここで、安定なパッケージとは、下記の「安定している」に当たるパッケージのこと。  
安定なパッケージは**変更が難しい**。反対に、不安定なパッケージは**変更が容易**。

- 内側結合度 `Ca = このパッケージ内のクラスに依存するクラス数`
- 外側結合度 `Ce = パッケージ外のクラスに依存するパッケージ内のクラス数`
- 不安定度 `I = Ce / (Ca + Ce)`
- 安定している：`Iが小さい`

### The Stable Abstractions Principle (SAP) : 安定抽象概念原則
パッケージの依存関係と抽象度に関する原則。  

[A Memorandum - The Common Closure Principle (CCP)　安定抽象概念原則](http://etc9.hatenablog.com/entry/20091020/1256051472)

> パッケージの依存関係は、抽象度が高いパッケージへと向かうべき、ということで SAP と SDP は Dependency Inversion Principleのパッケージ版となります。
> パッケージの安定度を高めるには、抽象的でなくてはならず、一方、不安定なパッケージは具体的でなくてはならない。パッケージの抽象度を高めれば その安定度も高くなる。その逆もまたしかりと。
> 
> 抽象クラスやインターフェイスは、その派生クラスによって振る舞いが拡張されます。これは抽象クラスやインターフェイスがその派生クラスより安定していることを示しています。つまり、安定したパッケージを構成するためは、パッケージ内での抽象クラスやインターフェイスの割合を高めればよいことになります。さらに、これらの抽象クラスやインターフェイスに依存する派生クラスをまとめて別のパッケージに配置すれば、そのパッケージは不安定なパッケージとなり、安定したパッケージに依存することになります。結果として自然に先の「安定依存の原則」に従うことになります。

パッケージの安定度を最大にするためには、抽象度を最大化する必要がある。  
また反対に、不安定なパッケージは、具象である必要がある。  
したがって、パッケージの依存関係は、具象的なパッケージから抽象的なパッケージに向かうべき。

----
# その他の原則
## The Law of Demeter（デメテルの法則）
デメテルの法則とは、1987年の末にかけてノースイースタン大学で作成された、オブジェクト指向プログラミングにおけるガイドライン。

[Wikipedia - デメテルの法則](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%A1%E3%83%86%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)

### オブジェクト指向におけるデメテルの法則の適用
Wikipediaの文章を少し変更しつつ引用する。

> オブジェクト指向プログラムにデメテルの法則を適用する場合には、この法則はより厳密に「関数/メソッドに関するデメテルの法則」(*Law of Demeter for Functions/Methods, LoD-F*) と言い表すことができる。  
> この場合、下記が成り立つ。
> 
> - あるオブジェクトAは別のオブジェクトBのサービスを要求してもよい
>   - クラスA内でメソッド呼び出し`B.Method()`しても良い
> - オブジェクトAがオブジェクトBを**経由して**更にに別のオブジェクトCのサービスを要求してはならない。
>   - クラスA内で`var c := B.GetC()`して得た`c`に対してメソッド呼び出し`c.Method()`してはならない。
> 
> これが望ましくないのは、オブジェクトAがオブジェクトBに対して、オブジェクトB自身の内部構造以上の知識を要求してしまうためである。 このような場合には、クラスBを変更し、クラスAがクラスBに対して行った要求を適切なBのサブコンポーネントに伝播させるようにすればよい。または、AがCへのリファレンスを持つようにして、AがCを直接呼ぶようにしてもよい。この法則に従えば、オブジェクトBが知っているのは自分自身の内部構造だけになる。

つまり、下記コードは違反となる。

```cs
class A
{
	private B b = new B();

	private void Method()
	{
		b.GetC().Method();	// クラスAが直接参照していないクラスCに対してメソッド呼び出し(=違反)
	}
}
```

上記を適合コードに修正する方法には、主に2通りある。

- 下記のように、クラスAがクラスCに対して行った要求を、クラスBが伝播するようにクラスBを修正する。

```cs
class A
{
	private B b = new B();

	private void Method()
	{
		b.GetCAndMethod();
	}
}

class B
{
	private C c= new C();

	public C GetC()
	{
		return c;
	}

	// このメソッドを新設
	public void GetCAndMethod()
	{
		GetC().Method();
	}
}
```

- 下記のようにクラスA内にクラスCへの参照を持たせ、クラスAからクラスCへ直接要求するように修正する。

```cs
class A
{
	private B b = new B();
	private C c;	// Cへの参照を直接持つ

	private void Method()
	{
		c = b.GetC();	// Aが持つCへの参照をセットするだけなので問題ない
		c.Method();
	}
}
```


> より形式的に言えば、関数に対するデメテルの法則に従った場合、オブジェクトO上のメソッドMが呼び出してもよいメソッドは以下のオブジェクトに属するメソッドのみに限定される。
> 
> 1. Oそれ自身(`this`)
> 1. Mの引数に渡されたオブジェクト
> 1. Mの内部でインスタンス化されたオブジェクト
> 1. Oを直接的に構成するオブジェクト（Oのインスタンス変数）

つまり、呼び出して良いメソッドは下記のパターンに限られる。(番号は上記と対応する)

```cs
class O
{
	private OtherO3 otherO3;

	public void M(OtherO input)
	{
		this.M2();	// OK (1.)
		input.OtherOM();	// OK (2.)
		(new OtherO2).OtherO2M();	// OK (3.)
		otherO3.OtherO3M();	// OK (4.)
	}
}
```

> 具体的には、他のメソッドの戻り値として返されたオブジェクトのメソッドの呼び出しを避けるということになる。最近のオブジェクト指向言語の多くではフィールド識別子としてドット(.)が採用されているが、そのような言語においてはこの法則は単純に「使えるドットは一つだけ」と言い表すこともできる。つまり、"a.b.Method()"という呼び出しは法則に違反しているが"a.Method()"という呼び出しは問題ない。なお、**このアプローチの充足性については反論がある。**

「使えるドットは一つだけ」がデメテルの法則を充足しないのは、例えば下記コードも許してしまうため。

```cs
public void Method(B b)
{
	var c = b.GetC();	// 一時変数を挟むだけでOKとみなされてしまう
	c.Method();
}
```

> 簡単な例として、犬を散歩に連れ出すことを考える。この際、犬の足に直接「歩け」と命じるのはおかしいだろう。この場合は、犬に対して命令し、自分の足の面倒は自分で見させるのが正しい方法だといえる。

### デメテルの法則の利点と欠点
#### 利点

> デメテルの法則の利点としては、結果的にソフトウェアがよりメンテナンスしやすく、柔軟なものになりやすいという点が挙げられる。オブジェクトが他のオブジェクトの内部構造に依存することが少なくなるため、オブジェクトのコンテナを呼び出し側の変更なしに修正することができる。
> 
> Basiliらによる1996年の実験では、デメテルの法則がソフトウェアの欠陥の発生確率を低下させるのに有効であることが示唆されている。
> 
> マルチレイヤアーキテクチャは、ソフトウェアシステムにおいてデメテルの法則を系統的に実装するためのメカニズムとして捉えることができる。 レイヤ化されたアーキテクチャにおいて、各レイヤ中のコードは自分の属するレイヤと直下のレイヤのコードのみを呼び出すことができる。直下のレイヤをスキップして他のレイヤにアクセスした場合には、アーキテクチャに違反していることになる。 

#### 欠点

> デメテルの法則の欠点としては、時として数多くの"ラッパー"メソッド（デメテルのTransmogrifierと呼ばれる）を作成する必要があるという点が挙げられる。このメソッドは自分自身の呼び出しを別のコンポーネントに委譲するためのものである。さらに、自分自身が含んでいるクラスのメソッドを呼び出せるようにするためにインタフェースが巨大になり、結果としてクラスの凝集度が低下するという欠点もある。

利点と欠点を読んで思ったが、結局は、デメテルの法則は厳格すぎて実用性を削いでいると思う。  
厳格に守るべきは、メソッド(例:`C c = b.GetC()`)呼び出しで得られた他オブジェクト(例:`c`)の**内部構造**に依存しないという点ではないか?  
メソッドがインターフェースを返すようにし(例:`IC ic = b.GetIC()`)、そのインターフェースが提供するメソッド(例:`Method()`)は呼び出せるようにすれば良いと思う(例:`ic.Method()`)。こうすれば下記が実現できる。

- 呼び出し元クラス(例:`A`)からは、メソッド呼び出しで得られた他オブジェクト(例:`ic`)を直接使用できる。
- メソッドが呼び出された側(例:`B`)では、返り値のオブジェクト自体(例:クラス`C`)ではなく、インターフェース(例:インターフェース`IC`)を保証するだけで済む(返り値のオブジェクトの内部構造に依存しなくなる)。

…と、ここまで書いているととても当たり前のことしか言っていないように思う。実際、「メソッド利用者側にオブジェクトを返す際には、実体ではなくインターフェースを返す」というのは、よく見かける。上記のような流れで、インターフェースが活躍するようになったのかもしれない。
