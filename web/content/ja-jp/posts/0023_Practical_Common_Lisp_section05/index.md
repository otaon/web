---
title: "書籍 実践 Common Lisp 第5章 関数"
date:    2019-03-07T00:00:00+09:00
lastmod: 2019-03-07T00:00:00+09:00
draft: false
toc: true
tags: ["lisp", "実践-Common-Lisp"]
categories: ["Notes"]
authors:
- otaon
---

## 5.1 新しい関数の定義

```lisp
(defun name (parameter*)
  "省略可能なドキュメンテーション文字列"
  body-form*)
```

## 5.2 関数のパラメータリスト
`parameter`の部分は、関数のパラメータリストと呼ばれる。  
パラメータリストの指定方法は複数ある。  
次の章で、それらについて説明する。

## 5.3 オプショナルパラメータ
必須のパラメータ以外に、任意で指定したいパラメータの前に`&optional`を指定する。  
全ての必須パラメータに値が渡された後、まだ引数が残っていたら、その値がオプショナルパラメータに割り当てられる。  
引数がオプショナルパラメータより先に足りなくなったら、残りのオプショナルパラメータには`NIL`の値が割り当てられる。

```lisp
(defun foo (a b &optional c d)
  (list a b c d))

(foo 1 2)
; => (1 2 NIL NIL)
(foo 1 2 3)
; => (1 2 3 NIL)
(foo 1 2 3 4)
; => (1 2 3 4)
```

オプショナル引数の値が、呼び出し元により指定された`NIL`なのか、それともデフォルトの`NIL`なのかを知るには、下記の通りにする。

```lisp
(defun foo (a b &optional (c 3 c-supplied-p))
  (list a b c c-supplied-p))

(foo 1 2)
; => (1 2 3 NIL)
(foo 1 2 3)
; => (1 2 3 T)
(foo 1 2 4)
; => (1 2 4 T)
```

まとめると、オプショナルパラメータの構文は下記の通りになる。  

- 必須パラメータの後に`&optional`シンボルをつけることで、続く引数がオプショナルパラメータ扱いになる。
- 必須パラメータには、デフォルト値を持たせることができる。
- 必須パラメータには、その引数に値が渡されたかを判定するためのフラグを割り当てることができる。

```lisp
(defun foo (必須パラメータ1 必須パラメータ2 &optional オプショナル1 (オプショナル2 デフォルト値 引数指定判定フラグ)))
```

## 5.4 レストパラメータ
可変個のパラメータを扱うための仕組みとして、レストパラメータがある。  
関数の引数に`&rest`シンボルがあったら、それ以降のパラメータを全てまとめて扱うことができる。  
つまり、`&rest`パラメータが含まれていたら、必須パラメータとオプショナルパラメータに割り当てられた残りの引数はリストにまとめられ、そのリストが`&rest`パラメータの値になる。

```lisp
(defun + (&rest numbers)
  "0個以上の数値を加算する
   numbers: 数値(0..*)"
  ...)
```

```lisp
(defun format (stream string &rest values)
  "文字列を整形して出力する
   stream: 出力ストリーム
   string: 出力対象文字列
   values: フォーマット対象の値"
  ...)
```

まとめると、レストパラメータの構文は下記の通りになる。

- 必須パラメータとオプショナルパラメータの後に`&rest`シンボルをつけることで、続く引数がレストパラメータ扱いになる。
- 必須パラメータに渡された値は、リストとなり、必須パラメータに割り当てられる。


```lisp
(defun foo (必須パラメータ1 必須パラメータ2 &rest レストパラメータ1 レストパラメータ2))
```

## 5.5 キーワードパラメータ
例えば、ある関数に4つの引数を持たせたいとする。  
その関数が呼び出されるとき、ほとんどの呼び出し元は4つのパラメータのうち1つしか渡さず、しかもどのパラメータも偏りなく呼び出されるとする。
そのような場合、キーワードパラメータを使用するとうまく解決できる。  
下記の通り、キーワードパラメータを使えば、関数呼び出しの際の引数の指定の順番によらない処理が可能となる。

```lisp
(defun foo (&key a b c)
  "キーワードパラメータで渡された引数のリストを返す"
  (list a b c))

(foo)
; => (NIL NIL NIL)

(foo :a 1)
; => (1 NIL NIL)

(foo :b 1)
; => (NIL 1 NIL)

(foo :c 1)
; => (NIL NIL 1)

(foo :a 1 :c 3)
; => (1 NIL 3)

(foo :a 1 :b 2 :c 1)
; => (1 2 3)

(foo :a 1 :c 3 :b 2)
; => (1 2 3)
```

既に登場したパラメータを、デフォルト値のフォームとして使用することもできる。

```lisp
(defun foo (&key (a 0) (b 0 b-supplied-p) (c (+ a b)))
  ...)


(foo :a 1)
; => (1 0 1 NIL)

(foo :b 1)
; => (0 1 1 T)

(foo :b 1 :c 4)
; => (0 1 4 T)

(foo :a 2 :b 1 :c 4)
; => (2 1 4 T)
```

呼び出し元がパラメータ指定するために使うキーワードを、実際のパラメータと異なるものにする事もできる。  
もしAPIなどを実装する場合には、このような機能が役立つ。  
つまり、内部的には簡潔な変数名を使用し、外部に公開する引数には説明的なキーワードを使用する。

```lisp
(defun foo (&key ((:apple a)) ((:box b) 0) ((:charlie c) 0 c-supplied-p))
  (list a b c c-supplied-p))

(foo :apple 10 :box 20 :charlie 30)
; => (10 20 30 T)
```

## 5.6 異なるパラメータの併用は注意すべき
上記の、必須パラメータ、オプショナルパラメータ、レストパラメータ、キーワードパラメータは、全て併用することができる。  
ただし、これらには使用して良い順番がある。下記の順番で使用可能である。

1. 必須パラメータ
1. オプショナルパラメータ
1. レストパラメータ
1. キーワードパラメータ

### `&optional`と`&key`は併用禁止・`rest`と`&key`は併用OK
`&optional`と`&key`の組み合わせは、予想外の結果になるため、併用してはいけない。  
というのも、呼び出し元がオプショナルパラメータを全て与えなかった場合、オプショナルパラメータがキーワードパラメータの値を食ってしまうためである。

下記コードの最後の例では、`:z`がオプショナルパラメータとして認識されてしまう。
こうなると、残りは引数3のみである。
これをキーワードパラメータとして解釈することができないため、エラーとなる。

```lisp
(defun foo (x &optional y &key z)
  (list x y z))

;; これは正しく動作する
(foo 1 2 :z 3)
; => (1 2 3)

;; これも正しく動作する
(foo 1)
; => (1 NIL NIL)

;; これはエラーとなる
(foo 1 :z 3)
; => ERROR
```

レストパラメータとキーワードパラメータの組み合わせは、少々とっつきにくいが、安全に動作する。  
下記コードは、レストパラメータとキーワードパラメータの解釈を素直に理解すれば納得できる。

- レストパラメータ…`&rest`シンボル以降の引数を全て集めてリストに入れる
- キーワードパラメータ…`&key`シンボル以降の引数を、キーワードの対として集める

```lisp
(defun foo (&rest rest &key a b c)
  (list a b c))

(foo :a 1 :b 2 :c 3)
; => ((:A 1 :B 2 :C 3) 1 2 3)
```

## 5.7 関数の戻り値
関数の戻り値は、その関数を抜ける最後に評価された値となる。  
関数の任意の箇所で、**直ちに**値を返す場合は、特殊オペレータ`return-from`を使用する。  
ただし、`return-from`は関数から抜けるためだけのオペレータ**ではなく**、`block`で作られた**ブロック**から抜けるために使用するものである。

`defun`は自動的に関数の本文全体を関数と同名の**ブロック**で囲う。  
そのため、`return-from`を関数の名前で評価することにより、戻したい値と一緒に直ちにその関数から脱出できる。

`return-from`には、脱出したいブロックの名前を最初の引数として指定する。  
この名前は評価されないため、**クォート不要**である。

例を下記に示す。  
下記の関数は、ネストしたループを使用して、引数よりも大きな積になる10未満の数の**最初の**ペアを探す。
そして、数のペアが見つかったらすぐに`return-from`を使ってペアを返している。

```lisp
(defun find-less-than-10-pair (n)
  (dotimes (i 10)
    (dotimes (j 10)
	 (when (> (* i j) n)
	   (return-from find-less-than-10-pair (list i j))))))
```

## 5.8 データとしての関数または高階関数
Lispでは関数を第1級オブジェクトとして扱える。つまり、普通のプリミティブなデータのように、変数に代入したりできる。
つまり、Lispの`defun`は、新しい関数オブジェクトを生成して、それに名前をつけているだけである。  
`lambda`を使えば、名前を持たない**無名関数**も作成できる。

ところで、Common Lispは**Lisp-2**と呼ばれている。これは、Common Lispには変数などの為の名前空間と、関数の為の名前空間の2つがあるためである。  
ちなみにSchemeは全てが同一の名前空間に存在するため、**Lisp-1**と呼ばれている。

Lisp-2であるCommon Lispにおいて関数オブジェクトを得るには、特殊オペレータ`function`を使用する。  
引数に関数名を渡すが、これは評価されないため**クォート不要**。

```cl
(function foo)
; #<Interpreted Function FOO>
```

`function`を使うのは煩わしいので、シンタックスシュガー`#'`がよく使われる。

```cl
#'foo
; #<Interpreted Function FOO>
```

関数オブジェクトを評価する、つまり、関数を呼び出すには、`funcall`または`apply`を使う。

`funcall`は、渡す引数の個数が明らかな場合に使用する。
`funcall`では、第1引数に関数オブジェクト、第2引数以降には関数オブジェクトに渡す引数(任意個数)を指定する。

```cl
(funcall #'foo 1 2 3)
; (foo 1 2 3) と等価
```

例えば、任意の関数(数学的な意味で)をプロットするには、下記のようにする。

```cl
(defun plot (fn min max step)
  "fn: プロット対象の関数
   min: xの最小値
   max: xの最大値
   step: 刻み幅"
  (loop for x from min to max by step do
        (loop repeat (funcall fn x) do
          (format t "*"))  ; あるxにおけるfn(x)の値
        (format t "~%")))  ; 改行

(plot #'exp 0 4 1/2)
```

`apply`は、渡す引数の個数が分からない場合に使用する。  
`apply`では、第1引数に関数オブジェクト、第2引数に関数オブジェクトに渡す引数のリストを指定する。  

```cl
(apply #'foo arg-list)
```

`apply`は、関数適用の際に、第2引数のリストを展開して、関数オブジェクトの引数に渡してくれる。  
下記の例では、今度は`#'plot`を関数オブジェクトとして呼び出している。

```cl
(defparameter arg-list '(#'exp 0 4 1/2))
(apply #'plot arg-list)
```

`apply`では、第2引数に渡される引数リストの中身が第1引数に渡される関数オブジェクトが要求する引数の構成を満たせば良い。
つまり、渡される関数の取る引数が`&optional`でも`&rest`でも`&key`でも気にしない。

## 5.9 無名関数
既に何度か登場しているが、無名関数を`lambda`で作成できる。

```cl
(lambda (parameters) body...)
```

無名関数を呼び出すのにも`funcall`が使える。

```cl
(funcall #'(lambda (x y) (+ x y)) 2 3)
; => 5
```

`funcall`を使うとき、歴史的経緯(書籍P.62参照)によって`lambda`には`#'`を付けても付けなくても良い。  
これは、`lambda`が評価されるとき、`(lambda ...)`が`(function (lambda ...))`に自動的に展開されることで実現されている。

```cl
(funcall (lambda (x y) (+ x y)) 2 3)
; => 5
```

また、`lambda`による関数定義自体を呼び出すこともできる。(使いどころは無いが。)

```cl
((lambda (x y) (+ x y)) 2 3)
; => 5
```

注意点として、無名関数を使うのは、下記のように、インラインで記述できるくらいシンプルな処理を他の関数に渡す場合にした方が良い。

```cl
(plot #'(lambda (x) (* 2 x)) 0 10 1)
```

他に無名関数の用途としては、クロージャの作成がある。クロージャに関しては次の章に述べる。
